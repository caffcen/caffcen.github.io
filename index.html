<!DOCTYPE html>
<html lang="zh_CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"caffcen.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="caffcen&#39;s blog">
<meta property="og:url" content="https://caffcen.github.io/index.html">
<meta property="og:site_name" content="caffcen&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="caffcen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://caffcen.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh_CN'
  };
</script>

  <title>caffcen's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">caffcen's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh_CN">
    <link itemprop="mainEntityOfPage" href="https://caffcen.github.io/2023/05/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-AbstractQueuedSynchronizer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="caffcen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caffcen's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-AbstractQueuedSynchronizer/" class="post-title-link" itemprop="url">深入理解 AbstractQueuedSynchronizer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-05-21 18:25:12 / Modified: 18:25:36" itemprop="dateCreated datePublished" datetime="2023-05-21T18:25:12+08:00">2023-05-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>AQS 提供了实现同步阻塞队列的基本框架，是 juc 包中其他众多同步原语和锁实现的基础。</p>
<blockquote>
<p>Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released. Given these, the other methods in this class carry out all queuing and blocking mechanics. Subclasses can maintain other state fields, but only the atomically updated int value manipulated using methods getState, setState and compareAndSetState is tracked with respect to synchronization.</p>
</blockquote>
<p>以上片段摘录自 AQS 源码中的注释，可以总结出以下几点：</p>
<ul>
<li>AQS 提供了一种基于先入先出 FIFO 等待队列的线程同步框架；</li>
<li>AQS 被设计为其他同步器实现的基础，其他同步器需要在内部实现 AQS 的模板方法，来实现自己的同步原语。</li>
</ul>
<h1 id="Node-数据结构"><a href="#Node-数据结构" class="headerlink" title="Node 数据结构"></a>Node 数据结构</h1><p><code>Node</code> 结构是 AQS 阻塞队列实现的基础结构，是 AQS 排队、获取锁、释放锁等行为被操作的对象。其实现基于 CLH Queue Lock 中的节点数据结构，关于 CLH Queue Lock，可以参考笔者之前的博客（<a href="https://caffcen.github.io/2023/04/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-CLH-Queue-Lock/">深入理解 CLH Queue Lock | caffcen’s blog</a>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();  <span class="comment">// 节点处于共享等待的标识</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">// 节点处于独占等待的标识</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;  <span class="comment">// 线程的状态</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;  <span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;  <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;  <span class="comment">// 节点对应的线程</span></span><br><span class="line"></span><br><span class="line">    Node nextWaiter;  <span class="comment">// 指向下一个等待在条件变量上的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>waitStatus</code> 可能有几种取值：</p>
<ol>
<li><code>0</code> : 节点初始化时候的值</li>
<li><code>CANCELLED = 1</code> : 表示节点由于超时或者被打断，『取消』排队</li>
<li><code>SIGNAL = -1</code> : 当前节点如果是 <code>SIGNAL</code> 则表示后继结点需要被唤醒，或者换过来说，如果当前节点想要被唤醒并尝试获取锁，则需要前驱节点的 <code>waitStatus</code> 是 <code>SIGNAL</code></li>
<li><code>CONDITION = -2</code> : 表示节点位于条件变量的等待队列中</li>
<li><code>PROPAGATE = -3</code> : 仅在释放共享锁时使用到</li>
</ol>
<p><code>Node</code> 类是构建起 AQS 阻塞双向队列的基础节点数据结构， <code>prev</code> 和 <code>next</code> 变量实现了双向队列， <code>waitStatus</code> 表示节点对应的线程的等待状态。</p>
<h1 id="AQS-队列"><a href="#AQS-队列" class="headerlink" title="AQS 队列"></a>AQS 队列</h1><p>AQS 双向等待 FIFO 队列的实现基于上面提到 <code>Node</code> 数据结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Head of the wait queue, lazily initialized.  Except for</span></span><br><span class="line"><span class="comment">     * initialization, it is modified only via method setHead.  Note:</span></span><br><span class="line"><span class="comment">     * If head exists, its waitStatus is guaranteed not to be</span></span><br><span class="line"><span class="comment">     * CANCELLED.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tail of the wait queue, lazily initialized.  Modified only via</span></span><br><span class="line"><span class="comment">     * method enq to add new wait node.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The synchronization state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>state</code> 字段是 AQS 的同步状态字段，主要通过 <code>compareAndSetState</code> （内部实现基于 Unsafe 的 CAS 操作）进行原子地更新。</p>
<h2 id="线程节点入队"><a href="#线程节点入队" class="headerlink" title="线程节点入队"></a>线程节点入队</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;  <span class="comment">// 获取队列尾部节点</span></span><br><span class="line">            <span class="comment">// 如果没有初始化，则原子地设置 head</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;  <span class="comment">// node 将要成为队列的新 tail，因此更新 t 为 node 的前驱节点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;  <span class="comment">// 原子地更新</span></span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;  <span class="comment">// 更新成功则返回 node 的前驱节点，否则进入下一次循环直至成功</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="comment">// 尝试原子地更新尾结点，如果成功则直接返回，否则调用 enq 入队</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 快速入队失败，调用 enq 入队</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="线程节点出队"><a href="#线程节点出队" class="headerlink" title="线程节点出队"></a>线程节点出队</h2><p>节点出队列则很简单，把 <code>head</code> 设为当前节点即可：</p>
<blockquote>
<p>To dequeue, you just set the head field.</p>
</blockquote>
<h1 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h1><blockquote>
<p>Subclasses should be defined as non-public internal helper classes that are used to implement the synchronization properties of their enclosing class. Class AbstractQueuedSynchronizer does not implement any synchronization interface. Instead it defines methods such as acquireInterruptibly that can be invoked as appropriate by concrete locks and related synchronizers to implement their public methods.</p>
</blockquote>
<p>AQS 是非常优秀的模板模式的实现和应用，它提供以下模板方法供实现类实现，以达到不同的同步原语以及同步器机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span>;  <span class="comment">// 尝试获取独占锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span>;  <span class="comment">// 尝试释放独占锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span>;  <span class="comment">// 尝试获取共享锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> arg)</span>;  <span class="comment">// 尝试释放共享锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span>;  <span class="comment">// 返回共享资源是否以独占的方式被占用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ReentrantLock-如何实现-AQS"><a href="#ReentrantLock-如何实现-AQS" class="headerlink" title="ReentrantLock 如何实现 AQS"></a>ReentrantLock 如何实现 AQS</h2><p>我们以 <code>ReentrantLock</code> 为例来看一下 juc 包中的同步器和 AQS 是如何搭配使用的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;...&#125;</span><br><span class="line">	    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;...&#125;</span><br><span class="line">	    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">		<span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;...&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">		<span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;...&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ReentrantLock</code> 内部类 <code>Sync</code> 继承了 AQS，同时实现了 <code>tryRelease</code> 接口来释放锁，同时，为了同时实现公平锁和非公平锁的加锁逻辑， <code>ReentrantLock</code> 还提供了 <code>NonfairSync</code> 和 <code>FairSync</code> 来实现不同的 <code>tryAcquire</code> 逻辑。</p>
<p>可见 AQS 负责维护队列状态、更新同步状态等底层操作，这些操作对任何的同步器都是相同的，并且暴露出了 5 个模板接口供实现类实现，这样实现类仅仅需要关注自己的同步原语的实现即可，不用关注相同的底层逻辑。</p>
<h1 id="独占锁模式"><a href="#独占锁模式" class="headerlink" title="独占锁模式"></a>独占锁模式</h1><h2 id="独占锁模式下的加锁操作"><a href="#独占锁模式下的加锁操作" class="headerlink" title="独占锁模式下的加锁操作"></a>独占锁模式下的加锁操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment">     * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment">     * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">	    <span class="comment">// 尝试获取锁，如果获取成功直接返回</span></span><br><span class="line">	    <span class="comment">// tryAcquire 由具体的同步器实现</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  <span class="comment">// 无法获取到资源，先加入队列，再尝试获取</span></span><br><span class="line">            selfInterrupt();  <span class="comment">// 中断当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment">     * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();  <span class="comment">// 取前置节点</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">				<span class="comment">// 只有前置节点已经获取了锁，即前置节点成为了队列的 head 也就是出队时，尝试获取锁</span></span><br><span class="line">                    setHead(node);  <span class="comment">// 获取锁成功，出队列，返回</span></span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取锁失败，调用 shouldParkAfterFailedAcquire 看是否需要睡眠当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment">     * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment">     * control in all acquire loops.  Requires that pred == node.prev.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pred node&#x27;s predecessor holding status</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 取前置节点的 waitStatus</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 前置节点的 SIGNAL 已设置，当前可以安全地睡眠，返回 true</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 前驱节点对应的线程不再尝试获取锁，不断往前遍历知道找到一个状态为非取消的节点</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">// 设置前驱节点的状态为 SIGNAL，之后当前线程才能够被唤醒</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结一下加锁过程：</p>
<ul>
<li>调用 <code>acquire</code> 获取锁， <code>acquire</code> 内部调用同步器内部类实现的 <code>tryAcquire</code> 尝试获取锁，加锁成功则直接返回，否则将线程节点加入等待队列中，并调用 <code>acquireQueued</code> 继续尝试获取锁；</li>
<li><code>acquireQueued</code> 有一个无限循环来不断尝试获取锁。当前驱节点为 <code>head</code> 时才会调用 <code>tryAcquire</code> 来获取锁，这和 CLH 队列锁的加锁操作如出一辙：只有等前驱节点成功获取锁并解锁后，当前节点才能够取获取锁。这里贴出了 CLH 队列锁加锁的代码供对比参考：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CLHLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">qnode</span> <span class="operator">=</span> myNode.get();</span><br><span class="line">        qnode.locked = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">pred</span> <span class="operator">=</span> tail.getAndSet(qnode);</span><br><span class="line">        myPred.set(pred);</span><br><span class="line">        <span class="keyword">while</span> (pred.locked) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>acquireQueued</code> 如果加锁成功，那么则会将 <code>head</code> 设为当前节点，将当前节点出队并返回；否则调用 <code>shouldParkAfterFailedAcquire</code></li>
<li><code>shouldParkAfterFailedAcquire</code> 方法是用来在当前线程没有成功获取到锁时，检查并更新节点状态的。其有几个功能：<ol>
<li>判断当前线程是否能够『安全地』休眠，即判断前驱结点的 <code>waitStatus</code> 是否为 <code>SIGNAL</code> ；</li>
<li>如果前驱节点取消了排队，则不断往前寻找一个未取消的节点，当做当前节点的前置节点；</li>
<li>如果前驱节点的 <code>waitStatus</code> 不为 <code>SIGNAL</code> ，则原子性的更新为 <code>SIGNAL</code> ，方便当前节点之后被阻塞</li>
<li>返回当前线程是否能够休眠；</li>
</ol>
</li>
</ul>
<p>总的来说，AQS 共享锁的加锁逻辑和 CLH 队列锁的加锁逻辑本质上是相同的：当前线程只有在它的前驱节点的线程获取到锁之后，才可以尝试去获取锁，且它们都采用的是一种自旋忙等待的方式，不断地测试前置节点的状态来实现的。</p>
<p>不同点在于 AQS 通过 <code>shouldParkAfterFailedAcquire</code> 方法可以让当前忙等待的线程被阻塞，好让出 CPU 时间。</p>
<h2 id="独占锁模式下的解锁操作"><a href="#独占锁模式下的解锁操作" class="headerlink" title="独占锁模式下的解锁操作"></a>独占锁模式下的解锁操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment">     * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment">     * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">// 调用同步器实现的 tryRelease</span></span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="comment">// 如果成功释放，则调用 unparkSuccessor 唤醒可能在睡眠的后继节点线程</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wakes up node&#x27;s successor, if one exists.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">// 如果后继节点取消了排队，则从 tail 开始往队列头部遍历，找到 node 后第一个未取消排队的节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果后继节点存在，则唤醒它</span></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>共享模式下解锁的操作则简单很多，主要工作是唤醒当前节点的后继节点。</p>
<h1 id="共享锁模式"><a href="#共享锁模式" class="headerlink" title="共享锁模式"></a>共享锁模式</h1><h2 id="共享锁模式下的加锁操作"><a href="#共享锁模式下的加锁操作" class="headerlink" title="共享锁模式下的加锁操作"></a>共享锁模式下的加锁操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared mode, ignoring interrupts.  Implemented by</span></span><br><span class="line"><span class="comment">     * first invoking at least once &#123;<span class="doctag">@link</span> #tryAcquireShared&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquireShared&#125; until success.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">     *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">	    <span class="comment">// 调用同步器实现的 tryAcquireShared 方法</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">	        <span class="comment">// 失败，调用 doAcquireShared 方法继续不断尝试</span></span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">	    <span class="comment">// 获取锁失败，现将线程入队</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="comment">// 和独占模式相同，只有前置节点为 head 时才能够尝试获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                    <span class="comment">// r &gt;= 0 表示获取锁成功</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">	                    <span class="comment">// 当前线程出队，并将 release 信息传播给后继节点</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 获取锁失败，判断是否需要休眠</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets head of queue, and checks if successor may be waiting</span></span><br><span class="line"><span class="comment">     * in shared mode, if so propagating if either propagate &gt; 0 or</span></span><br><span class="line"><span class="comment">     * PROPAGATE status was set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> propagate the return value from a tryAcquireShared</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        <span class="comment">// 设置 head 为当前节点，表示当前节点已经获取到了临界资源，出队</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">         *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">         *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">         *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">         *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">         *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">         * and</span></span><br><span class="line"><span class="comment">         *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">         *     or we don&#x27;t know, because it appears null</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">         * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">         * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">         * anyway.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当满足任一条件时，则唤醒后继节点让其尝试进入临界区</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Release action for shared mode -- signals successor and ensures</span></span><br><span class="line"><span class="comment">     * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment">     * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">         * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">         * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">         * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">         * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">         * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">         * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">         * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">         * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 当 waitStatus 为 SIGNAL 时，需要唤醒后继节点</span></span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="comment">// recheck 保证线程安全</span></span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    <span class="comment">// 唤醒后继节点</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="comment">// 为了保证将唤醒操作传播出去，需要设置 waitStatus 为 PROPAGATE</span></span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 head 变更，说明有其他节点也成功释放了临界资源，它将会负责唤醒后继的阻塞节点，当前线程可以退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>共享模式和独占模式加锁的区别主要是：</p>
<ol>
<li>可以有多个线程同时尝试获取锁；独占模式只能有一个；</li>
<li>共享锁模式下，如果一个线程成功获取到了锁，那么它还会同时尝试去唤醒其他等待着的线程；而独占模式只有在解锁后才会去唤醒队列中阻塞的节点。</li>
</ol>
<p>共享锁模式比较重要的是 <code>setHeadAndPropagate</code> 和 <code>doReleaseShared</code> 。 <code>setHeadAndPropagate</code> 会进行两个操作：</p>
<ol>
<li>将获取了锁的线程出队，即将 <code>head</code> 设为当前节点；</li>
<li>满足一下条件时，调用 <code>doReleaseShared</code> 唤醒队列中阻塞的线程：<ol>
<li><code>propagate &gt; 0</code> : 表示还有资源剩余可以索取</li>
<li><code>h == null</code></li>
<li><code>h.waitStatus &lt; 0</code></li>
<li><code>(h = head) == null</code></li>
<li><code>h.waitStatus &lt; 0</code></li>
</ol>
</li>
</ol>
<p><code>doReleaseShared</code> 则是在尝试不断地唤醒符合条件的节点。</p>
<p>总结一下共享模式加锁：</p>
<ul>
<li>调用 <code>acquireShared</code> 加锁。会调用同步器实现的 <code>tryAcquireShared</code> 方法尝试获取锁，如果成功直接返回；否则调用 <code>doAcquireShared</code></li>
<li><code>doAcquireShared</code> 首先会将当前线程入队；之后则会尝试获取锁：<ul>
<li>先判断自己的前驱节点是否是 <code>head</code> ，是的话则尝试获取锁，如果成功则调用 <code>setHeadAndPropagate</code> ，将 <code>head</code> 设置为自己，同时唤醒队列中阻塞的节点</li>
<li>如果自己的前驱节点不是 <code>head</code> ，又或者获取锁失败，则调用 <code>shouldParkAfterFailedAcquire</code> 判断自己是否需要休眠，这和独占锁模式是一模一样的</li>
</ul>
</li>
<li><code>setHeadAndPropagate</code> 首先将当前获得了共享锁的节点出队，之后在满足条件的情况下，尝试唤醒队列中被阻塞的线程</li>
<li><code>doReleaseShared</code> 不断尝试唤醒被阻塞的线程，直到 <code>head</code> 因为某个线程也成功地获得到了共享锁而被更新为止</li>
</ul>
<h2 id="共享锁模式下的解锁操作"><a href="#共享锁模式下的解锁操作" class="headerlink" title="共享锁模式下的解锁操作"></a>共享锁模式下的解锁操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Releases in shared mode.  Implemented by unblocking one or more</span></span><br><span class="line"><span class="comment">     * threads if &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; returns true.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">     *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryReleaseShared&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解锁操作很简单，调用了同步器实现的 <code>tryReleaseShared</code> 方法，如果成功释放了共享资源则调用 <code>doReleaseShared</code> 唤醒后续线程。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li>AQS 源码</li>
<li><a target="_blank" rel="noopener" href="https://gee.cs.oswego.edu/dl/papers/aqs.pdf">https://gee.cs.oswego.edu/dl/papers/aqs.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用 - 美团技术团队</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/taleLaugh/p/15257784.html">Java并发之AQS详解 - 拉夫德鲁 - 博客园</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh_CN">
    <link itemprop="mainEntityOfPage" href="https://caffcen.github.io/2023/04/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-CLH-Queue-Lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="caffcen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caffcen's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-CLH-Queue-Lock/" class="post-title-link" itemprop="url">深入理解 CLH Queue Lock</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-09 16:04:06 / Modified: 16:05:20" itemprop="dateCreated datePublished" datetime="2023-04-09T16:04:06+08:00">2023-04-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>JUC 包中的很多同步原语是基于 AbstractQueuedSynchronizer（以下简称 AQS） 实现的，而 AQS 的实现又是基于 CLH 队列锁（CLH queued lock），因此学习并理解 CLH 队列锁对我们学习 JUC 中的各种同步原语非常有帮助。本文将阐述 CLH 队列锁的实现和原理。</p>
<h1 id="CLH-Queue-Lock"><a href="#CLH-Queue-Lock" class="headerlink" title="CLH Queue Lock"></a>CLH Queue Lock</h1><p>CLH 队列锁是由 Craig, Landin, Hagersten 三位大佬提出的，因此被称为 CLH 队列锁，它是一种自旋公平锁，基于虚链表实现（virtual linked list）。</p>
<p>《The Art of Multiprocessor Programming》7.5.2 节给出了 CLH 可能的一种 Java 语言实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CLHLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    AtomicReference&lt;QNode&gt; tail;</span><br><span class="line">    ThreadLocal&lt;QNode&gt; myPred;</span><br><span class="line">    ThreadLocal&lt;QNode&gt; myNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CLHLock</span><span class="params">()</span> &#123;</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;QNode&gt;(<span class="keyword">new</span> <span class="title class_">QNode</span>());</span><br><span class="line"></span><br><span class="line">        myNode = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;QNode&gt;() &#123;</span><br><span class="line">            <span class="keyword">protected</span> QNode <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">QNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        myPred = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;QNode&gt;() &#123;</span><br><span class="line">            <span class="keyword">protected</span> QNode <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">qnode</span> <span class="operator">=</span> myNode.get();</span><br><span class="line">        qnode.locked = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">pred</span> <span class="operator">=</span> tail.getAndSet(qnode);</span><br><span class="line">        myPred.set(pred);</span><br><span class="line">        <span class="keyword">while</span> (pred.locked) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">qnode</span> <span class="operator">=</span> myNode.get();</span><br><span class="line">        qnode.locked = <span class="literal">false</span>;</span><br><span class="line">        myNode.set(myPred.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来将会对源码以及其中各个关键技术进行分析。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="QNode"><a href="#QNode" class="headerlink" title="QNode"></a>QNode</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">locked</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>QNode</code> 记录一个线程的同步状态，它只有一个实例字段 <code>locked</code> ，其含义为：</p>
<ul>
<li><code>true</code> ：表示该线程要么已经拿到了锁，要么等待获取锁</li>
<li><code>false</code> ：表示该线程已经释放了锁。</li>
</ul>
<h3 id="Virtual-Linked-List"><a href="#Virtual-Linked-List" class="headerlink" title="Virtual Linked List"></a>Virtual Linked List</h3><p><code>CLHLock</code> 类中有三个实例字段，共同构成了 CLH 队列锁的虚队列结构：</p>
<ol>
<li><code>AtomicReference&lt;QNode&gt; tail</code> ：指向最后加入虚队列的线程节点</li>
<li><code>ThreadLocal&lt;QNode&gt; myPred</code> ：每个线程独有，指向该线程的前继节点的 <code>QNode</code></li>
<li><code>ThreadLocal&lt;QNode&gt; myNode</code> ：每个线程独有，指向线程自己的 <code>QNode</code></li>
</ol>
<p><code>tail</code> 节点是始终指向虚队列的尾结点，即最后加入队列的线程节点。因其是 <code>AtomicReference</code> 类型，因此对其的操作都可以保证是原子性的，不会造成线程不安全的问题。</p>
<p>而之所以称 CLH 队列锁的数据结构是一个虚队列，是因为每个线程只能通过 <code>prev</code> 节点访问到它的前继节点，链表结构对我们来说是『隐式』的。</p>
<blockquote>
<p>We use the term “virtual” because the list is implicit: Each thread refers to its predecessor through a thread-local pred variable.</p>
</blockquote>
<p>CLH 队列是根据线程请求锁的顺序来进行排列的，因此是 First-in-first-out 的，满足公平锁的定义。</p>
<h2 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 获取当前线程的 QNode</span></span><br><span class="line">    <span class="type">QNode</span> <span class="variable">qnode</span> <span class="operator">=</span> myNode.get();</span><br><span class="line">    <span class="comment">// 将 myNode.locked 置为 true，表示当前线程想要获取锁</span></span><br><span class="line">    qnode.locked = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 通过 tail 获取队列末尾的线程 QNode</span></span><br><span class="line">    <span class="comment">// 并且更新 tail 节点指向当前线程，CAS 操作保证原子性</span></span><br><span class="line">    <span class="comment">// 现在当前线程排到了队列的末尾</span></span><br><span class="line">    <span class="type">QNode</span> <span class="variable">pred</span> <span class="operator">=</span> tail.getAndSet(qnode);</span><br><span class="line">    <span class="comment">// 设置当前线程的前继节点 myPred</span></span><br><span class="line">    myPred.set(pred);</span><br><span class="line">    <span class="comment">// 在 pred 上忙等待，直到前继节点将其 locked 更新为 flase</span></span><br><span class="line">    <span class="keyword">while</span> (pred.locked) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个线程获取锁的步骤可以总结为：</p>
<ol>
<li>将自己的 <code>QNode</code> 状态置为 <code>true</code> ，表示自己想要获取锁。</li>
<li>将自己加入到虚队列的末尾（即让 <code>tail</code> 指向自己的 <code>QNode</code> ），同时得到自己的前继节点的 <code>QNode</code> ，这是一个原子操作，由 <code>AtomicReference</code> 类型保证。</li>
<li>在前继节点 <code>myPred</code> 的 <code>QNode</code> 上进行忙等待，直到前继节点释放锁为止。</li>
</ol>
<h2 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// 获取当前线程 QNode</span></span><br><span class="line">    <span class="type">QNode</span> <span class="variable">qnode</span> <span class="operator">=</span> myNode.get();</span><br><span class="line">    <span class="comment">// 将其置为 false，表示当前线程离开临界区，并释放锁</span></span><br><span class="line">    qnode.locked = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 循环利用 QNode，且防止该线程下次加锁时发生死锁</span></span><br><span class="line">    myNode.set(myPred.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线程解锁的步骤可以总结为：</p>
<ol>
<li>获取当前线程的 <code>QNode</code></li>
<li>将当前线程的 <code>QNode</code> 状态置为 <code>false</code> ，表示当前线程已经处理完临界区的工作，释放锁</li>
<li>更新 <code>myNode</code> 引用，使其指向一个新的 <code>QNode</code> 对象，防止死锁。</li>
</ol>
<h3 id="死锁的可能性以及-QNode-的回收利用"><a href="#死锁的可能性以及-QNode-的回收利用" class="headerlink" title="死锁的可能性以及 QNode 的回收利用"></a>死锁的可能性以及 QNode 的回收利用</h3><p>可能有读者会奇怪这里为什么需要更新 <code>myNode</code> 引用，能不能不更新 <code>myNode</code> 引用，直接从方法调用中返回呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">QNode</span> <span class="variable">qnode</span> <span class="operator">=</span> myNode.get();</span><br><span class="line">    qnode.locked = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 不更新 myNode 引用直接返回</span></span><br><span class="line">    <span class="comment">// myNode.set(myPred.get());</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不更新 <code>myNode</code> 对象，那么可能会出现如下的情况：</p>
<p><img src="/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-CLH-Queue-Lock/Pasted%20image%2020230409152218.png"></p>
<p>假设整个 CLH 队列中只有一个线程，它能够立刻获得锁（因为没有前继节点持有锁）并进入临界区。它在执行完临界区工作后释放了锁，将自己的 <code>QNode</code> 置为 <code>flase</code> ，那么将变成下图的情况：</p>
<p><img src="/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-CLH-Queue-Lock/Pasted%20image%2020230409152556.png"></p>
<p>之后，该线程立刻再次尝试获取锁，这个时候，CLH 队列的情况和上图是一致的，因为我们在解锁时没有更新 <code>myNode</code> 引用，那么 <code>tail</code> 节点和该线程的 <code>myNode</code> 节点指向的是同一个内存对象。那么考虑该线程重新尝试加锁时会发生什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">// qnode 即为上次加锁、解锁中使用的 QNode 数据结构</span></span><br><span class="line">    <span class="type">QNode</span> <span class="variable">qnode</span> <span class="operator">=</span> myNode.get();</span><br><span class="line">    <span class="comment">// 将 myNode.locked 置为 true</span></span><br><span class="line">    qnode.locked = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 通过 tail 获取队列末尾的线程 QNode，tail 此时指向的对象既为该线程自己的 myNode</span></span><br><span class="line">    <span class="comment">// 也就是上上条语句 QNode qnode = myNode.get(); 拿到的 QNode 引用</span></span><br><span class="line">    <span class="type">QNode</span> <span class="variable">pred</span> <span class="operator">=</span> tail.getAndSet(qnode);</span><br><span class="line">    <span class="comment">// 设置当前线程的前继节点 myPred，这个时候 myPred 指向了 myNode</span></span><br><span class="line">    <span class="comment">// 也就是说该线程的前继线程是自己，明显是错误的</span></span><br><span class="line">    myPred.set(pred);</span><br><span class="line">    <span class="comment">// pred.locked == myNode.locked &amp;&amp; myNode.locked == true，死锁</span></span><br><span class="line">    <span class="keyword">while</span> (pred.locked) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过注释可以清晰地看到，因为 <code>tail</code> 指向了想要重新获取锁的这条线程，那么这个线程的 <code>myNode</code> 和 <code>myPred</code> 将指向同一个对象，最终将永远忙等待下去。这也就是为什么我们需要在解锁时更新 <code>myNode</code> 的原因，这是为了让同一个线程再次加锁时不发生死锁而必要的一个操作。</p>
<p>而《The Art of Multiprocessor Programming》的实现中是将 <code>myPred</code> 直接赋值给了 <code>myNode</code> ，这是因为前继节点对应的线程已经离开了临界区，自然它的 <code>QNode</code> 就不会再被使用了，这里循环使用了内存中的对象。其实也可以重新实例化一个新的 <code>QNode</code> 并赋值给 <code>myNode</code> 也是可以的。《The Art of Multiprocessor Programming》的一条脚注说明了这一点：</p>
<blockquote>
<p>There is no need to reuse nodes in garbage-collected languages such as Java or C#, but reuse would be needed in languages such as C++ or C.</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CLH 队列锁通过一个虚队列来维护想要获取锁的线程，每当一个线程想要获取锁时，CLH 将其放到队列的末尾，并让其获得它的前继节点（即排在它前面的线程）的 <code>QNode</code> 引用。一个线程通过在它的前继节点的 <code>QNode</code> 状态上进行自旋，判断它能否获取到锁。</p>
<p>CLH 队列锁的缺点是它在无缓存的 NUMA 架构机器上性能并不好。因为每个线程都自旋在另一个线程的 <code>QNode</code> 状态上，而另一个线程的 <code>QNode</code> 状态对象可能存放在另一个 CPU 的本地内存中，这将导致这种自旋操作将变得很慢。如果是在 SMP 架构的机器上，因为内存读取的开销是统一的，因此该算法的性能就很好。</p>
<blockquote>
<p>Perhaps the only disadvantage of this lock algorithm is that it performs poorly on cacheless NUMA architectures. Each thread spins waiting for its predecessor’s node’s <code>locked</code> ﬁeld to become <code>false</code>. If this memory location is remote, then performance suffers. On cache-coherent architectures, however, this approach should work well.</p>
</blockquote>
<h1 id="Referece"><a href="#Referece" class="headerlink" title="Referece"></a>Referece</h1><ol>
<li>The Art of Multiprocessor Programming 7.5.2</li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/43628187/why-clh-lock-need-prev-node-in-java">multithreading - Why CLH Lock need prev-Node in java - Stack Overflow</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6864210697292054541">AQS基础——多图详解CLH锁的原理与实现 - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6981431787746492447">🏆【数据结构之旅】「线程锁算法专项」引领你走进CLH队列锁机制原理世界 - 掘金</a></li>
<li><a target="_blank" rel="noopener" href="https://gee.cs.oswego.edu/dl/papers/aqs.pdf">https://gee.cs.oswego.edu/dl/papers/aqs.pdf</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh_CN">
    <link itemprop="mainEntityOfPage" href="https://caffcen.github.io/2023/04/02/LeetCode-%E7%AC%94%E8%AE%B0-5%EF%BC%9ASearch-in-Rotated-Sorted-Array/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="caffcen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caffcen's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/02/LeetCode-%E7%AC%94%E8%AE%B0-5%EF%BC%9ASearch-in-Rotated-Sorted-Array/" class="post-title-link" itemprop="url">LeetCode 笔记 5：Search in Rotated Sorted Array</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-02 16:09:48 / Modified: 16:12:01" itemprop="dateCreated datePublished" datetime="2023-04-02T16:09:48+08:00">2023-04-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天要讲的题目都使用到了二分查找（或者和二分查找紧密相关），同时又都是基于一个 Rotated Sorted Array。那么先从 Rotated Sorted Array 的特点讲起吧。</p>
<p>Rotated Sorted Array 的定义是这样子的：</p>
<blockquote>
<p>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values). <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 &lt;= k &lt; nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>).</p>
</blockquote>
<p>就拿 <code>int[] nums = new int[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;</code> 举例好了，如果 <code>nums</code> 在 <code>nums[4]</code> 位置进行旋转，那么它将变成： <code>&#123;4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3&#125;</code> ，那么我们能够观察到几个特性：</p>
<ol>
<li><code>nums</code> 被分成了两个区间，两个区间都是排好序的（严格上升）</li>
<li><code>nums</code> 第二个区间的所有元素小于第一个区间的最小元素</li>
</ol>
<p>拿 <code>&#123;4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3&#125;</code> 举例来说，从 <code>nums[0]</code> 到 <code>nums[5]</code> 是第一个区间（ <code>&#123;4, 5, 6, 7, 8, 9, 10&#125;</code> ），这个区间是排好序的，从 <code>nums[6]</code> 到 <code>nums[9]</code> 是第二个区间，第二个区间也是排好序的。同时第二个区间的所有值均小于第一个区间的所有值。</p>
<p>根据这两个特性，我们就能够在子区间中使用二分查找来缩小查找范围了。如何在 rotated sorted array 中使用二分查找算法，请看题：</p>
<h1 id="Search-in-Rotated-Sorted-Array"><a href="#Search-in-Rotated-Sorted-Array" class="headerlink" title="Search in Rotated Sorted Array"></a>Search in Rotated Sorted Array</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目 1"></a>题目 1</h2><p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-in-rotated-sorted-array/">33. Search in Rotated Sorted Array</a>：</p>
<p><img src="/images/LeetCode-%E7%AC%94%E8%AE%B0-5%EF%BC%9ASearch-in-Rotated-Sorted-Array/Pasted%20image%2020230402150142.png"></p>
<p>算法思路是这样子的：</p>
<ol>
<li>定义 <code>left, right, mid</code> ，计算 <code>mid</code> ，如果 <code>nums[mid] == target</code> ，那么就返回结果。</li>
<li>否则，我们需要缩小我们的查找空间。如何做呢？我们需要比较 <code>nums[left]</code> , <code>nums[mid]</code> 和 <code>nums[right]</code> 的大小来判断当前的子区间是否是排好序的（即判断 <code>[left, mid]</code> 及 <code>[mid, right]</code> 这两个区间是否是排好序的）：<ul>
<li>如果 <code>nums[left] &lt;= nums[mid]</code> ，那么说明 <code>[left, mid]</code> 这个子区间是有序的；</li>
<li>如果 <code>nums[mid] &lt;= nums[right]</code> ，那么说明 <code>[mid, right]</code> 这个子区间是有序的；</li>
</ul>
</li>
<li>在子区间是有序的前提下，我们再来判断 <code>target</code> 是否在该子区间中，以及它和 <code>nums[mid]</code> 的大小关系。<strong>之所以要在有序的子区间内进行比较的原因是，二分查找算法只能使用在排好序的数据集合当中。</strong> 根据 <code>nums[mid]</code> 和 <code>target</code> 的大小关系比较，来移动左端点和右端点，就像寻常的二分查找那样：<ul>
<li>如果 <code>nums[left] &lt;= nums[mid]</code> ，那么可能存在两种情况：<ol>
<li><code>nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]</code> ，说明 <code>target</code> 在 <code>[left, mid]</code> 这个区间内，我们只需要将 <code>right</code> 左移到 <code>mid - 1</code> 处即可；</li>
<li>否则，说明 <code>target</code> 不在 <code>[left, mid]</code> 区间内，我们右移 <code>left</code> 节点即可。</li>
</ol>
</li>
<li>如果是右半边子区间是有序的 (即 <code>nums[mid] &lt;= nums[right]</code> )，同样可能存在两种情况：<ol>
<li><code>nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]</code> ：说明 <code>target</code> 在 <code>[mid, right]</code> 这个区间内，右移 <code>left</code> 左端点；</li>
<li>否则，说明 <code>target</code> 不在这个区间内，我们左移 <code>right</code> 。</li>
</ol>
</li>
</ul>
</li>
<li>重复以上步骤直到找到了 <code>target</code> ，或 <code>left &gt; right</code> 。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>, mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<ul>
<li>时间复杂度： <code>O(logN)</code></li>
<li>空间复杂度： <code>O(1)</code></li>
</ul>
<p>笔者认为，这类题目的关键点在于如何在找出可以使用二分查找的子区间上。因为 Rotated Sorted Array 的特性，导致我们无法确定 <code>[left, right]</code> 这个区间是排好序的，因此我们只能去分析更小范围的子区间的情况，也就是 <code>[left, mid]</code> 和 <code>[mid, right]</code> 这两个更小的子区间。一旦我们找到了排好序的区间，那么就可以使用二分查找算法的思想，来缩小搜索范围。</p>
<h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目 2"></a>题目 2</h2><p><img src="/images/LeetCode-%E7%AC%94%E8%AE%B0-5%EF%BC%9ASearch-in-Rotated-Sorted-Array/Pasted%20image%2020230402152506.png"></p>
<p>这道题目在上一道题目的基础上只有一个不同，那就是 <code>nums</code> 可能存在重复元素，而这将影响我们的算法，举个例子：</p>
<p><code>int[] nums = new int[]&#123;1, 1, 1, 1, 1, 0, 1, 1, 1, 1&#125;</code></p>
<p>假设 <code>nums</code> 是这个样子的，我们只需要演算一下我们算法的第一次迭代即可看出问题：</p>
<ul>
<li><code>left = 0</code> , <code>right = 9</code> , <code>mid = 0 + (9 - 0) / 2 = 4</code> ；</li>
<li><code>nums[left] &lt;= nums[mid]</code> ，同时， <code>nums[mid] &lt;= nums[right]</code> ；</li>
</ul>
<p>我们发现 <code>nums[mid] &lt;= nums[right]</code> ，那么按照我们之前的想法， <code>[mid, right]</code> 这个子区间应该是排好序的，但是 <code>&#123;1, 0, 1, 1, 1, 1&#125;</code> 却不是一个有序的数组。问题就出在重复元素上。</p>
<p>解决方法其实也很简单，我们只需要略过这些重复的、影响对我们数组是否有序判断的元素即可，整体算法不变：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>, mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left + <span class="number">1</span> &lt;= right &amp;&amp; nums[left + <span class="number">1</span>] == nums[left]) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (right - <span class="number">1</span> &gt;= left &amp;&amp; nums[right - <span class="number">1</span>] == nums[right]) &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这两道题都是笔者之前博客 <a href="https://caffcen.github.io/2023/03/12/LeetCode-%E7%AC%94%E8%AE%B0-4%EF%BC%9ABinary-Search-%E7%9A%845%E7%A7%8D%E5%8F%98%E4%BD%93%E5%BA%94%E7%94%A8/">LeetCode 笔记 4：Binary Search 的5种变体应用 | caffcen’s blog</a> 中提到的二分查找的第一种应用 Contains（即用二分查找判断排序数组是否包含目标）。</p>
<h1 id="Search-the-Minimum-in-Rotated-Sorted-Array"><a href="#Search-the-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="Search the Minimum in Rotated Sorted Array"></a>Search the Minimum in Rotated Sorted Array</h1><h2 id="题目-1-1"><a href="#题目-1-1" class="headerlink" title="题目 1"></a>题目 1</h2><p><img src="/images/LeetCode-%E7%AC%94%E8%AE%B0-5%EF%BC%9ASearch-in-Rotated-Sorted-Array/Pasted%20image%2020230402153454.png"></p>
<p>这道题目和之前题目的区别在于，之前题目给出了 <code>target</code> ，而这两个题目的 <code>target</code> 是 <code>nums</code> 中最小的元素。解决方法也很简单，只需要用到我们开篇提到的 rotated sorted array 的一个特性即可：</p>
<blockquote>
<p>Rotated sorted array 的第一个子区间的最小值，大于第二个子区间的所有值。</p>
</blockquote>
<p>既然第一个子区间的最小值都大于第二个子区间的所有值，那么整个 <code>nums</code> 中的最小值就是第二个子区间的第一个值了。那么目标就是去寻找第二个子区间的第一个值。</p>
<p>那么如何去寻找这个值呢？其实很简单，我们只需要做一定的转换即可：根据 rotated sorted array 的特性我们知道，第一个子区间的所有值均大于第二个子区间的所有值，那么我们二分查找时定义的右端点，一定小于左端点，即 <code>nums[left] &lt; nums[right]</code> ，同时，第一个子区间中的所有值均大于 <code>nums[right]</code> ，它们也都不是我们要找的解。而题目的解即<strong>第一个</strong>值小于 <code>nums[right]</code> 的元素。</p>
<p>为了更好理解，我们定义这样一个有序集合 <code>S = [a1, a2, a3, ..., an]</code> ，同时 <code>S</code> 中的元素 <code>a</code> 表示 <code>nums</code> 的下标，且 <code>a1 &lt; a2 &lt; a3 &lt; ... &lt; an</code> 。同时，它们都满足 <code>nums[a] &lt; nums[right]</code> 这一要求，也就是说 <code>S</code> 是一个合法的解集。那么，『求 <code>nums</code> 最小元素』这个问题，就可以转换成『求 <code>S</code> 这一解集中的第一个元素』这样一个问题。</p>
<p>经过这么一转换，可以看出这道题目和 <a href="https://caffcen.github.io/2023/03/12/LeetCode-%E7%AC%94%E8%AE%B0-4%EF%BC%9ABinary-Search-%E7%9A%845%E7%A7%8D%E5%8F%98%E4%BD%93%E5%BA%94%E7%94%A8/">LeetCode 笔记 4：Binary Search 的5种变体应用 | caffcen’s blog</a> 中的 <em>Index of least element greater than (or equal) to key</em>，<em>最小的大于（或大于等于）目标的下标</em>算法有异曲同工之妙：它们都是使用二分查找去求解集的第一个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="题目-2-1"><a href="#题目-2-1" class="headerlink" title="题目 2"></a>题目 2</h2><p><img src="/images/LeetCode-%E7%AC%94%E8%AE%B0-5%EF%BC%9ASearch-in-Rotated-Sorted-Array/Pasted%20image%2020230402153504.png"></p>
<p>算法和上一题几乎一样，只是多了过滤重复元素的步骤，因此不再做过多赘述：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right &amp;&amp; nums[left + <span class="number">1</span>] == nums[left]) &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (right - <span class="number">1</span> &gt; left &amp;&amp; nums[right - <span class="number">1</span>] == nums[right]) &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>虽然不好理解，但实际上这两道题目都是用 Binary Search 去求解集中的第一个解，也就是 <a href="https://caffcen.github.io/2023/03/12/LeetCode-%E7%AC%94%E8%AE%B0-4%EF%BC%9ABinary-Search-%E7%9A%845%E7%A7%8D%E5%8F%98%E4%BD%93%E5%BA%94%E7%94%A8/">LeetCode 笔记 4：Binary Search 的5种变体应用 | caffcen’s blog</a> 中的 <strong>Index of least element greater than (or equal) to key，最小的大于（或大于等于）目标的下标</strong> 这一算法。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-in-rotated-sorted-array/">33. Search in Rotated Sorted Array</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/">81. Search in Rotated Sorted Array II</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">153. Find Minimum in Rotated Sorted Array</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. Find Minimum in Rotated Sorted Array II</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh_CN">
    <link itemprop="mainEntityOfPage" href="https://caffcen.github.io/2023/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-B-Tree-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="caffcen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caffcen's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-B-Tree-1/" class="post-title-link" itemprop="url">深入理解 B+ Tree</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-26 13:56:01 / Modified: 13:59:46" itemprop="dateCreated datePublished" datetime="2023-03-26T13:56:01+08:00">2023-03-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>B+ 树的定义和 B 树是类似的，B+ 树在数据结构上进行了一定的改进，它的特性使得它的某些场景下教 B 树有了显著的优势。本文笔者将对 B+ 树的定义、特点以及应用进行详细解析。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>B+ 树和 B 树的定义是类似的，它们都是平衡多路搜索树，在文件系统和数据库系统中都有大量的应用。只不过 B+ 树有以下几点独特的属性：</p>
<ol>
<li>B+ 树的非叶子结点不包含值（value），只存储键（key）</li>
<li>B+ 树的叶子结点之间是互相连接的，B+ 树叶子结点这一层构成了一个双向链表（Doubly linked list）</li>
<li>B+ 树的叶子结点这一层存储了所有数据的 key-links pairs，而 B 树的所有数据是散布在整棵树中的，B 树的叶子结点这一层只存储了数据全集的一部分。</li>
</ol>
<p>B+ 树的查找、添加、删除算法和 B 树是类似的，可以参考笔者的上一篇博客进行了解：<a href="https://caffcen.github.io/2023/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-B-Tree/">深入理解 B-Tree | caffcen’s blog</a>，在此不在赘述。</p>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>对于阶数为 <code>m</code> 的 B+ 树，它拥有如下性质：</p>
<ol>
<li>每个节点最多有 <code>m</code> 个子节点。</li>
<li>每个节点最多有 <code>m-1</code> 个键值。</li>
<li>每个内部节点至少有 <code>⌈m/2⌉</code> 个子节点，根节点除外。</li>
<li>根节点至少有 2 个子节点。</li>
<li>所有叶子节点出现在同一层级上，叶子结点与叶子结点之间有双向引用，叶子结点这一层构成了一条双向链表。</li>
<li>一个具有 <code>k</code> 个子节点的非叶节点包含 <code>k-1</code> 个键值。</li>
<li>叶子结点这一层存储了所有数据（所有的 key-link pairs）</li>
</ol>
<h1 id="B-Tree-vs-B-Tree"><a href="#B-Tree-vs-B-Tree" class="headerlink" title="B-Tree vs. B+ Tree"></a>B-Tree vs. B+ Tree</h1><p>B 树和 B+ 树的区别对比，可以参考 Stack Overflow 这个问题：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/870218/what-are-the-differences-between-b-trees-and-b-trees">database - What are the differences between B trees and B+ trees? - Stack Overflow</a></p>
<p><img src="/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-B-Tree-1/Pasted%20image%2020230309213209.png"></p>
<table>
<thead>
<tr>
<th></th>
<th>B+ 树</th>
<th>B 树</th>
</tr>
</thead>
<tbody><tr>
<td>非叶子节点数据存储情况</td>
<td>B+ 树非叶子结点不保存 value，只存储 key</td>
<td>B 树所有结点都既保存 key 有存储 value</td>
</tr>
<tr>
<td>叶子节点结构</td>
<td>B+ 树叶子结点组成了一个 doubly-linked list</td>
<td>B 树叶子结点之间是没有引用可以访问彼此的</td>
</tr>
<tr>
<td>叶子结点数据存储情况</td>
<td>B+ 树叶子结点包含了所有 key 的信息，及指向 key 所对应的 value 的指针</td>
<td>B 树叶子结点则只保存了部分 key-value 信息</td>
</tr>
</tbody></table>
<h1 id="B-树适用场景"><a href="#B-树适用场景" class="headerlink" title="B+ 树适用场景"></a>B+ 树适用场景</h1><p>B+ 树非常适用于做文件系统索引和数据库索引，这是因为：</p>
<ol>
<li>B+ 树的磁盘利用率更高<ul>
<li>这是因为 B+ 树内部节点仅存储 key，B 树内部节点既存储 key 又存储 value (link)，导致同样大小的磁盘空间可以容纳的 B+ 树内部节点要比 B 树多。这也就意味着如果使用 B+ 树索引，相同的查询需要的 IO 次数更少。</li>
</ul>
</li>
<li>B+ 树支持高效的范围查询<ul>
<li>范围查询是非常常见的，因为 B+ 树叶子结点层构成了一个排好序的双向链表，因此对范围查询和整棵树的遍历是非常高效的。在 B 树结构中作范围查询的代价过高（类似在二叉搜索树中作范围查询，需要遍历整棵树），往往是无法接受的。</li>
</ul>
</li>
<li>B+ 树的查询效率是稳定且可预期的<ul>
<li>B+ 树的搜索最终会在叶子结点这一层结束，因为内部节点只存储 key 不存储 value (link)。所以每一次搜索的时间开销是相近且可预测的。</li>
</ul>
</li>
</ol>
<h1 id="B-树在-MySQL-InnoDB-存储引擎中的使用"><a href="#B-树在-MySQL-InnoDB-存储引擎中的使用" class="headerlink" title="B+ 树在 MySQL InnoDB 存储引擎中的使用"></a>B+ 树在 MySQL InnoDB 存储引擎中的使用</h1><p>最后讲一讲 B+ 树在 InnoDB 存储引擎中的使用，这样对帮助理解 InnoDB 索引结构和 B+ 树具体是如何使用的有直观的帮助。</p>
<p>InnoDB 是索引组织的，表都是根据主键顺序存放的，InnoDB 的数据文件本身既是索引文件，底层数据结构就是 B+ 树。因此这种表也被称为索引组织表（Index organized table）。</p>
<p>B+ 树在实际使用中，阶数 <code>m</code> 一般都很大，使得 B+ 树具有了很高的扇出性（fanout），因此即便存储大量的数据，整棵树的高度一般都在 2~4 层，也就是说一次搜索只需要 2 到 4 次 IO。</p>
<p>在 MySQL InnoDB 中，索引可以分为聚集索引和辅助索引（非聚集索引）。</p>
<ul>
<li>聚集索引（clustered index）就是按照每张表的主键构造⼀棵 B+树，同时叶⼦节点中存放的即为整张表的⾏记录数据，也将聚集索引的叶⼦节点称为数据页。同 B+树数据结构⼀样，每个数据页都通过⼀个双向链表来进⾏链接。</li>
<li>辅助索引（Secondary Index，也称⾮聚集索引），叶⼦节点并不包含⾏记录的全部数据。叶⼦节点除了包含键值以外，每个叶⼦节点中的索引⾏中还包含了⼀个书签（bookmark）。该书签⽤来告诉 InnoDB 存储引擎哪⾥可以找到与索引相对应的⾏数据。由于 InnoDB 存储引擎表是索引组织表，因此 InnoDB 存储引擎的辅助索引的书签就是相应⾏数据的聚集索引键（key）。</li>
</ul>
<p>MySQL InnoDB 是索引组织表，每张表只能有一个主键、一个聚集索引文件，但是可以有多个辅助索引。</p>
<p>通过聚集索引进行查询，就是在 B+ 树中进行搜索；通过辅助索引进行查询，则需要进行两次查询：</p>
<ol>
<li>第一次查询从辅助索引中找到该辅助索引键对应的主键是什么；</li>
<li>第二次查询用主键从聚集索引中进行查询。</li>
</ol>
<p>如果读者对聚集索引和辅助索引还有疑惑，可以阅读《MySQL 技术内幕——InnoDB 存储引擎》的 5.4 和 4.1 节。这里就不多赘述了。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li>《MySQL 技术内幕——InnoDB 存储引擎》</li>
<li>《Algorithms, 4th Edition》by Robert Sedgewick, Kevin Wayne</li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/870218/what-are-the-differences-between-b-trees-and-b-trees">database - What are the differences between B trees and B+ trees? - Stack Overflow</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/B%2B_tree#:~:text=A%20B%2B%20tree%20is%20an,B%2B%20tree">B+ tree - Wikipedia</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh_CN">
    <link itemprop="mainEntityOfPage" href="https://caffcen.github.io/2023/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-B-Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="caffcen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caffcen's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-B-Tree/" class="post-title-link" itemprop="url">深入理解 B-Tree</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-03-18 16:07:30 / Modified: 16:22:11" itemprop="dateCreated datePublished" datetime="2023-03-18T16:07:30+08:00">2023-03-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>B 树是一种平衡多路搜索树，可以看做是对二叉搜索树（Binary Search Tree）的拓展。因为 B 树的自平衡以及允许一个节点存储多个值的特性，被广泛运用在数据库以及文件系统中，非常适用于存储大量数据。</p>
<p>要理解 B 树，最好的方式就是学习 2-3 搜索树——B 树的一种特例。</p>
<h1 id="2-3-搜索树-2-3-Search-Tree"><a href="#2-3-搜索树-2-3-Search-Tree" class="headerlink" title="2-3 搜索树 (2-3 Search Tree)"></a>2-3 搜索树 (2-3 Search Tree)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>2-3 搜索树是对二叉搜索树一种自然的扩充，二叉搜索树的任意一个节点只能存储一个 key、两个 links，但是 2-3 搜索树扩展了这一设定，2-3 搜索树允许存在以下两类节点：</p>
<ul>
<li>2-node：拥有一个 key 两个 links，2-node 和二叉搜索树中的节点完全等价，两个 links 分别指向左子树和右子树：<ul>
<li>左子树中的所有节点的 key 均『小于』当前 2-node 的 key；</li>
<li>右子树中的所有节点均『大于』当前 2-node 的 key。</li>
</ul>
</li>
<li>3-node：拥有两个 keys 三个 links，3 个 links 分别指向左子树、右子树和中间子树：<ul>
<li>左子树中的所有节点的 key 均『小于』当前 3-node 较小的 key；</li>
<li>右子树中的所有节点均『大于』当前 3-node 较大的 key；</li>
<li>中间子树中的所有节点均大于 3-node 较小的 key，且小于 3-node 较大的 key。</li>
</ul>
</li>
</ul>
<blockquote>
<p>这里大于、小于打引号是因为类型的大小关系往往是可以自定义的。</p>
</blockquote>
<blockquote>
<p>本文使用 key 表示存储数据的键，links 表示指向其他节点的引用，value 表示存储数据实际存储的值，在数据库以及文件系统中，value 可能是指向实际数据的指针。</p>
</blockquote>
<p><img src="/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-B-Tree/Pasted%20image%2020230318143549.png"></p>
<p>2-3 搜索树支持搜索、插入、删除操作，这些操作的最坏、平均时间复杂度均为 <code>O(longN)</code> ， <code>N</code> 为 2-3 搜索树的数据总量。同时，2-3 搜索树总是高度平衡的，所有叶子结点到根节点的距离总是一致的。</p>
<p>本文将会对搜索以及插入操作进行详细分析。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>在 2-3 搜索树中搜索某一个 key 是否存在，和在二叉搜索树中几乎一致：</p>
<ol>
<li>判断 target 是否等于当前节点中任意 key，如果相等则返回当前节点；</li>
<li>如果当前节点是 2-node，那么将出现两种情况：<ol>
<li>如果 target 小于 2-node 的 key，则递归地向左子树进行搜索；</li>
<li>如果 target 大于 2-node 的 key，则递归地向右子树进行搜索；</li>
</ol>
</li>
<li>如果当前节点是 3-node，那么将出现三种情况：<ol>
<li>如果 target 小于 3-node 中最小的 key，则递归地向左子树进行搜索；</li>
<li>如果 target 大于 3-node 中最大的 key，则递归地对右子树进行搜索；</li>
<li>否则，递归搜索中间子树；</li>
</ol>
</li>
<li>如果当前节点是 <code>null</code> 说明，target 并未在 2-3 搜索树中，返回 <code>null</code></li>
</ol>
<p><img src="/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-B-Tree/Pasted%20image%2020230318145503.png"></p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>向 2-3 搜索树中插入一对 key-value 是一个相较于二叉搜索树的插入算法更为复杂的操作。2-3 搜索树能够保证任何情况下（无论输入数据插入的顺序是怎样的）都是高度平衡的特性和 2-3 搜索树的插入算法是紧密相关的。</p>
<p>插入算法总是从 <code>root</code> 节点开始搜索，搜索到叶子结点为止（搜索算法 1.2 小节已经讨论过了），再根据叶子结点以及插入 key-value 键值对和叶子结点中的 key 的比较情况来进行操作的。之后的讨论都是基于『已经搜索到需要往哪个叶子节点进行插入』进行讨论。</p>
<h3 id="插入到-2-node-中"><a href="#插入到-2-node-中" class="headerlink" title="插入到 2-node 中"></a>插入到 2-node 中</h3><p>如果待插入的节点是一个 2-node，只需要将其变为一个 3-node 即可：</p>
<p><img src="/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-B-Tree/Pasted%20image%2020230318150451.png"></p>
<p>当往一个 2-node 中插入一个节点后，所有叶子结点都还位于它原本的位置上，没有任何节点的位置发生变化，也没有新增任何的节点，所以整棵树在插入操作后依然是高度平衡的，所有叶子结点到根节点的距离都没有发生改变。</p>
<h3 id="插入到单独的-3-node-中"><a href="#插入到单独的-3-node-中" class="headerlink" title="插入到单独的 3-node 中"></a>插入到单独的 3-node 中</h3><p>如果整棵树只有 <code>root</code> 这一个节点，同时 <code>root</code> 是一个 3-node，那么我们和面对 2-node 时是一样的，我们将待插入的 key 插入其中，让其暂时将其变为一个 4-node（拥有 3 个 keys 和 4 个 links）。然后，我们将这一个 4-node 分裂为 3 个 2-node：</p>
<ol>
<li>我们将 3 个 key 中大小位于中间位置的 key-value 对向上分裂，成为当前 2-3 搜索树的 <code>new_root</code> ；</li>
<li>将 3 个 key 中最小的变为 <code>new_root</code> 的左子树；</li>
<li>将 3 个 key 中最大的变为 <code>new_root</code> 的右子树</li>
</ol>
<p><img src="/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-B-Tree/Pasted%20image%2020230318151238.png"></p>
<p>当往一个是 3-node 的 <code>root</code> 中插入一组数据后，整棵树的高度增加了 1（这也是 2-3 搜索树高度增加的唯一情况，2-3 搜索树的高度增加依赖于新插入的数据使得 <code>root</code> 进行分裂），原来的叶子节点到新 <code>root</code> 的距离都增加了 1，所有叶子结点到 <code>root</code> 的距离还是相等的，因此 2-3 搜索树在这种情况下依然是高度平衡的。</p>
<h3 id="往一个父节点是-2-node-的-3-node-插入数据"><a href="#往一个父节点是-2-node-的-3-node-插入数据" class="headerlink" title="往一个父节点是 2-node 的 3-node 插入数据"></a>往一个父节点是 2-node 的 3-node 插入数据</h3><p>当往一个 3-node 节点插入数据后，和上一小节一样，我们需要将其短暂变为一个 4-node，之后变成 3 个 2-node，并将顺序大小排中间的节点向上分裂。</p>
<p>因为该叶子节点的父节点是个 2-node，我们只需要将其变为一个 3-node 即可，剩下的未向上分裂的『最小』、『最大』节点变成分裂上去的 key 的左右孩子节点即可：</p>
<p><img src="/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-B-Tree/Pasted%20image%2020230318152424.png"></p>
<p>在这种情况下，从结果来看仅仅是一个中间节点从 2-node 变成了 3-node，没有新增任何节点，树的高度保持一致，因此在这种情况下 2-3 搜索树依然是高度平衡的。</p>
<h3 id="往一个父节点是-3-node-的-3-node-插入数据"><a href="#往一个父节点是-3-node-的-3-node-插入数据" class="headerlink" title="往一个父节点是 3-node 的 3-node 插入数据"></a>往一个父节点是 3-node 的 3-node 插入数据</h3><p>当向一个 3-node 叶子节点插入数据后，我们将其变为一个 4-node 后分裂成 3 个 2-node，并把大小排在中间的 2-node 向上分裂。</p>
<p>和上一小节不同的是，当前叶子节点的父节点是一个 3-node。那么，我们只能把向上分裂的 key-value 对加入其中，将其也变成一个暂时的 4-node，并分出 3 个 2-node，再将大小排中间的 key-value 对继续向上抛。</p>
<p>相信你此时一定能看出插入算法是如何递归地执行的了。我们将分裂得到的大小位于中间的 2-node 向上抛给父节点，如果父节点也需要进行分裂，那么递归地分裂、向上抛，直到某个父节点是一个 2-node，或者递归到 <code>root</code> 节点时 <code>root</code> 是一个 3-node，递归的步骤才会终止：</p>
<p><img src="/images/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-B-Tree/Pasted%20image%2020230318153603.png"></p>
<p>我们再来看看在这种情况下 2-3 搜索树是如何保持高度平衡的，只需要考虑两种情况：</p>
<ol>
<li><code>root</code> 是一个 2-node，即便从叶子结点一路向上分裂到 <code>root</code> ，因为 <code>root</code> 是一个 2-node，那么情况将和最开始讨论的往一个 2-node 插入是一模一样的，我们只需要将 <code>root</code> 变为一个 3-node 即可。整棵树的高度没有发生任何变化，即便中间的路径可能发生了改变，但所有叶子结点在插入后还是在叶子结点的位置上，它们到根节点的距离依然是相同的。</li>
<li><code>root</code> 是一个 3-node，那么如果递归到最后需要向 <code>root</code> 进行插入，情况就和整棵树只有 <code>root</code> 一个 3-node 时是一样，整棵树的高度将增加 1，所有叶子结点到根节点的距离都加 1，那么 2-3 搜索树依然是高度平衡的。</li>
</ol>
<p>也就是说，在这种情况下，2-3 搜索树的高度依然是平衡的。</p>
<h2 id="2-3-搜索树插入算法总结"><a href="#2-3-搜索树插入算法总结" class="headerlink" title="2-3 搜索树插入算法总结"></a>2-3 搜索树插入算法总结</h2><p>我们可以总结出 2-3 搜索树插入算法拥有这样的局部特性以及全局特性：</p>
<ol>
<li>只有从叶子结点开始，沿着父子关系的路径往上，一直到根节点结束的这一条局部路径范围上的节点会受到影响，插入算法的影响范围总是局部的。</li>
<li>局部范围内的影响并不会破坏 2-3 搜索树的全局特性：2-3 搜索树在任意时刻总是高度平衡的，所有叶子结点到根节点的距离都相等。</li>
<li>2-3 搜索树只有当往一个类型是 3-node 的 <code>root</code> 节点插入时，才会导致导致整棵树的高度增加。</li>
<li>二叉搜索树的高度是往下增加的，而 2-3 搜索树的高度是往上增加的。</li>
</ol>
<p>我们知道，二叉搜索树的高度和空间结构严重依赖于输入数据的插入顺序，在最坏情况下（比如顺序插入一组已经排好序的数据）的搜索、插入、删除时间复杂度将变成 <code>O(N)</code> ，而 2-3 搜索树因为它的分裂以及局部变更等特点，使得在任意情况下，插入、搜索、删除的最坏时间复杂度均为 <code>O(logN)</code> 。</p>
<h1 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h1><p>B 树是对 2-3 搜索树的泛化，反过来说就是，2-3 搜索树是一种 3 阶 B 树。</p>
<h2 id="B-Tree-定义"><a href="#B-Tree-定义" class="headerlink" title="B-Tree 定义"></a>B-Tree 定义</h2><p>一个 <code>m</code> 阶 B 树可以看做是 2-3 搜索树的一种泛化，它拥有如下特点：</p>
<ol>
<li>每个节点最多有 <code>m</code> 个子节点（ <code>m</code> 个 links）。 </li>
<li>每个节点最多有 <code>m - 1</code> 个键值对（ <code>m - 1</code> 个 key-value pairs）。</li>
<li>每个内部节点至少有 <code>⌈m/2⌉</code> 个子节点。</li>
<li>根节点必须至少有 2 个键值对（两个 key-value pairs）。</li>
<li>所有叶节点在同一级别上出现。</li>
<li>一个具有 <code>k</code> 个子节点的非叶节点包含 <code>k-1</code> 个键值对。</li>
<li>关键字（keys）集合分布在整颗树中。</li>
<li>任何一个关键字（key）出现且只出现在一个结点中。</li>
<li>搜索有可能在非叶子结点结束 (树中所有结点都存储数据，与 B+树这一点不同)。</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找（最坏时间复杂度 <code>O(logN</code> ）。</li>
</ol>
<p>B 树的搜索、插入和删除算法本质上和 2-3 搜索树的搜索、插入、删除算法是一样的，它们的最坏时间复杂度都是 <code>O(logN)</code> 。学懂了 2-3 搜索树，你也就懂了 B 树的各种操作是如何执行的了。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/2%E2%80%933_tree">2–3 tree - Wikipedia</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/B-tree">B-tree - Wikipedia</a></li>
<li>《MySQL 技术内幕——InnoDB 存储引擎》</li>
<li>《Algorithms, 4th Edition》by Robert Sedgewick, Kevin Wayne</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh_CN">
    <link itemprop="mainEntityOfPage" href="https://caffcen.github.io/2023/03/12/LeetCode-%E7%AC%94%E8%AE%B0-4%EF%BC%9ABinary-Search-%E7%9A%845%E7%A7%8D%E5%8F%98%E4%BD%93%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="caffcen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caffcen's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/12/LeetCode-%E7%AC%94%E8%AE%B0-4%EF%BC%9ABinary-Search-%E7%9A%845%E7%A7%8D%E5%8F%98%E4%BD%93%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">LeetCode 笔记 4：Binary Search 的5种变体应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-12 13:00:48" itemprop="dateCreated datePublished" datetime="2023-03-12T13:00:48+08:00">2023-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-04-02 15:47:27" itemprop="dateModified" datetime="2023-04-02T15:47:27+08:00">2023-04-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>二分查找在算法题目中是十分常见的一类题目，但这类题目往往要求二分查找找出解集中的第一个、最后一个解，这个时候通常的二分查找算法就无法直接套用了。</p>
<p>本文将列举 5 种二分查找的变体应用，它们分别是：</p>
<ol>
<li>Contains，是否包含目标</li>
<li>Index of first occurrence of a key，目标第一次出现的下标</li>
<li>Index of last occurrence of a key，目标最后一次出现的下标</li>
<li>Index of least element greater than (or equal) to key，最小的大于（或大于等于）目标的下标</li>
<li>Index of greatest element less than (or equal to) key，最大的小于（或小于等于）目标的下标</li>
</ol>
<p>之后会更新几篇文章针对不同类型的题目进行分析。</p>
<p>这 5 中变体算法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否包含 key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 输入数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 目标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 包含；false 不包含</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;  <span class="comment">// (low + high) / 2 可能导致溢出，因此采用这种方式计算</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> nums[mid];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (midVal == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (midVal &lt; key) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; key) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 输入数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 目标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 key 第一次出现时的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">first</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>, low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> nums[mid];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (midVal &lt; key) &#123;</span><br><span class="line">                <span class="comment">// key 在 mid 右边</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; key) &#123;</span><br><span class="line">                <span class="comment">// key 在 mid 左边</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal == key) &#123;</span><br><span class="line">                <span class="comment">// mid 左边可能存在 key，因此左移右边界</span></span><br><span class="line">                ans = mid;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 输入数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 目标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 key 最后出现时的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">last</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>, low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> nums[mid];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (midVal &lt; key) &#123;</span><br><span class="line">                <span class="comment">// key 在 mid 右边</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; key) &#123;</span><br><span class="line">                <span class="comment">// key 在 mid 左边</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal == key) &#123;</span><br><span class="line">                <span class="comment">// 右边界任然可能存在 key，因此将 low 右移</span></span><br><span class="line">                ans = mid;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 输入数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 目标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最小大于 key 的元素的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">leastGreater</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>, low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> nums[mid];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (midVal &lt; key) &#123;</span><br><span class="line">                <span class="comment">// 最小大于 key 的元素在 mid 右边</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; key) &#123;</span><br><span class="line">                <span class="comment">// 任然存在比 midVal 更小的解，因此将 high 左移</span></span><br><span class="line">                ans = mid;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal == key) &#123;</span><br><span class="line">                <span class="comment">// 最小大于 key 的元素在 mid 右边</span></span><br><span class="line">                <span class="comment">// 可以和 midVal &lt; key 的情况进行合并</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 输入数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 目标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 最大的小于 key 的元素的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">greatestLesser</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>, low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> nums[mid];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (midVal &lt; key) &#123;</span><br><span class="line">                <span class="comment">// 可能存在比 midVal 更大的解，因此右移 low</span></span><br><span class="line">                ans = mid;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; key) &#123;</span><br><span class="line">                <span class="comment">// midVal 过大，解在 mid 左边</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (midVal == key) &#123;</span><br><span class="line">                <span class="comment">// 同样，可以和 midVal &gt; key 进行合并</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中算法 <code>leastGreater</code> 和 <code>greatestLesser</code> 只需稍作修改即可用于求解大于等于以及小于等于的情况，因此不做赘述。</p>
<p>其中，变体 2 （目标第一次出现时的下标，上面的 <code>first</code> 算法）和 C++ <code>std::lower_bound()</code> 很类似：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">lower_bound</span><span class="params">(ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ForwardIt it;</span><br><span class="line">    <span class="keyword">typename</span> std::iterator_traits&lt;ForwardIt&gt;::difference_type count, step;</span><br><span class="line">    count = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        it = first; </span><br><span class="line">        step = count / <span class="number">2</span>; </span><br><span class="line">        std::<span class="built_in">advance</span>(it, step);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (*it &lt; value)</span><br><span class="line">        &#123;</span><br><span class="line">            first = ++it; </span><br><span class="line">            count -= step + <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count = step;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变体 4，最大的小于（或小于等于）目标的元素的下标（上面的 <code>greatestLesser</code> 算法）和 C++ 的 <code>std::upper_bound()</code> 算法很类似：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ForwardIt, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">ForwardIt <span class="title">upper_bound</span><span class="params">(ForwardIt first, ForwardIt last, <span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ForwardIt it;</span><br><span class="line">    <span class="keyword">typename</span> std::iterator_traits&lt;ForwardIt&gt;::difference_type count, step;</span><br><span class="line">    count = std::<span class="built_in">distance</span>(first, last);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        it = first; </span><br><span class="line">        step = count / <span class="number">2</span>; </span><br><span class="line">        std::<span class="built_in">advance</span>(it, step);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (!(value &lt; *it))</span><br><span class="line">        &#123;</span><br><span class="line">            first = ++it;</span><br><span class="line">            count -= step + <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            count = step;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/variants-of-binary-search/">Variants of Binary Search - GeeksforGeeks</a></li>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">std::lower_bound - cppreference.com</a></li>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/algorithm/upper_bound">std::upper_bound - cppreference.com</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh_CN">
    <link itemprop="mainEntityOfPage" href="https://caffcen.github.io/2023/02/26/MySQL-InnoDB-Bin-Log-Redo-Log-Undo-Log-%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="caffcen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caffcen's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/26/MySQL-InnoDB-Bin-Log-Redo-Log-Undo-Log-%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">MySQL InnoDB Bin Log, Redo Log, Undo Log 详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-26 18:23:10 / Modified: 18:26:25" itemprop="dateCreated datePublished" datetime="2023-02-26T18:23:10+08:00">2023-02-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Bin log，Redo log 以及 Undo log 是 MySQL 以及 InnoDB 中较为重要的 3 中日志文件，它们帮助实现了本地事务的原子性以及持久性，同时还是复制、MVCC 等功能必不可少的组成部分。</p>
<h1 id="Bin-Log"><a href="#Bin-Log" class="headerlink" title="Bin Log"></a>Bin Log</h1><blockquote>
<p>The binary log contains “events” that describe database changes such as table creation operations or changes to table data.</p>
</blockquote>
<p>Bin log 记录所有对于 MySQL 执行的更改操作（包括不同存储引擎相关的操作），不记录 SELECT 和 SHOW 这类不修改数据库的操作。Bin log 产生于 MySQL 数据库上层，任何存储引擎对于数据库的更改都会产生 Bin log，包括 InnoDB、MyISAM、Heap 等任何存储引擎的⽇志。</p>
<p>Bin log 是逻辑日志，记录的是 SQL 语句。</p>
<h2 id="Bin-log-的作用"><a href="#Bin-log-的作用" class="headerlink" title="Bin log 的作用"></a>Bin log 的作用</h2><p>Bin log 的作用主要是：</p>
<ol>
<li>恢复：数据库恢复阶段，某些数据的恢复依赖于二进制日志</li>
<li>复制（replication）：MySQL 集群间的同步是将 bin log 中记录的数据更改复制给其它节点实现的。</li>
</ol>
<p>From official doc <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/binary-log.html">MySQL :: MySQL 8.0 Reference Manual :: 5.4.4 The Binary Log</a>:</p>
<blockquote>
<ul>
<li>For <strong>replication</strong>, the binary log on a replication source server provides a record of the data changes to be sent to replicas. The source sends the information contained in its binary log to its replicas, which reproduce those transactions to make the same data changes that were made on the source. See <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/replication-implementation.html" title="17.2 Replication Implementation">Section 17.2, “Replication Implementation”</a>.</li>
<li>Certain <strong>data recovery operations</strong> require use of the binary log. After a backup has been restored, the events in the binary log that were recorded after the backup was made are re-executed. These events bring databases up to date from the point of the backup. See <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/point-in-time-recovery.html" title="7.5 Point-in-Time (Incremental) Recovery">Section 7.5, “Point-in-Time (Incremental) Recovery”</a>.</li>
</ul>
</blockquote>
<h2 id="Bin-log-的刷盘时机"><a href="#Bin-log-的刷盘时机" class="headerlink" title="Bin log 的刷盘时机"></a>Bin log 的刷盘时机</h2><p>对于 InnoDB 存储引擎而言，只有在事务提交时才会记录 bin log ，此时记录还在内存中，之后才会将将其写到磁盘之中。具体的刷盘时机是通过 <code>sync_binlog</code> 参数来控制的。 <code>sync_binlog</code> 取值范围是 <code>0-N</code> ：</p>
<ul>
<li>0：不强制要求，由系统自行判断何时写入磁盘；</li>
<li>1：每次 <code>commit</code> 的时候都要将 bin log 写入磁盘；</li>
<li>N：每 N 个事务，才会将 bin log 写入磁盘。</li>
</ul>
<p>从上面可以看出， <code>sync_binlog</code> 最安全的是设置是 1，这也是 MySQL 5.7.7 之后版本的默认值。但是设置一个大一些的值可以提升数据库性能，因此实际情况下也可以将值适当调大，牺牲一定的一致性来获取更好的性能。</p>
<h1 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h1><p>Redo log 和 bin log 不同，redo log 是 InnoDB 存储引擎文件，是在引擎层产生的。它是一种物理格式日志（和 Bin log 的逻辑日志属性不同），记录了页的修改内容。在恢复时，物理日志比逻辑日志的处理速度快许多。</p>
<h2 id="Redo-Log-的作用"><a href="#Redo-Log-的作用" class="headerlink" title="Redo Log 的作用"></a>Redo Log 的作用</h2><p>为了保证事务的持久性，现代的数据库普遍采用先写日志，再做变更的策略（Write-Ahead Logging），一个事务如果将修改全部写入到了日志中，那么即便数据库宕机等意外情况，在数据库恢复阶段完全可以依照日志将修改安全地进行重做。</p>
<p>这也是 Redo log 名字的来源，在数据库的恢复时，数据库会判断有哪些事务已经在 Redo log 中写入了 Commit Record，这表示这些事务实际上已经完成，数据库会根据 Redo log 将这些事务未写到磁盘中的修改落盘，也因此，Redo log 实现了事务的持久性。</p>
<p>关于 Write-Ahead Logging 以及事务持久性的实现，可以参考笔者之前的 <a href="https://caffcen.github.io/2023/02/19/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/">本地事务的原子性和持久性是如何实现的 | caffcen’s blog</a> 及该文的参考资料作进一步的了解。</p>
<h2 id="Redo-log-文件以及-redo-log-group"><a href="#Redo-log-文件以及-redo-log-group" class="headerlink" title="Redo log 文件以及 redo log group"></a>Redo log 文件以及 redo log group</h2><p>在 InnoDB 存储引擎的数据目录下会有两个名为 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> 的文件，它们既为重做日志文件。</p>
<p>InnoDB 存储引擎引入了重做日志组（Redo log group）的概念，每个日志组至少有 2 个重做日志文件，如默认的 <code>ib_logfile0</code> 和 <code>ib_logfile1</code> 。为了得到更高的可靠性，可以设置多个镜像日志组（mirrored log groups）。每个日志组内的每个 redo log file 大小一致，并采用循环写（round robin）的方式进行写入。这部分之后会有详细介绍。</p>
<h2 id="Redo-log-格式"><a href="#Redo-log-格式" class="headerlink" title="Redo log 格式"></a>Redo log 格式</h2><p>Redo log 可以看做是由位于内存中的 redo log buffer 以及磁盘中的 redo log file 这两个部分组成。它们均有 block （块）组成，称为 redo log block:</p>
<p><img src="/images/MySQL-InnoDB-Bin-Log-Redo-Log-Undo-Log-%E8%AF%A6%E8%A7%A3/Pasted%20image%2020230223193250.png"></p>
<p>每个 redo log block 大小为 512 bytes。</p>
<p>Redo log block 的结构这里就不具体展开了，有兴趣的读者可以进一步阅读《MySQL 技术内幕——InnoDB 存储引擎》7.2 节的内容。</p>
<h2 id="Redo-log-工作原理"><a href="#Redo-log-工作原理" class="headerlink" title="Redo log 工作原理"></a>Redo log 工作原理</h2><p>MySQL 每执行一条 DML 语句，会将页的修改记录写到内存中的 redo log buffer 之中，之后依据一定的策略将 buffer 中的记录刷到磁盘之中。</p>
<p>从重做⽇志缓冲往磁盘写⼊时，是按 512 个字节，也就是⼀个扇区的⼤⼩进⾏写⼊。这是因为扇区是写⼊的最⼩单位，因此可以保证写⼊必定是成功的（因此是原子的）。因此在重做⽇志的写⼊过程中不需要有 doublewrite。</p>
<p>MySQL 和其他进程一样，是位于用户空间中的进程，一般情况下，位于用户空间之中的内存数据是无法直接写入磁盘的，而是需要调用操作系统提供的接口，将数据拷贝到位于内核空间的缓冲区中，之后再通过 <code>fsync</code> 将其写入磁盘之中：</p>
<p><img src="/images/MySQL-InnoDB-Bin-Log-Redo-Log-Undo-Log-%E8%AF%A6%E8%A7%A3/Pasted%20image%2020230223194614.png"></p>
<h2 id="Redo-log-刷盘策略"><a href="#Redo-log-刷盘策略" class="headerlink" title="Redo log 刷盘策略"></a>Redo log 刷盘策略</h2><p>参数 <code>innodb_ﬂush_log_at_trx_commit</code> ⽤来控制重做⽇志刷新到磁盘的策略。</p>
<table>
<thead>
<tr>
<th>参数值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0（延迟写）</td>
<td>事务提交时不会将 <code>redo log buffer</code> 中日志写入到 <code>os buffer</code> ，而是让 master thread 来完成重入日志的落盘，因为 master thread 每秒都会将重做日志缓冲中的修改写入磁盘，无论事务是否有提交。Master thread 每秒会进行一次 <code>fsync</code> 操作。</td>
</tr>
<tr>
<td>1，默认值（实时写，实时刷）</td>
<td>事务每次提交都会将 <code>redo log buffer</code> 中的日志写入 <code>os buffer</code> 并调用 <code>fsync</code> 刷到 <code>redo log file</code> 中。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO 的性能较差。</td>
</tr>
<tr>
<td>2（实时写，延迟刷）</td>
<td>每次提交都仅写入到 <code>os buffer</code> ，每秒会进行一次 <code>fsync</code> 。当系统崩溃时，存在于内存中未刷新到磁盘的事务数据将会丢失</td>
</tr>
</tbody></table>
<p>将 <code>innodb_ﬂush_log_at_trx_commit</code> 设置为 0 或 2 将破坏事务的 ACID 特性。因此为了保证事务的持久性，必须将 <code>innodb_ﬂush_log_at_trx_commit</code> 设置为 1，也就是每当有事务提交时，就必须确保缓冲中的修改已经成功地写入到了磁盘中。那么，即便数据库因为各种意外发⽣宕机，也能够在重启恢复时通过 redo log 进行重做，保证了事务的持久性。（至于本地事务是如何实现持久性的，DBMS 在重启恢复阶段怎样进行重做和回滚，可以参考笔者的另一篇博客：<a href="https://caffcen.github.io/2023/02/19/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/">本地事务的原子性和持久性是如何实现的 | caffcen’s blog</a>）</p>
<p>如果将 <code>innodb_ﬂush_log_at_trx_commit</code> 设置为 0 或 2，就无法保证缓冲中的数据能够在事务提交的时候写入磁盘。0 和 2 的区别在于，设置为 2 时，当 MySQL 数据库发⽣宕机⽽操作系统及服务器并没有发⽣宕机时，内存中的数据将得到保存。当然，如果系统挂了内存中的数据当然也就丢失了。</p>
<h2 id="Redo-log-file-写入策略"><a href="#Redo-log-file-写入策略" class="headerlink" title="Redo log file 写入策略"></a>Redo log file 写入策略</h2><p>Redo log 采用追加（append）的方式写到 redo log ﬁle 的最后部分，当⼀个 redo log ﬁle 被写满时，会接着写⼊下⼀个 redo log ﬁle，其使⽤⽅式为 roundrobin，如下图：</p>
<p><img src="/images/MySQL-InnoDB-Bin-Log-Redo-Log-Undo-Log-%E8%AF%A6%E8%A7%A3/Pasted%20image%2020230226180548.png"></p>
<p>在上图中， <code>write position</code> 表示 redo log 当前记录的 <code>LSN</code> (逻辑序列号) 位置， <code>checkpoint</code> 表示将缓存中的脏页写回磁盘后，数据页最新的版本号。</p>
<ul>
<li><code>write position</code> 到 <code>checkpoint</code> 之间的部分是 redo log 空着的部分，用于记录新的记录； </li>
<li><code>checkpoint</code> 到 <code>write position</code> 之间是 <code>redo log</code> 待落盘的数据页更改记录。</li>
</ul>
<p>当 <code>write position</code> 追上 <code>checkpoint</code> 时，会先推动 <code>checkpoint</code> 向前移动，空出位置再记录新的日志。</p>
<h1 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h1><p>因为采用了 Write-Ahead Logging 策略，数据库允许事务在提交之前就将修改写到磁盘中，这提高了硬件资源的利用率（磁盘和处理器同时在进行工作），但也带来了一个问题：如果事务未能 Commit 数据库就因为某种原因宕机了，那么提前写入到磁盘中的修改就是错误的数据，事务的一致性和原子性都将被破坏。</p>
<p>因此，Undo log 应运而生。在数据库恢复阶段，会将那些未能完成（未在 Redo log 中写下 Commit Record）的事务（称为 Loser）对磁盘的修改进行回滚，而 Undo log 就是数据库如何进行回滚的依据。</p>
<p>Undo log 也是 InnoDB 存储引擎的文件，和 Bin log 一样是一种逻辑日志文件，记录了行记录变更之前的记录，也因此可以实现 MVCC（Multi-Version Concurrency Control）。</p>
<p>From official doc <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-undo-logs.html#:~:text=An%20undo%20log%20record%20contains,retrieved%20from%20undo%20log%20records.">MySQL :: MySQL 5.7 Reference Manual :: 14.6.7 Undo Logs</a>:</p>
<blockquote>
<p>An undo log is a collection of undo log records associated with a single read-write transaction. An undo log record contains information about how to undo the latest change by a transaction to a <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_clustered_index" title="clustered index">clustered index</a> record. If another transaction needs to see the original data as part of a consistent read operation, the unmodified data is retrieved from undo log records. Undo logs exist within <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_undo_log_segment" title="undo log segment">undo log segments</a>, which are contained within <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_rollback_segment" title="rollback segment">rollback segments</a>. Rollback segments reside in the <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_system_tablespace" title="system tablespace">system tablespace</a>, in <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_undo_tablespace" title="undo tablespace">undo tablespaces</a>, and in the <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_temporary_tablespace" title="temporary tablespace">temporary tablespace</a>.</p>
</blockquote>
<p>总结一下，Undo log 的作用主要有两个：</p>
<ol>
<li>回滚</li>
<li>MVCC</li>
</ol>
<h2 id="Undo-log-的存储"><a href="#Undo-log-的存储" class="headerlink" title="Undo log 的存储"></a>Undo log 的存储</h2><p>Redo log 和 bin log 都以日志文件的形式进行存储，undo log 则不同，undo 存放在数据库内部的 undo 段中。 undo 段位于共享表空间、undo 表空间及临时表空间中。</p>
<blockquote>
<p>Undo logs exist within <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_undo_log_segment" title="undo log segment">undo log segments</a>, which are contained within <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_rollback_segment" title="rollback segment">rollback segments</a>. Rollback segments reside in the <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_system_tablespace" title="system tablespace">system tablespace</a>, in <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_undo_tablespace" title="undo tablespace">undo tablespaces</a>, and in the <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_temporary_tablespace" title="temporary tablespace">temporary tablespace</a>.</p>
</blockquote>
<p>Undo log 的具体内部结构以及相关的 purge 操作，可以参考《MySQL 技术内幕——InnoDB 存储引擎》7.2.2 和 7.2.3 节，在此不再赘述。</p>
<h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><table>
<thead>
<tr>
<th></th>
<th>Bin Log</th>
<th>Redo Log</th>
<th>Undo Log</th>
</tr>
</thead>
<tbody><tr>
<td>作用</td>
<td>① 复制（Replication） ② 恢复</td>
<td>数据库恢复时用于重做事务</td>
<td>① 回滚 ② MVCC</td>
</tr>
<tr>
<td>文件分类</td>
<td>MySQL 数据库逻辑日志文件</td>
<td>InnoDB 引擎物理日志文件</td>
<td>InnoDB 引擎逻辑日志文件</td>
</tr>
<tr>
<td>记录内容</td>
<td>SQL 语句</td>
<td>页的修改</td>
<td>SQL 语句</td>
</tr>
</tbody></table>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li>《MySQL 技术内幕——InnoDB 存储引擎》3.2, 3.6, 7.2</li>
<li><a target="_blank" rel="noopener" href="http://icyfenix.cn/architect-perspective/general-architecture/transaction/local.html">本地事务 | 凤凰架构</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/binary-log.html">MySQL :: MySQL 8.0 Reference Manual :: 5.4.4 The Binary Log</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-redo-log.html">MySQL :: MySQL 8.0 Reference Manual :: 15.6.5 Redo Log</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html">MySQL :: MySQL 5.7 Reference Manual :: 14.15 InnoDB Startup Options and System Variables</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-undo-logs.html#:~:text=An%20undo%20log%20record%20contains,retrieved%20from%20undo%20log%20records.">MySQL :: MySQL 5.7 Reference Manual :: 14.6.7 Undo Logs</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6987557227074846733">彻底搞懂MySQL的redo log，binlog，undo log - 掘金</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh_CN">
    <link itemprop="mainEntityOfPage" href="https://caffcen.github.io/2023/02/26/LeetCode-%E7%AC%94%E8%AE%B0-3%EF%BC%9AConstruct-Binary-Tree-from-xxx-Traversal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="caffcen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caffcen's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/26/LeetCode-%E7%AC%94%E8%AE%B0-3%EF%BC%9AConstruct-Binary-Tree-from-xxx-Traversal/" class="post-title-link" itemprop="url">LeetCode 笔记 3：Construct Binary Tree from xxx Traversal</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-26 15:51:14 / Modified: 18:23:57" itemprop="dateCreated datePublished" datetime="2023-02-26T15:51:14+08:00">2023-02-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这一类题目（具体题目可以参考文末的链接）要求我们从 <code>inorder</code>, <code>preorder</code> 及 <code>postorder</code> traversal 其中的两个构建出二叉树，之所以能够通过这三种遍历方式中的两个就构建出整棵二叉树，是因为任意两种遍历方式都能够帮助我们递归地找出当前 <code>subroot</code> 的 left 和 right subtree 的范围。而这要从这三种遍历方式的特点说起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val;  </span><br><span class="line">    TreeNode left;  </span><br><span class="line">    TreeNode right;  </span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.val = val;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.val = val;  </span><br><span class="line">        <span class="built_in">this</span>.left = left;  </span><br><span class="line">        <span class="built_in">this</span>.right = right;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        list.add(root.val);  </span><br><span class="line">        preorder(root.left, list);  </span><br><span class="line">        preorder(root.right, list);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        postorder(root.left, list);  </span><br><span class="line">        postorder(root.right, list);  </span><br><span class="line">        list.add(root.val);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        inorder(root.left, list);  </span><br><span class="line">        list.add(root.val);  </span><br><span class="line">        inorder(root.right, list);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th><code>inorder</code></th>
<th><code>preorder</code></th>
<th><code>postorder</code></th>
</tr>
</thead>
<tbody><tr>
<td>节点遍历顺序</td>
<td><code>root.left</code> -&gt; <code>root</code> -&gt; <code>root.right</code></td>
<td><code>root</code> -&gt; <code> root. left</code> -&gt; <code>root.right</code></td>
<td><code>root.left</code> -&gt; <code>root.right</code> -&gt; <code>root</code></td>
</tr>
<tr>
<td>subroot 在 sublist 中的位置 （sublist 指遍历 subroot 所在的子树而构成的序列）</td>
<td>无法单独确定</td>
<td><code>sublist[0]</code></td>
<td><code>sublist[sublist.length - 1]</code></td>
</tr>
<tr>
<td>特性</td>
<td></td>
<td>根据 <code>preorder</code> 的特性，<code>subroot</code> 在当前子序列中的下一个元素一定是 <code>subroot.left</code> （如果还有的话），也就是 <code>subroot.left = sublist[1]</code></td>
<td>根据 <code>postorder</code> 的特性，<code>subroot</code> 在当前子序列中的前一个元素一定是 <code>subroot.right</code> （如果还有的话），也就是 <code>subroot.right = sublist[sublist.length - 2]</code></td>
</tr>
<tr>
<td>子序列情况</td>
<td><code>[左子树子序列][subroot][右子树子序列]</code></td>
<td><code>[subroot][左子树子序列][右子树子序列]</code></td>
<td><code>[左子树子序列][右子树子序列][subroot]</code></td>
</tr>
</tbody></table>
<p>我们可以总结出，可以很容易从 <code>preorder</code> 以及 <code>postorder</code> 序列中得到 <code>subroot</code> 的值，这是因为 <code>subroot</code> 在这两种递归算法中总是被优先以及最后处理的，所以 <code>subroot</code> 总是出现在子序列的开头或者末尾。</p>
<p>而 <code>inorder</code> 则无法单独判断出 <code>subroot</code> 的位置，但一旦从 <code>preorder</code> 和 <code>postorder</code> 中知道 <code>subroot</code> 的值，那么就可以轻松知道 <code>subroot</code> 的左子树和右子树的范围（在 <code>inorder</code> 序列中，找到 <code>subroot</code> 的 index，位于 index 左边的归属于左子树，右边的归属于右子树）。</p>
<p>而且，一旦我们知道了左子树和右子树的数组长度，我们就可以很轻易地计算出 <code>subroot.left</code> 以及 <code>subroot.right</code> 在 <code>preorder</code> 以及 <code>postorder</code> 数组中的下标了。</p>
<p>因此，我们也就可以递归地从 3 种遍历序列中构建出整棵二叉树。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><strong>Example 1</strong>: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-%60preorder%60-and-%60inorder%60-traversal/">105. Construct Binary Tree from <code>preorder</code> and <code>inorder</code> Traversal</a></p>
<p><img src="/images/LeetCode-%E7%AC%94%E8%AE%B0-3%EF%BC%9AConstruct-Binary-Tree-from-xxx-Traversal/Pasted%20image%2020230226144205.png"></p>
<p>通过之前的讨论，我们通过 <code>preorder</code> 可以知道 <code>subroot</code> 的位置，那么，在 <code>inorder</code> 数组中找到 <code>subroot</code> 的 <code>index</code> ，位于 <code>index</code> 左边和右边的子序列就对应当前 <code>subroot</code> 的左子树以及右子树，确定左子树和右子树的范围也不再是难事。</p>
<p>算法如下：</p>
<ul>
<li><code>rootPreIndex</code> ： 当前 <code>subroot</code> 在 <code>inorder</code> 数组的 <code>index</code></li>
<li><code>inorderLeft</code> , <code>inorderRight</code> : 当前子树用到的 <code>inorder</code> 数组的左边界和右边界，用于控制递归终止的条件（base case）</li>
<li>找到 <code>subroot</code> 在 <code>inorder</code> 数组中的 <code>index</code> ： <code>rootInorderIndex</code></li>
<li>计算 <code>subroot.left</code> 子树的长度 <code>leftSubTreeSize = rootInorderIndex - inorderLeft</code></li>
<li>递归地构造左子树： <code>root.left = build(preorder, inorder, rootPreIndex + 1, inorderLeft, rootInorderIndex - 1);</code> ，其中：<ul>
<li><code>rootPreIndex + 1</code> 表示 <code>root.left</code> 在 <code>preorder</code> 数组的 <code>index</code> ；</li>
<li>左子树在 <code>inorder</code> 数组中的左边界和当前 <code>subroot</code> 是共享的： <code>inorderLeft</code> ；</li>
<li>左子树在 <code>inorder</code> 数组中的右边界应该是 <code>subroot</code> 在 <code>inorder</code> 数组中的 <code>index</code> 减去 1： <code>rootInorderIndex - 1</code> ；</li>
<li>也就是 <code>[inorderLeft, rootInorderIndex - 1]</code> 是左子树在 <code>inorder</code> 数组中的范围；</li>
</ul>
</li>
<li>递归地构造右子树： <code>root.right = build(preorder, inorder, rootPreIndex + leftSubTreeSize + 1, rootInorderIndex + 1, inorderRight);</code> ，其中：<ul>
<li><code>subroot.right</code> 在 <code>preorder</code> 数组中的 <code>index</code> 应该是 <code>rootPreIndex</code> 加上 <code>subroot</code> 的左子树的长度： <code>subrootPreIndex + leftSubTreeSize + 1</code> ；</li>
<li><code>subroot.right</code> 在 <code>inorder</code> 数组中的左边界应该是 <code>rootInorderIndex + 1</code> ；</li>
<li><code>subroot.right</code> 在 <code>inorder</code> 数组中的右边界应该是和当前 <code>subroot</code> 共享的，因此</li>
<li><code>[rootInorderIndex + 1, inorderRight]</code> 是右子树在 <code>inorder</code> 数组中的范围</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, inorder, <span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, <span class="type">int</span> rootPreIndex, <span class="type">int</span> inorderLeft, <span class="type">int</span> inorderRight)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorderLeft &gt; inorderRight || rootPreIndex &lt; <span class="number">0</span> || rootPreIndex &gt;= preorder.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[rootPreIndex]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootInorderIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == root.val) &#123;</span><br><span class="line">                rootInorderIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSubTreeSize</span> <span class="operator">=</span> rootInorderIndex - inorderLeft;</span><br><span class="line"></span><br><span class="line">        root.left = build(preorder, inorder, rootPreIndex + <span class="number">1</span>, inorderLeft, rootInorderIndex - <span class="number">1</span>);</span><br><span class="line">        root.right = build(preorder, inorder, rootPreIndex + leftSubTreeSize + <span class="number">1</span>, rootInorderIndex + <span class="number">1</span>, inorderRight);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2</strong>: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-%60preorder%60-and-%60postorder%60-traversal/">889. Construct Binary Tree from preorder and postorder Traversal</a></p>
<p><img src="/images/LeetCode-%E7%AC%94%E8%AE%B0-3%EF%BC%9AConstruct-Binary-Tree-from-xxx-Traversal/Pasted%20image%2020230226152220.png"></p>
<p>这道题目和之前的类似，只不过换成了 <code>preorder</code> 和 <code>postorder</code> 的组合，这也导致我们能够利用的信息有了变化：我们不再能通过 <code>inorder</code> 计算出左子树以及右子树的长度了，我们得通过另外的途径来进行计算。</p>
<p>之前也有提到过， <code>preoder</code> 和 <code>postorder</code> 有一个特性，就是：</p>
<ul>
<li>① 假设 <code>subroot</code> 在 <code>preorder</code> 中的下标是 <code>rootPreIndex</code> ，那么 <code>subroot.left</code> 在 <code>preorder</code> 中的下标一定是 <code>rootPreIndex + 1</code> ；</li>
<li>② 假设 <code>subroot</code> 在 <code>postorder</code> 中的下标是 <code>rootPostIndex</code> ，那么 <code>subroot.right</code> 在 <code>postorder</code> 的下标一定是 <code>rootPostIndex - 1</code> ；</li>
</ul>
<p>我们再结合两种遍历所构成的子序列的情况一起分析：</p>
<ul>
<li>③ <code>preorder</code> 子序列情况： <code>[subroot][左子树子序列][右子树子序列]</code></li>
<li>④ <code>postorder</code> 子序列情况： <code>[左子树子序列][右子树子序列][subroot]</code></li>
</ul>
<p>那么，我们可以通过结合 ② 和 ③，可以导出：</p>
<ul>
<li>我们通过 ② 知道了 <code>subroot.right</code> 的值，就可以得到它在 <code>preorder</code> 中的位置，它位于 <code>preorder</code> 数组中 <code>[右子树子序列]</code> 的第一个位置；</li>
<li>既然知道了右子树在 <code>preorder</code> 中的位置，那么左子树的长度就可以通过： <code>rightSubrootPreIndex - subrootPreIndex - 1</code> 得到；</li>
<li>右子树的长度当然也可以通过当前 <code>preorder</code> 的右边界减去 <code>subroot.right</code> 在 <code>preorder</code> 中的 <code>index</code> 得到</li>
</ul>
<p>同样，我们结合 ① 和 ④，也可以推断得到：</p>
<ul>
<li>我们通过 ① 知道了 <code>subroot.left</code> 的值，那么就可以知道 <code>subroot.left</code> 在 <code>postorder</code> 数组中的位置，它一定处在 <code>postorder</code> 数组中的 <code>[左子树子序列] </code> 的最后一个位置；</li>
<li>既然知道了左子树序列的首尾位置，那么就可以计算出左子树的长度： <code>leftSubrootPostIndex - postLeft + 1</code> ；</li>
</ul>
<p>那么，现在我们获得了递归算法所需的一切条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructFromPrePost</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, postorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span>[] post, <span class="type">int</span> preLeft, <span class="type">int</span> preRight, <span class="type">int</span> postLeft, <span class="type">int</span> postRight)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preLeft &gt; preRight) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[preLeft]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (preLeft + <span class="number">1</span> &gt; preRight) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftSubRootPostIndex;</span><br><span class="line">        <span class="keyword">for</span> (leftSubRootPostIndex = postLeft; leftSubRootPostIndex &lt;= postRight; ++leftSubRootPostIndex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (post[leftSubRootPostIndex] == pre[preLeft + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSubtreeLength</span> <span class="operator">=</span> leftSubRootPostIndex - postLeft + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        root.left = build(pre, post, preLeft + <span class="number">1</span>, preLeft + leftSubtreeLength, postLeft, postLeft + leftSubtreeLength - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        root.right = build(pre, post, preLeft + leftSubtreeLength + <span class="number">1</span>, preRight, postLeft + leftSubtreeLength, postRight - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-%60preorder%60-and-%60inorder%60-traversal/">105. Construct Binary Tree from preorder and inorder Traversal</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-%60inorder%60-and-%60postorder%60-traversal/">106. Construct Binary Tree from inorder and postorder Traversal</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-%60preorder%60-and-%60postorder%60-traversal/">889. Construct Binary Tree from preorder and postorder Traversal</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-search-tree-from-%60preorder%60-traversal/">1008. Construct Binary Search Tree from preorder Traversal</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh_CN">
    <link itemprop="mainEntityOfPage" href="https://caffcen.github.io/2023/02/19/LeetCode-%E7%AC%94%E8%AE%B0-2%EF%BC%9ABinary-Tree-Lowest-Common-Ancestor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="caffcen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caffcen's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/19/LeetCode-%E7%AC%94%E8%AE%B0-2%EF%BC%9ABinary-Tree-Lowest-Common-Ancestor/" class="post-title-link" itemprop="url">LeetCode 笔记 2：Binary Tree Lowest Common Ancestor</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-19 15:00:45" itemprop="dateCreated datePublished" datetime="2023-02-19T15:00:45+08:00">2023-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-26 15:52:26" itemprop="dateModified" datetime="2023-02-26T15:52:26+08:00">2023-02-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Loweset-Common-Ancestor"><a href="#Loweset-Common-Ancestor" class="headerlink" title="Loweset Common Ancestor"></a>Loweset Common Ancestor</h1><p>From wikipedia <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lowest_common_ancestor#:~:text=In%20ontologies%2C%20the%20lowest%20common,and%20w%20to%20the%20root.">Lowest common ancestor - Wikipedia</a>:</p>
<blockquote>
<p>In <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Graph_theory" title="Graph theory">graph theory</a> and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_science" title="Computer science">computer science</a>, the <strong>lowest common ancestor</strong> (<strong>LCA</strong>) (also called least common ancestor) of two nodes v and w in a [tree]( <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tree">https://en.wikipedia.org/wiki/Tree</a>_ (graph_theory) “Tree (graph theory)”) or <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" title="Directed acyclic graph">directed acyclic graph</a> (DAG) T is the lowest (i.e. deepest) node that has both v and w as descendants, where we define each node to be a descendant of itself (so if v has a direct connection from w, w is the lowest common ancestor).</p>
</blockquote>
<p>概念很简单，举几个例子：</p>
<p><img src="/images/LeetCode-%E7%AC%94%E8%AE%B0-2%EF%BC%9ABinary-Tree-Lowest-Common-Ancestor/Pasted%20image%2020230219143145.png"></p>
<ul>
<li>A 和 B 的 LCA 是 A；</li>
<li>B 和 C 的 LCA 是 A;</li>
<li>D 和 E 的 LCA 是 A;</li>
<li>E 和 I 的 LCA 是 C;</li>
<li>D 和 F 的 LCA 是 A;</li>
<li>G 和 H 的 LCA 是 D;</li>
<li>C 和 F 的 LCA 是 C;</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>大部分的二叉树题目，首先想到的是递归的解法，这是因为二叉树的数据结构特点所致：我们只知道当前节点和当前节点的相连节点的信息，而不知道全局信息。</p>
<p>那么，如何求解给定的任意另个 Node <code>X</code> 和 <code>Y</code> 的 <code>LCA</code> 呢？思路是这样的：</p>
<ol>
<li>我们从下往上，遇到 <code>X</code> 或者 <code>Y</code> 的时候，将它们返回给上层；遇到非 <code>X</code> 或者 <code>Y</code> 的节点则返回 <code>null</code></li>
<li>当上层 Node 拿到两个非空节点是，当前节点即为 <code>LCA</code> ，将当前节点返回</li>
<li>当上层 Node 拿到一个空节点一个非空节点时，那个非空节点要么是 <code>LCA</code> , 要么是 <code>X</code> 或者 <code>Y</code> , 我们继续将非空节点返回给上层处理即可</li>
</ol>
<p>因为对于任意给定的两个节点 <code>X</code> 或者 <code>Y</code> 来说，它们的 <code>LCA</code> ：</p>
<ol>
<li>要么是 <code>X</code> 或者 <code>Y</code> 其中的一个，这表示其中一个节点位于另一个节点的子树之中；</li>
<li>要么是 <code>X</code> 或者 <code>Y</code> 的上层节点，这表示 <code>X</code> 和 <code>Y</code> 都位于它们的 <code>LCA</code> 子树之中。</li>
</ol>
<p>而我们的算法在递归的过程中，至多只会遇到一次，左子树返回和右子树返回均不为空的情况；否则，我们将非空节点返回即可，该非空节点即为题目所求的 <code>LCA</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><strong>Example 1</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/">1123. Lowest Common Ancestor of Deepest Leaves</a></p>
<p><img src="/images/LeetCode-%E7%AC%94%E8%AE%B0-2%EF%BC%9ABinary-Tree-Lowest-Common-Ancestor/Pasted%20image%2020230219144905.png"></p>
<p>这道题是找出深度最深的所有叶子结点的 <code>LCA</code> ，只需分解成两个步骤：</p>
<ol>
<li>找到最大深度（ <code>DFS</code> ）</li>
<li>找到最大深度叶子结点的 <code>LCA</code></li>
</ol>
<p>最大深度的叶子结点可能有多个，但这不妨碍我们算法的步骤和正确性：</p>
<ol>
<li>对于最大深度的叶子结点，返回自身；</li>
<li>对非最大深度的节点，如果左子树返回和右子树返回均不为空，说明该节点为 <code>LCA</code> ，返回自身；否则返回左子树和右子树的非空返回；</li>
</ol>
<p>解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">deepestDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lcaDeepestLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        findDeepestDepth(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> lca(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">lca</span><span class="params">(TreeNode root, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftRet</span> <span class="operator">=</span> lca(root.left, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightRet</span> <span class="operator">=</span> lca(root.right, depth + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (depth == deepestDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leftRet != <span class="literal">null</span> &amp;&amp; rightRet != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftRet != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftRet;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rightRet;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findDeepestDepth</span><span class="params">(TreeNode root, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        deepestDepth = Math.max(deepestDepth, depth);</span><br><span class="line">        findDeepestDepth(root.left, depth + <span class="number">1</span>);</span><br><span class="line">        findDeepestDepth(root.right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. Lowest Common Ancestor of a Binary Search Tree</a></p>
<p><img src="/images/LeetCode-%E7%AC%94%E8%AE%B0-2%EF%BC%9ABinary-Tree-Lowest-Common-Ancestor/Pasted%20image%2020230219145454.png"></p>
<p>这道题目的区别是，数据结构换成了 BST，根据 BST 的性质我们可以，对于任意节点 <code>X</code> 和 <code>Y</code> 来说，它们的 <code>LCA</code> 一定满足： <code>X.val &lt;= LCA.val &amp;&amp; LCA.val &lt;= Y.val</code> 。</p>
<p>我们只要从上到下，递归地寻到满足这一布尔条件式的节点即可：</p>
<ol>
<li>如果 <code>LCA.val &lt; X.val &amp;&amp; LCA.val &lt; Y.val</code> ，那么当前节点的值太小，我们去右子树中递归寻找；</li>
<li>如果 <code>LCA.val &gt; X.val &amp;&amp; LCA.val &gt; Y.val</code> ，那么当前节点值太大，我们去左子树中递归寻找；</li>
<li>否则，当前节点值落在了 <code>X.val</code> 和 <code>Y.val</code> 之间，说明当前节点即为我们要找的 <code>LCA</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LCA-题目"><a href="#LCA-题目" class="headerlink" title="LCA 题目"></a>LCA 题目</h1><ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. Lowest Common Ancestor of a Binary Search Tree</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. Lowest Common Ancestor of a Binary Tree</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/">865. Smallest Subtree with all the Deepest Nodes</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/">1123. Lowest Common Ancestor of Deepest Leaves</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh_CN">
    <link itemprop="mainEntityOfPage" href="https://caffcen.github.io/2023/02/19/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="caffcen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caffcen's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/19/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/" class="post-title-link" itemprop="url">本地事务的原子性和持久性是如何实现的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-19 14:16:19" itemprop="dateCreated datePublished" datetime="2023-02-19T14:16:19+08:00">2023-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-26 14:13:09" itemprop="dateModified" datetime="2023-02-26T14:13:09+08:00">2023-02-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>要实现持久性，数据库事务的修改必须要写入到磁盘中，否则，当出现数据库异常退出、系统宕机、机房断电等意外情况时，位于内存中的所有数据将会丢失。</p>
<p>但是，磁盘的操作又不是一个原子性行为，数据库可能在写入前、写入后、正在写等状态发生异常，这就需要我们采取一定的手段来保证事务的原子性。</p>
<p>目前的数据库管理系统采用的是先写日志、再写磁盘的策略来保证事务的原子性以及持久性的。本文将阐述 Commit Logging、Shadow Paging 以及 Write-Ahead Logging 三种策略。</p>
<h1 id="Commit-Logging"><a href="#Commit-Logging" class="headerlink" title="Commit Logging"></a>Commit Logging</h1><p>Commit logging 是一种事务实现方式。在将数据修改写到磁盘之前，先把事务操作所需要的所有信息（包括修改什么数据、数据物理上位于哪个内存页和磁盘块中、从什么值改成什么值，等等）以日志的形式写到文件中。</p>
<p>只有日志记录全部写入到了磁盘之中后（日记文件也需要持久化到磁盘中），才会根据日志记录中记录的信息将修改写入到磁盘。</p>
<p>一个事务成功提交会，会在日志记录中添加上 <code>Commit Record</code> ，表示事务已经成功提交。在讲事务的修改成功写入到磁盘中后，还会在添加上一条 <code>End Record</code> 用来标识磁盘写入成功。</p>
<h2 id="Commit-Logging-如何保证持久性和原子性"><a href="#Commit-Logging-如何保证持久性和原子性" class="headerlink" title="Commit Logging 如何保证持久性和原子性"></a>Commit Logging 如何保证持久性和原子性</h2><p>一旦事务在日志记录中写入了 <code>Commit Record</code> ，那么该事务的所有修改已经全部安全落盘，那么，即便数据库在讲事务的修改写入到磁盘的过程中异常退出，在数据库系统重启恢复阶段，也能够将未完成的写入继续做完，这保证了事务的持久性。</p>
<p>如果 DBMS 在将一个事务的 <code>Commit Record</code> 安全写入到日志文件之前就异常终止，那么，只需要在 DBMS 重启恢复阶段，回滚该事务的所有变更的写入操作即可，这保证了事务的原子性，不会存在中间状态。</p>
<h2 id="Commit-Logging-的缺陷"><a href="#Commit-Logging-的缺陷" class="headerlink" title="Commit Logging 的缺陷"></a>Commit Logging 的缺陷</h2><p>Commit Logging 的缺陷在于，在事务讲修改更新操作完全写入日志记录文件之前，无法讲修改写到磁盘之中，日志文件的修改和磁盘的修改变成了同步的操作。如果在日志文件写入的同时磁盘处于空闲状态，那么将会导致磁盘资源的空置和浪费。</p>
<h1 id="Shadow-Paging"><a href="#Shadow-Paging" class="headerlink" title="Shadow Paging"></a>Shadow Paging</h1><p>Shadow paging 是另一个实现事务原子性以及持久性的技术。它是基于 Copy-on-Write 的方法。</p>
<p>Shadow paging 是这样工作的：</p>
<ol>
<li>在事务修改一个数据页之前，将会复制一份该数据页的副本，该副本即为原数据页的影子 shadow。</li>
<li>所有的修改将会作用于影子页，因为影子页没有被位于磁盘中的任何数据页所引用，因此它的修改是十分安全的，不会影响一致性。</li>
<li>当影子页准备被持久化的时候，磁盘中所有引用原数据页的指针将被指向影子页。</li>
<li>最后一步的指针修改可以认为是原子性的，现在磁盘在硬件上保证了不会出现改了『半个值』的情况。</li>
</ol>
<h2 id="Shadow-Paging-的缺点"><a href="#Shadow-Paging-的缺点" class="headerlink" title="Shadow Paging 的缺点"></a>Shadow Paging 的缺点</h2><p>Shadow paging 的实现要比 Commit Logging 更加简单，但只要涉及到并发锁时，Shadow Paging 所能够处理的并发事务数量将成为一个瓶颈。</p>
<h1 id="Write-Ahead-Logging"><a href="#Write-Ahead-Logging" class="headerlink" title="Write-Ahead Logging"></a>Write-Ahead Logging</h1><p>我们在描述 Commit Logging 的缺点时提到，Commit Logging 最大的缺陷在于日志记录的写入和磁盘的写入是一个同步操作：只有在日志记录写入完成之后才会开始将修改写入到磁盘，这是对硬件资源的空置和浪费。</p>
<p>如果我们允许在日志记录写入完全之前，就开始将日志记录中的一部分修改写入到磁盘，那将提高硬件资源的使用情况，同时加快整个事务的执行过程，这就是 Write-Ahead Logging 策略。</p>
<h2 id="FORCE-and-STEAL"><a href="#FORCE-and-STEAL" class="headerlink" title="FORCE and STEAL"></a>FORCE and STEAL</h2><p>我们将事务提交后，修改必须同时完成写入称为 FORCE，不必须同时完成写入称为 NO-FORCE。</p>
<p>我们将事务提交之前，允许修改提前写入到磁盘称为 STEAL，不允许称为 NO-STEAL。</p>
<p>一个事务如果是 NO-FORCE 且 STEAL 的话，那么性能将达到最好：</p>
<ol>
<li>如果一个事务已经将修改安全写到了日志文件中，那么我们可以随时随地将修改写到磁盘，而无需立刻就这么做（现实中大多数 DBMS 均采用的 NO-FORCE 策略）；</li>
<li>允许事务将修改在事务提交之前就开始写入到磁盘中，这将提高磁盘的 IO 利用率。</li>
</ol>
<h2 id="Write-Ahead-Logging-如何保证原子性以及持久性"><a href="#Write-Ahead-Logging-如何保证原子性以及持久性" class="headerlink" title="Write-Ahead Logging 如何保证原子性以及持久性"></a>Write-Ahead Logging 如何保证原子性以及持久性</h2><p>Commit Logging 是 NO-FORCE + NO-STEAL 的策略，因为如果 DBMS 异常退出但修改没有写入完全，那么将提前写入的这些数据就是错误数据。</p>
<p>Write-Ahead Logging 允许 NO-FORCE，也允许 STEAL，它使用了 Undo Log 来保证提前写入的数据的正确性。当数据落盘前，必须先记录 Undo Log，Undo Log 记录了哪个数据页、哪一行的数据从什么值变成了什么值，等等。在 Undo Log 的帮助下，即便发生了异常我们也能够保证数据的正确了。</p>
<p>Write-Ahead Logging 的 DBMS 崩溃恢复时会执行下面 3 个阶段的操作：</p>
<ul>
<li><strong>分析阶段</strong>（Analysis）：该阶段从最后一次 checkpoint 开始扫描日志，找出所有没有 <code>End Record</code> 的事务，组成待恢复的事务集合。</li>
<li><strong>重做阶段</strong>（Redo）：该阶段会将待恢复事务集合中，已经在日志文件中写入了 <code>Commit Record</code> 的事务进行重做，写入完成后再添加上一条 <code>End Record</code> ，然后移除出待恢复事务集合。这些事务的全部修改都已经包含在了日志文件中，可以安全落盘，保证了事务的持久性。</li>
<li><strong>回滚阶段</strong>（Undo）：待恢复的事务集合中，还剩下那些没有在日志文件中写入 <code>Commit Record</code> ，它们被称为 Loser，根据 Undo Log 中的信息，将已经提前写入磁盘的信息重新改写回去，以达到回滚这些 Loser 事务的目的。这保证了事务的原子性。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>NO-STEAL</th>
<th>STEAL</th>
</tr>
</thead>
<tbody><tr>
<td>NO-FORCE</td>
<td></td>
<td>最快</td>
</tr>
<tr>
<td>FORCE</td>
<td>最慢</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>NO-STEAL</th>
<th>STEAL</th>
</tr>
</thead>
<tbody><tr>
<td>NO-FORCE</td>
<td>重做日志</td>
<td>重做日志+回滚日志</td>
</tr>
<tr>
<td>FORCE</td>
<td>不需要日志</td>
<td>回滚日志</td>
</tr>
</tbody></table>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shadow_paging">Shadow paging - Wikipedia</a></li>
<li><a target="_blank" rel="noopener" href="http://icyfenix.cn/architect-perspective/general-architecture/transaction/local.html">本地事务 | 凤凰架构</a></li>
<li>《MySQL 技术内幕——InnoDB 存储引擎》</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">caffcen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">caffcen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
