<!DOCTYPE html>
<html lang="en-us"
  dir="ltr">

  <head>
	<meta name="generator" content="Hugo 0.125.7">
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width">

<title>
    
    Lihang Liu&#39;s Homepage
    
</title>



<link rel="stylesheet" href="/assets/combined.min.95bd8f25e3a82100ceaab7f49774821700d8d89a2b551df9cd199c4de2d1626f.css" media="all">




  



  </head>

  

  
  
  

  <body class="auto">

    <div class="content">
      <header>
        

<div class="header">
    <h1 class="header-title">Lihang Liu&#39;s Homepage</h1>

    <div class="flex">
        

        
        
        <p class="small  bold ">
            <a href="/">
                /Home
            </a>
        </p>
        
        <p class="small ">
            <a href="/blog/">
                /Blog
            </a>
        </p>
        
        <p class="small ">
            <a href="/archive/">
                /Archive
            </a>
        </p>
        
        
    </div>

</div>
      </header>

      <main class="main">
        

<h1 id="hi">Hi!</h1>
<p>As an experienced software engineer with over 2.5 years of professional experience, I am deeply passionate about distributed systems, computer networking, databases, systems programming, and software development. I am excited to continue expanding my knowledge and skills through a pursuit of a PhD degree in Computer Science.</p>
<p>I have authored several blog posts in Chinese (in /Archive) covering topics such as databases, CAP theory, and Java concurrency. I plan to continue documenting my work and studies through regular blog writing, as I believe this is an excellent way to solidify my understanding and share insights with the community.</p>
<p>You can access my resume [here].</p>
<h1 id="work-experience">Work Experience</h1>
<ul>
<li><strong>Alibaba ICBU</strong>, Senior Software Engineer, 10/2023 - 03/2024</li>
<li><strong>Tencent Tenpay</strong>, Backend Engineer, 07/2021 - 09/2023</li>
</ul>
<h1 id="education">Education</h1>
<ul>
<li><strong>Northwestern University</strong>, Master of Computer Science, 09/2019 - 05/2021</li>
<li><strong>South China University of Technology</strong>, Bachelor of Computer Science, 09/2015 - 07/2019</li>
</ul>









<div class="social-icons">
    <a href="https://www.linkedin.com/in/caffcen" target="_blank"
        rel="noopener noreferrer me"
        title="Linkedin">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path>
    <rect x="2" y="9" width="4" height="12"></rect>
    <circle cx="4" cy="4" r="2"></circle>
</svg>
    </a>
    <a href="https://github.com/caffcen" target="_blank"
        rel="noopener noreferrer me"
        title="Github">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
    stroke-linecap="round" stroke-linejoin="round">
    <path
        d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22">
    </path>
</svg>
    </a>
</div>







<h1> Archive </h1>












<div class="post-line">

    
    
    
    

    <p class="line-date">21 May 2023 </p>

    <div>
        <p class="line-title">
            <a href="/archive/13_aqs_intro/">
                AbstractQueuedSynchronizer 简介
            </a>
        </p>

        
        <p class="line-summary"> 本文主要介绍了 JUC 中的 AbstractQueuedSynchronizer 的实现基础、其和 CLH 队列锁之间的关联、独占锁模式及共享锁模式加解锁的过程等。不包含 ConditionObject 的分析。
简介 AQS 提供了实现同步阻塞队列的基本框架，是 juc 包中其他众多同步原语和锁实现的基础。
Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released. </p>
        
    </div>
</div>

<div class="post-line">

    
    
    
    

    <p class="line-date">9 Apr 2023 </p>

    <div>
        <p class="line-title">
            <a href="/archive/12_clh_queue_lock/">
                深入理解 CLH Queue Lock
            </a>
        </p>

        
        <p class="line-summary"> JUC 包中的很多同步原语是基于 AbstractQueuedSynchronizer（以下简称 AQS） 实现的，而 AQS 的实现又是基于 CLH 队列锁（CLH queued lock），因此学习并理解 CLH 队列锁对我们学习 JUC 中的各种同步原语非常有帮助。本文将阐述 CLH 队列锁的实现和原理。
CLH Queue Lock CLH 队列锁是由 Craig, Landin, Hagersten 三位大佬提出的，因此被称为 CLH 队列锁，它是一种自旋公平锁，基于虚链表实现（virtual linked list）。
《The Art of Multiprocessor Programming》7.5.2 节给出了 CLH 可能的一种 Java 语言实现：
public class CLHLock implements Lock { AtomicReference&lt;QNode&gt; tail; ThreadLocal&lt;QNode&gt; myPred; ThreadLocal&lt;QNode&gt; myNode; public CLHLock() { tail = new AtomicReference&lt;QNode&gt;(new QNode()); myNode = new ThreadLocal&lt;QNode&gt;() { protected QNode initialValue() { return new QNode(); } }; myPred = new ThreadLocal&lt;QNode&gt;() { protected QNode initialValue() { return null; } }; } public void lock() { QNode qnode = myNode. </p>
        
    </div>
</div>

<div class="post-line">

    
    
    
    

    <p class="line-date">2 Apr 2023 </p>

    <div>
        <p class="line-title">
            <a href="/archive/11_leetcode_note_5_search_in_rotated_sorted_array/">
                LeetCode 笔记 5：Search in Rotated Sorted Array
            </a>
        </p>

        
        <p class="line-summary"> 今天要讲的题目都使用到了二分查找（或者和二分查找紧密相关），同时又都是基于一个 Rotated Sorted Array。那么先从 Rotated Sorted Array 的特点讲起吧。
Rotated Sorted Array 的定义是这样子的：
There is an integer array nums sorted in ascending order (with distinct values). nums is possibly rotated at an unknown pivot index k (1 &lt;= k &lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed).
就拿 int[] nums = new int[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; 举例好了，如果 nums 在 nums[4] 位置进行旋转，那么它将变成： {4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3} ，那么我们能够观察到几个特性： </p>
        
    </div>
</div>

<div class="post-line">

    
    
    
    

    <p class="line-date">26 Mar 2023 </p>

    <div>
        <p class="line-title">
            <a href="/archive/10_b&#43;tree/">
                深入理解 B&#43; Tree
            </a>
        </p>

        
        <p class="line-summary"> B+ 树的定义和 B 树是类似的，B+ 树在数据结构上进行了一定的改进，它的特性使得它的某些场景下教 B 树有了显著的优势。本文笔者将对 B+ 树的定义、特点以及应用进行详细解析。
定义 B+ 树和 B 树的定义是类似的，它们都是平衡多路搜索树，在文件系统和数据库系统中都有大量的应用。只不过 B+ 树有以下几点独特的属性：
B+ 树的非叶子结点不包含值（value），只存储键（key） B+ 树的叶子结点之间是互相连接的，B+ 树叶子结点这一层构成了一个双向链表（Doubly linked list） B+ 树的叶子结点这一层存储了所有数据的 key-links pairs，而 B 树的所有数据是散布在整棵树中的，B 树的叶子结点这一层只存储了数据全集的一部分。 B+ 树的查找、添加、删除算法和 B 树是类似的，可以参考笔者的上一篇博客进行了解：深入理解 B-Tree | caffcen&rsquo;s blog，在此不在赘述。
特性 对于阶数为 m 的 B+ 树，它拥有如下性质：
每个节点最多有 m 个子节点。 每个节点最多有 m-1 个键值。 每个内部节点至少有 ⌈m/2⌉ 个子节点，根节点除外。 根节点至少有 2 个子节点。 所有叶子节点出现在同一层级上，叶子结点与叶子结点之间有双向引用，叶子结点这一层构成了一条双向链表。 一个具有 k 个子节点的非叶节点包含 k-1 个键值。 叶子结点这一层存储了所有数据（所有的 key-link pairs） B-Tree vs. B+ Tree B 树和 B+ 树的区别对比，可以参考 Stack Overflow 这个问题：database - What are the differences between B trees and B+ trees? </p>
        
    </div>
</div>

<div class="post-line">

    
    
    
    

    <p class="line-date">18 Mar 2023 </p>

    <div>
        <p class="line-title">
            <a href="/archive/9_btree/">
                深入理解 B-Tree
            </a>
        </p>

        
        <p class="line-summary"> B 树是一种平衡多路搜索树，可以看做是对二叉搜索树（Binary Search Tree）的拓展。因为 B 树的自平衡以及允许一个节点存储多个值的特性，被广泛运用在数据库以及文件系统中，非常适用于存储大量数据。
要理解 B 树，最好的方式就是学习 2-3 搜索树——B 树的一种特例。
1. 2-3 搜索树 (2-3 Search Tree) 1.1 定义 2-3 搜索树是对二叉搜索树一种自然的扩充，二叉搜索树的任意一个节点只能存储一个 key、两个 links，但是 2-3 搜索树扩展了这一设定，2-3 搜索树允许存在以下两类节点：
2-node：拥有一个 key 两个 links，2-node 和二叉搜索树中的节点完全等价，两个 links 分别指向左子树和右子树： 左子树中的所有节点的 key 均『小于』当前 2-node 的 key； 右子树中的所有节点均『大于』当前 2-node 的 key。 3-node：拥有两个 keys 三个 links，3 个 links 分别指向左子树、右子树和中间子树： 左子树中的所有节点的 key 均『小于』当前 3-node 较小的 key； 右子树中的所有节点均『大于』当前 3-node 较大的 key； 中间子树中的所有节点均大于 3-node 较小的 key，且小于 3-node 较大的 key。 这里大于、小于打引号是因为类型的大小关系往往是可以自定义的。
本文使用 key 表示存储数据的键，links 表示指向其他节点的引用，value 表示存储数据实际存储的值，在数据库以及文件系统中，value 可能是指向实际数据的指针。 </p>
        
    </div>
</div>



<div class="pagination">
    <div class="pagination-control">
        
    </div>
    <div class="page-number">
        <p>
            1/3
        </p>
    </div>
    <div class="pagination-control">
        
        <a href="https://caffcen.github.io/page/2/">
            next
        </a>
        
    </div>
</div>





      </main>
    </div>

    <footer>
      <p>Powered by
    <a href="https://gohugo.io/">Hugo</a>
    and
    <a href="https://github.com/tomfran/typo">tomfran/typo</a>
</p>


    </footer>

  </body>

  <script>

  function isAuto() {
    return document.body.classList.contains("auto");
  }

  function setTheme() {
    if (!isAuto()) {
      return
    }

    document.body.classList.remove("auto");
    let cls = "light";
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      cls = "dark";
    }

    document.body.classList.add(cls);
  }

  function invertBody() {
    document.body.classList.toggle("dark");
    document.body.classList.toggle("light");
  }

  if (isAuto()) {
    window.matchMedia('(prefers-color-scheme: dark)').addListener(invertBody);
  }

  setTheme();

</script>

</html>