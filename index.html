<!DOCTYPE html>
<html lang="zh_CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"caffcen.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="caffcen&#39;s blog">
<meta property="og:url" content="https://caffcen.github.io/index.html">
<meta property="og:site_name" content="caffcen&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="caffcen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://caffcen.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh_CN'
  };
</script>

  <title>caffcen's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">caffcen's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh_CN">
    <link itemprop="mainEntityOfPage" href="https://caffcen.github.io/2023/02/26/LeetCode-%E7%AC%94%E8%AE%B0-3%EF%BC%9AConstruct-Binary-Tree-from-xxx-Traversal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="caffcen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caffcen's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/26/LeetCode-%E7%AC%94%E8%AE%B0-3%EF%BC%9AConstruct-Binary-Tree-from-xxx-Traversal/" class="post-title-link" itemprop="url">LeetCode 笔记 3：Construct Binary Tree from xxx Traversal</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-26 15:51:14 / Modified: 15:54:09" itemprop="dateCreated datePublished" datetime="2023-02-26T15:51:14+08:00">2023-02-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这一类题目（具体题目可以参考文末的链接）要求我们从 <code>inorder</code>, <code>preorder</code> 及 <code>postorder</code> traversal 其中的两个构建出二叉树，之所以能够通过这三种遍历方式中的两个就构建出整棵二叉树，是因为任意两种遍历方式都能够帮助我们递归地找出当前 <code>subroot</code> 的 left 和 right subtree 的范围。而这要从这三种遍历方式的特点说起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> val;  </span><br><span class="line">    TreeNode left;  </span><br><span class="line">    TreeNode right;  </span><br><span class="line"></span><br><span class="line">    TreeNode() &#123;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.val = val;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.val = val;  </span><br><span class="line">        <span class="built_in">this</span>.left = left;  </span><br><span class="line">        <span class="built_in">this</span>.right = right;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        list.add(root.val);  </span><br><span class="line">        preorder(root.left, list);  </span><br><span class="line">        preorder(root.right, list);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        postorder(root.left, list);  </span><br><span class="line">        postorder(root.right, list);  </span><br><span class="line">        list.add(root.val);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        inorder(root.left, list);  </span><br><span class="line">        list.add(root.val);  </span><br><span class="line">        inorder(root.right, list);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th><code>inorder</code></th>
<th><code>preorder</code></th>
<th><code>postorder</code></th>
</tr>
</thead>
<tbody><tr>
<td>节点遍历顺序</td>
<td><code>root.left</code> -&gt; <code>root</code> -&gt; <code>root.right</code></td>
<td><code>root</code> -&gt; <code> root. left</code> -&gt; <code>root.right</code></td>
<td><code>root.left</code> -&gt; <code>root.right</code> -&gt; <code>root</code></td>
</tr>
<tr>
<td>subroot 在 sublist 中的位置 （sublist 指遍历 subroot 所在的子树而构成的序列）</td>
<td>无法单独确定</td>
<td><code>sublist[0]</code></td>
<td><code>sublist[sublist.length - 1]</code></td>
</tr>
<tr>
<td>特性</td>
<td></td>
<td>根据 <code>preorder</code> 的特性，<code>subroot</code> 在当前子序列中的下一个元素一定是 <code>subroot.left</code> （如果还有的话），也就是 <code>subroot.left = sublist[1]</code></td>
<td>根据 <code>postorder</code> 的特性，<code>subroot</code> 在当前子序列中的前一个元素一定是 <code>subroot.right</code> （如果还有的话），也就是 <code>subroot.right = sublist[sublist.length - 2]</code></td>
</tr>
<tr>
<td>子序列情况</td>
<td><code>[左子树子序列][subroot][右子树子序列]</code></td>
<td><code>[subroot][左子树子序列][右子树子序列]</code></td>
<td><code>[左子树子序列][右子树子序列][subroot]</code></td>
</tr>
</tbody></table>
<p>我们可以总结出，可以很容易从 <code>preorder</code> 以及 <code>postorder</code> 序列中得到 <code>subroot</code> 的值，这是因为 <code>subroot</code> 在这两种递归算法中总是被优先以及最后处理的，所以 <code>subroot</code> 总是出现在子序列的开头或者末尾。</p>
<p>而 <code>inorder</code> 则无法单独判断出 <code>subroot</code> 的位置，但一旦从 <code>preorder</code> 和 <code>postorder</code> 中知道 <code>subroot</code> 的值，那么就可以轻松知道 <code>subroot</code> 的左子树和右子树的范围（在 <code>inorder</code> 序列中，找到 <code>subroot</code> 的 index，位于 index 左边的归属于左子树，右边的归属于右子树）。</p>
<p>而且，一旦我们知道了左子树和右子树的数组长度，我们就可以很轻易地计算出 <code>subroot.left</code> 以及 <code>subroot.right</code> 在 <code>preorder</code> 以及 <code>postorder</code> 数组中的下标了。</p>
<p>因此，我们也就可以递归地从 3 种遍历序列中构建出整棵二叉树。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><strong>Example 1</strong>: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-%60preorder%60-and-%60inorder%60-traversal/">105. Construct Binary Tree from <code>preorder</code> and <code>inorder</code> Traversal</a></p>
<p><img src="/images/LeetCode-%E7%AC%94%E8%AE%B0-3%EF%BC%9AConstruct-Binary-Tree-from-xxx-Traversal/Pasted%20image%2020230226144205.png"></p>
<p>通过之前的讨论，我们通过 <code>preorder</code> 可以知道 <code>subroot</code> 的位置，那么，在 <code>inorder</code> 数组中找到 <code>subroot</code> 的 <code>index</code> ，位于 <code>index</code> 左边和右边的子序列就对应当前 <code>subroot</code> 的左子树以及右子树，确定左子树和右子树的范围也不再是难事。</p>
<p>算法如下：</p>
<ul>
<li><code>rootPreIndex</code> ： 当前 <code>subroot</code> 在 <code>inorder</code> 数组的 <code>index</code></li>
<li><code>inorderLeft</code> , <code>inorderRight</code> : 当前子树用到的 <code>inorder</code> 数组的左边界和右边界，用于控制递归终止的条件（base case）</li>
<li>找到 <code>subroot</code> 在 <code>inorder</code> 数组中的 <code>index</code> ： <code>rootInorderIndex</code></li>
<li>计算 <code>subroot.left</code> 子树的长度 <code>leftSubTreeSize = rootInorderIndex - inorderLeft</code></li>
<li>递归地构造左子树： <code>root.left = build(preorder, inorder, rootPreIndex + 1, inorderLeft, rootInorderIndex - 1);</code> ，其中：<ul>
<li><code>rootPreIndex + 1</code> 表示 <code>root.left</code> 在 <code>preorder</code> 数组的 <code>index</code> ；</li>
<li>左子树在 <code>inorder</code> 数组中的左边界和当前 <code>subroot</code> 是共享的： <code>inorderLeft</code> ；</li>
<li>左子树在 <code>inorder</code> 数组中的右边界应该是 <code>subroot</code> 在 <code>inorder</code> 数组中的 <code>index</code> 减去 1： <code>rootInorderIndex - 1</code> ；</li>
<li>也就是 <code>[inorderLeft, rootInorderIndex - 1]</code> 是左子树在 <code>inorder</code> 数组中的范围；</li>
</ul>
</li>
<li>递归地构造右子树： <code>root.right = build(preorder, inorder, rootPreIndex + leftSubTreeSize + 1, rootInorderIndex + 1, inorderRight);</code> ，其中：<ul>
<li><code>subroot.right</code> 在 <code>preorder</code> 数组中的 <code>index</code> 应该是 <code>rootPreIndex</code> 加上 <code>subroot</code> 的左子树的长度： <code>subrootPreIndex + leftSubTreeSize + 1</code> ；</li>
<li><code>subroot.right</code> 在 <code>inorder</code> 数组中的左边界应该是 <code>rootInorderIndex + 1</code> ；</li>
<li><code>subroot.right</code> 在 <code>inorder</code> 数组中的右边界应该是和当前 <code>subroot</code> 共享的，因此</li>
<li><code>[rootInorderIndex + 1, inorderRight]</code> 是右子树在 <code>inorder</code> 数组中的范围</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, inorder, <span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, <span class="type">int</span> rootPreIndex, <span class="type">int</span> inorderLeft, <span class="type">int</span> inorderRight)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorderLeft &gt; inorderRight || rootPreIndex &lt; <span class="number">0</span> || rootPreIndex &gt;= preorder.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[rootPreIndex]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootInorderIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == root.val) &#123;</span><br><span class="line">                rootInorderIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSubTreeSize</span> <span class="operator">=</span> rootInorderIndex - inorderLeft;</span><br><span class="line"></span><br><span class="line">        root.left = build(preorder, inorder, rootPreIndex + <span class="number">1</span>, inorderLeft, rootInorderIndex - <span class="number">1</span>);</span><br><span class="line">        root.right = build(preorder, inorder, rootPreIndex + leftSubTreeSize + <span class="number">1</span>, rootInorderIndex + <span class="number">1</span>, inorderRight);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2</strong>: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-%60preorder%60-and-%60postorder%60-traversal/">889. Construct Binary Tree from preorder and postorder Traversal</a></p>
<p><img src="/images/LeetCode-%E7%AC%94%E8%AE%B0-3%EF%BC%9AConstruct-Binary-Tree-from-xxx-Traversal/Pasted%20image%2020230226152220.png"></p>
<p>这道题目和之前的类似，只不过换成了 <code>preorder</code> 和 <code>postorder</code> 的组合，这也导致我们能够利用的信息有了变化：我们不再能通过 <code>inorder</code> 计算出左子树以及右子树的长度了，我们得通过另外的途径来进行计算。</p>
<p>之前也有提到过， <code>preoder</code> 和 <code>postorder</code> 有一个特性，就是：</p>
<ul>
<li>① 假设 <code>subroot</code> 在 <code>preorder</code> 中的下标是 <code>rootPreIndex</code> ，那么 <code>subroot.left</code> 在 <code>preorder</code> 中的下标一定是 <code>rootPreIndex + 1</code> ；</li>
<li>② 假设 <code>subroot</code> 在 <code>postorder</code> 中的下标是 <code>rootPostIndex</code> ，那么 <code>subroot.right</code> 在 <code>postorder</code> 的下标一定是 <code>rootPostIndex - 1</code> ；</li>
</ul>
<p>我们再结合两种遍历所构成的子序列的情况一起分析：</p>
<ul>
<li>③ <code>preorder</code> 子序列情况： <code>[subroot][左子树子序列][右子树子序列]</code></li>
<li>④ <code>postorder</code> 子序列情况： <code>[左子树子序列][右子树子序列][subroot]</code></li>
</ul>
<p>那么，我们可以通过结合 ② 和 ③，可以导出：</p>
<ul>
<li>我们通过 ② 知道了 <code>subroot.right</code> 的值，就可以得到它在 <code>preorder</code> 中的位置，它位于 <code>preorder</code> 数组中 <code>[右子树子序列]</code> 的第一个位置；</li>
<li>既然知道了右子树在 <code>preorder</code> 中的位置，那么左子树的长度就可以通过： <code>rightSubrootPreIndex - subrootPreIndex - 1</code> 得到；</li>
<li>右子树的长度当然也可以通过当前 <code>preorder</code> 的右边界减去 <code>subroot.right</code> 在 <code>preorder</code> 中的 <code>index</code> 得到</li>
</ul>
<p>同样，我们结合 ① 和 ④，也可以推断得到：</p>
<ul>
<li>我们通过 ① 知道了 <code>subroot.left</code> 的值，那么就可以知道 <code>subroot.left</code> 在 <code>postorder</code> 数组中的位置，它一定处在 <code>postorder</code> 数组中的 <code>[左子树子序列] </code> 的最后一个位置；</li>
<li>既然知道了左子树序列的首尾位置，那么就可以计算出左子树的长度： <code>leftSubrootPostIndex - postLeft + 1</code> ；</li>
</ul>
<p>那么，现在我们获得了递归算法所需的一切条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructFromPrePost</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, postorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span>[] post, <span class="type">int</span> preLeft, <span class="type">int</span> preRight, <span class="type">int</span> postLeft, <span class="type">int</span> postRight)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (preLeft &gt; preRight) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[preLeft]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (preLeft + <span class="number">1</span> &gt; preRight) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftSubRootPostIndex;</span><br><span class="line">        <span class="keyword">for</span> (leftSubRootPostIndex = postLeft; leftSubRootPostIndex &lt;= postRight; ++leftSubRootPostIndex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (post[leftSubRootPostIndex] == pre[preLeft + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSubtreeLength</span> <span class="operator">=</span> leftSubRootPostIndex - postLeft + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        root.left = build(pre, post, preLeft + <span class="number">1</span>, preLeft + leftSubtreeLength, postLeft, postLeft + leftSubtreeLength - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        root.right = build(pre, post, preLeft + leftSubtreeLength + <span class="number">1</span>, preRight, postLeft + leftSubtreeLength, postRight - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-%60preorder%60-and-%60inorder%60-traversal/">105. Construct Binary Tree from preorder and inorder Traversal</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-%60inorder%60-and-%60postorder%60-traversal/">106. Construct Binary Tree from inorder and postorder Traversal</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-tree-from-%60preorder%60-and-%60postorder%60-traversal/">889. Construct Binary Tree from preorder and postorder Traversal</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/construct-binary-search-tree-from-%60preorder%60-traversal/">1008. Construct Binary Search Tree from preorder Traversal</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh_CN">
    <link itemprop="mainEntityOfPage" href="https://caffcen.github.io/2023/02/19/LeetCode-%E7%AC%94%E8%AE%B0-2%EF%BC%9ABinary-Tree-Lowest-Common-Ancestor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="caffcen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caffcen's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/19/LeetCode-%E7%AC%94%E8%AE%B0-2%EF%BC%9ABinary-Tree-Lowest-Common-Ancestor/" class="post-title-link" itemprop="url">LeetCode 笔记 2：Binary Tree Lowest Common Ancestor</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-19 15:00:45" itemprop="dateCreated datePublished" datetime="2023-02-19T15:00:45+08:00">2023-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-26 15:52:26" itemprop="dateModified" datetime="2023-02-26T15:52:26+08:00">2023-02-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Loweset-Common-Ancestor"><a href="#Loweset-Common-Ancestor" class="headerlink" title="Loweset Common Ancestor"></a>Loweset Common Ancestor</h1><p>From wikipedia <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lowest_common_ancestor#:~:text=In%20ontologies%2C%20the%20lowest%20common,and%20w%20to%20the%20root.">Lowest common ancestor - Wikipedia</a>:</p>
<blockquote>
<p>In <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Graph_theory" title="Graph theory">graph theory</a> and <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Computer_science" title="Computer science">computer science</a>, the <strong>lowest common ancestor</strong> (<strong>LCA</strong>) (also called least common ancestor) of two nodes v and w in a [tree]( <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Tree">https://en.wikipedia.org/wiki/Tree</a>_ (graph_theory) “Tree (graph theory)”) or <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" title="Directed acyclic graph">directed acyclic graph</a> (DAG) T is the lowest (i.e. deepest) node that has both v and w as descendants, where we define each node to be a descendant of itself (so if v has a direct connection from w, w is the lowest common ancestor).</p>
</blockquote>
<p>概念很简单，举几个例子：</p>
<p><img src="/images/LeetCode-%E7%AC%94%E8%AE%B0-2%EF%BC%9ABinary-Tree-Lowest-Common-Ancestor/Pasted%20image%2020230219143145.png"></p>
<ul>
<li>A 和 B 的 LCA 是 A；</li>
<li>B 和 C 的 LCA 是 A;</li>
<li>D 和 E 的 LCA 是 A;</li>
<li>E 和 I 的 LCA 是 C;</li>
<li>D 和 F 的 LCA 是 A;</li>
<li>G 和 H 的 LCA 是 D;</li>
<li>C 和 F 的 LCA 是 C;</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>大部分的二叉树题目，首先想到的是递归的解法，这是因为二叉树的数据结构特点所致：我们只知道当前节点和当前节点的相连节点的信息，而不知道全局信息。</p>
<p>那么，如何求解给定的任意另个 Node <code>X</code> 和 <code>Y</code> 的 <code>LCA</code> 呢？思路是这样的：</p>
<ol>
<li>我们从下往上，遇到 <code>X</code> 或者 <code>Y</code> 的时候，将它们返回给上层；遇到非 <code>X</code> 或者 <code>Y</code> 的节点则返回 <code>null</code></li>
<li>当上层 Node 拿到两个非空节点是，当前节点即为 <code>LCA</code> ，将当前节点返回</li>
<li>当上层 Node 拿到一个空节点一个非空节点时，那个非空节点要么是 <code>LCA</code> , 要么是 <code>X</code> 或者 <code>Y</code> , 我们继续将非空节点返回给上层处理即可</li>
</ol>
<p>因为对于任意给定的两个节点 <code>X</code> 或者 <code>Y</code> 来说，它们的 <code>LCA</code> ：</p>
<ol>
<li>要么是 <code>X</code> 或者 <code>Y</code> 其中的一个，这表示其中一个节点位于另一个节点的子树之中；</li>
<li>要么是 <code>X</code> 或者 <code>Y</code> 的上层节点，这表示 <code>X</code> 和 <code>Y</code> 都位于它们的 <code>LCA</code> 子树之中。</li>
</ol>
<p>而我们的算法在递归的过程中，至多只会遇到一次，左子树返回和右子树返回均不为空的情况；否则，我们将非空节点返回即可，该非空节点即为题目所求的 <code>LCA</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><strong>Example 1</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/">1123. Lowest Common Ancestor of Deepest Leaves</a></p>
<p><img src="/images/LeetCode-%E7%AC%94%E8%AE%B0-2%EF%BC%9ABinary-Tree-Lowest-Common-Ancestor/Pasted%20image%2020230219144905.png"></p>
<p>这道题是找出深度最深的所有叶子结点的 <code>LCA</code> ，只需分解成两个步骤：</p>
<ol>
<li>找到最大深度（ <code>DFS</code> ）</li>
<li>找到最大深度叶子结点的 <code>LCA</code></li>
</ol>
<p>最大深度的叶子结点可能有多个，但这不妨碍我们算法的步骤和正确性：</p>
<ol>
<li>对于最大深度的叶子结点，返回自身；</li>
<li>对非最大深度的节点，如果左子树返回和右子树返回均不为空，说明该节点为 <code>LCA</code> ，返回自身；否则返回左子树和右子树的非空返回；</li>
</ol>
<p>解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">deepestDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lcaDeepestLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        findDeepestDepth(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> lca(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">lca</span><span class="params">(TreeNode root, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftRet</span> <span class="operator">=</span> lca(root.left, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightRet</span> <span class="operator">=</span> lca(root.right, depth + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (depth == deepestDepth) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leftRet != <span class="literal">null</span> &amp;&amp; rightRet != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftRet != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftRet;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> rightRet;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findDeepestDepth</span><span class="params">(TreeNode root, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        deepestDepth = Math.max(deepestDepth, depth);</span><br><span class="line">        findDeepestDepth(root.left, depth + <span class="number">1</span>);</span><br><span class="line">        findDeepestDepth(root.right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Example 2</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. Lowest Common Ancestor of a Binary Search Tree</a></p>
<p><img src="/images/LeetCode-%E7%AC%94%E8%AE%B0-2%EF%BC%9ABinary-Tree-Lowest-Common-Ancestor/Pasted%20image%2020230219145454.png"></p>
<p>这道题目的区别是，数据结构换成了 BST，根据 BST 的性质我们可以，对于任意节点 <code>X</code> 和 <code>Y</code> 来说，它们的 <code>LCA</code> 一定满足： <code>X.val &lt;= LCA.val &amp;&amp; LCA.val &lt;= Y.val</code> 。</p>
<p>我们只要从上到下，递归地寻到满足这一布尔条件式的节点即可：</p>
<ol>
<li>如果 <code>LCA.val &lt; X.val &amp;&amp; LCA.val &lt; Y.val</code> ，那么当前节点的值太小，我们去右子树中递归寻找；</li>
<li>如果 <code>LCA.val &gt; X.val &amp;&amp; LCA.val &gt; Y.val</code> ，那么当前节点值太大，我们去左子树中递归寻找；</li>
<li>否则，当前节点值落在了 <code>X.val</code> 和 <code>Y.val</code> 之间，说明当前节点即为我们要找的 <code>LCA</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LCA-题目"><a href="#LCA-题目" class="headerlink" title="LCA 题目"></a>LCA 题目</h1><ol>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. Lowest Common Ancestor of a Binary Search Tree</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. Lowest Common Ancestor of a Binary Tree</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/">865. Smallest Subtree with all the Deepest Nodes</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/">1123. Lowest Common Ancestor of Deepest Leaves</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh_CN">
    <link itemprop="mainEntityOfPage" href="https://caffcen.github.io/2023/02/19/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="caffcen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caffcen's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/19/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/" class="post-title-link" itemprop="url">本地事务的原子性和持久性是如何实现的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-19 14:16:19" itemprop="dateCreated datePublished" datetime="2023-02-19T14:16:19+08:00">2023-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-26 14:13:09" itemprop="dateModified" datetime="2023-02-26T14:13:09+08:00">2023-02-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>要实现持久性，数据库事务的修改必须要写入到磁盘中，否则，当出现数据库异常退出、系统宕机、机房断电等意外情况时，位于内存中的所有数据将会丢失。</p>
<p>但是，磁盘的操作又不是一个原子性行为，数据库可能在写入前、写入后、正在写等状态发生异常，这就需要我们采取一定的手段来保证事务的原子性。</p>
<p>目前的数据库管理系统采用的是先写日志、再写磁盘的策略来保证事务的原子性以及持久性的。本文将阐述 Commit Logging、Shadow Paging 以及 Write-Ahead Logging 三种策略。</p>
<h1 id="Commit-Logging"><a href="#Commit-Logging" class="headerlink" title="Commit Logging"></a>Commit Logging</h1><p>Commit logging 是一种事务实现方式。在将数据修改写到磁盘之前，先把事务操作所需要的所有信息（包括修改什么数据、数据物理上位于哪个内存页和磁盘块中、从什么值改成什么值，等等）以日志的形式写到文件中。</p>
<p>只有日志记录全部写入到了磁盘之中后（日记文件也需要持久化到磁盘中），才会根据日志记录中记录的信息将修改写入到磁盘。</p>
<p>一个事务成功提交会，会在日志记录中添加上 <code>Commit Record</code> ，表示事务已经成功提交。在讲事务的修改成功写入到磁盘中后，还会在添加上一条 <code>End Record</code> 用来标识磁盘写入成功。</p>
<h2 id="Commit-Logging-如何保证持久性和原子性"><a href="#Commit-Logging-如何保证持久性和原子性" class="headerlink" title="Commit Logging 如何保证持久性和原子性"></a>Commit Logging 如何保证持久性和原子性</h2><p>一旦事务在日志记录中写入了 <code>Commit Record</code> ，那么该事务的所有修改已经全部安全落盘，那么，即便数据库在讲事务的修改写入到磁盘的过程中异常退出，在数据库系统重启恢复阶段，也能够将未完成的写入继续做完，这保证了事务的持久性。</p>
<p>如果 DBMS 在将一个事务的 <code>Commit Record</code> 安全写入到日志文件之前就异常终止，那么，只需要在 DBMS 重启恢复阶段，回滚该事务的所有变更的写入操作即可，这保证了事务的原子性，不会存在中间状态。</p>
<h2 id="Commit-Logging-的缺陷"><a href="#Commit-Logging-的缺陷" class="headerlink" title="Commit Logging 的缺陷"></a>Commit Logging 的缺陷</h2><p>Commit Logging 的缺陷在于，在事务讲修改更新操作完全写入日志记录文件之前，无法讲修改写到磁盘之中，日志文件的修改和磁盘的修改变成了同步的操作。如果在日志文件写入的同时磁盘处于空闲状态，那么将会导致磁盘资源的空置和浪费。</p>
<h1 id="Shadow-Paging"><a href="#Shadow-Paging" class="headerlink" title="Shadow Paging"></a>Shadow Paging</h1><p>Shadow paging 是另一个实现事务原子性以及持久性的技术。它是基于 Copy-on-Write 的方法。</p>
<p>Shadow paging 是这样工作的：</p>
<ol>
<li>在事务修改一个数据页之前，将会复制一份该数据页的副本，该副本即为原数据页的影子 shadow。</li>
<li>所有的修改将会作用于影子页，因为影子页没有被位于磁盘中的任何数据页所引用，因此它的修改是十分安全的，不会影响一致性。</li>
<li>当影子页准备被持久化的时候，磁盘中所有引用原数据页的指针将被指向影子页。</li>
<li>最后一步的指针修改可以认为是原子性的，现在磁盘在硬件上保证了不会出现改了『半个值』的情况。</li>
</ol>
<h2 id="Shadow-Paging-的缺点"><a href="#Shadow-Paging-的缺点" class="headerlink" title="Shadow Paging 的缺点"></a>Shadow Paging 的缺点</h2><p>Shadow paging 的实现要比 Commit Logging 更加简单，但只要涉及到并发锁时，Shadow Paging 所能够处理的并发事务数量将成为一个瓶颈。</p>
<h1 id="Write-Ahead-Logging"><a href="#Write-Ahead-Logging" class="headerlink" title="Write-Ahead Logging"></a>Write-Ahead Logging</h1><p>我们在描述 Commit Logging 的缺点时提到，Commit Logging 最大的缺陷在于日志记录的写入和磁盘的写入是一个同步操作：只有在日志记录写入完成之后才会开始将修改写入到磁盘，这是对硬件资源的空置和浪费。</p>
<p>如果我们允许在日志记录写入完全之前，就开始将日志记录中的一部分修改写入到磁盘，那将提高硬件资源的使用情况，同时加快整个事务的执行过程，这就是 Write-Ahead Logging 策略。</p>
<h2 id="FORCE-and-STEAL"><a href="#FORCE-and-STEAL" class="headerlink" title="FORCE and STEAL"></a>FORCE and STEAL</h2><p>我们将事务提交后，修改必须同时完成写入称为 FORCE，不必须同时完成写入称为 NO-FORCE。</p>
<p>我们将事务提交之前，允许修改提前写入到磁盘称为 STEAL，不允许称为 NO-STEAL。</p>
<p>一个事务如果是 NO-FORCE 且 STEAL 的话，那么性能将达到最好：</p>
<ol>
<li>如果一个事务已经将修改安全写到了日志文件中，那么我们可以随时随地将修改写到磁盘，而无需立刻就这么做（现实中大多数 DBMS 均采用的 NO-FORCE 策略）；</li>
<li>允许事务将修改在事务提交之前就开始写入到磁盘中，这将提高磁盘的 IO 利用率。</li>
</ol>
<h2 id="Write-Ahead-Logging-如何保证原子性以及持久性"><a href="#Write-Ahead-Logging-如何保证原子性以及持久性" class="headerlink" title="Write-Ahead Logging 如何保证原子性以及持久性"></a>Write-Ahead Logging 如何保证原子性以及持久性</h2><p>Commit Logging 是 NO-FORCE + NO-STEAL 的策略，因为如果 DBMS 异常退出但修改没有写入完全，那么将提前写入的这些数据就是错误数据。</p>
<p>Write-Ahead Logging 允许 NO-FORCE，也允许 STEAL，它使用了 Undo Log 来保证提前写入的数据的正确性。当数据落盘前，必须先记录 Undo Log，Undo Log 记录了哪个数据页、哪一行的数据从什么值变成了什么值，等等。在 Undo Log 的帮助下，即便发生了异常我们也能够保证数据的正确了。</p>
<p>Write-Ahead Logging 的 DBMS 崩溃恢复时会执行下面 3 个阶段的操作：</p>
<ul>
<li><strong>分析阶段</strong>（Analysis）：该阶段从最后一次 checkpoint 开始扫描日志，找出所有没有 <code>End Record</code> 的事务，组成待恢复的事务集合。</li>
<li><strong>重做阶段</strong>（Redo）：该阶段会将待恢复事务集合中，已经在日志文件中写入了 <code>Commit Record</code> 的事务进行重做，写入完成后再添加上一条 <code>End Record</code> ，然后移除出待恢复事务集合。这些事务的全部修改都已经包含在了日志文件中，可以安全落盘，保证了事务的持久性。</li>
<li><strong>回滚阶段</strong>（Undo）：待恢复的事务集合中，还剩下那些没有在日志文件中写入 <code>Commit Record</code> ，它们被称为 Loser，根据 Undo Log 中的信息，将已经提前写入磁盘的信息重新改写回去，以达到回滚这些 Loser 事务的目的。这保证了事务的原子性。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>NO-STEAL</th>
<th>STEAL</th>
</tr>
</thead>
<tbody><tr>
<td>NO-FORCE</td>
<td></td>
<td>最快</td>
</tr>
<tr>
<td>FORCE</td>
<td>最慢</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>NO-STEAL</th>
<th>STEAL</th>
</tr>
</thead>
<tbody><tr>
<td>NO-FORCE</td>
<td>重做日志</td>
<td>重做日志+回滚日志</td>
</tr>
<tr>
<td>FORCE</td>
<td>不需要日志</td>
<td>回滚日志</td>
</tr>
</tbody></table>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Shadow_paging">Shadow paging - Wikipedia</a></li>
<li><a target="_blank" rel="noopener" href="http://icyfenix.cn/architect-perspective/general-architecture/transaction/local.html">本地事务 | 凤凰架构</a></li>
<li>《MySQL 技术内幕——InnoDB 存储引擎》</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh_CN">
    <link itemprop="mainEntityOfPage" href="https://caffcen.github.io/2023/02/12/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="caffcen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caffcen's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/12/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/" class="post-title-link" itemprop="url">本地事务的隔离性是如何实现的</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-12 16:47:37" itemprop="dateCreated datePublished" datetime="2023-02-12T16:47:37+08:00">2023-02-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-26 14:15:56" itemprop="dateModified" datetime="2023-02-26T14:15:56+08:00">2023-02-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>如果没有并发的存在，数据库所有事务总是串行执行的，那么也就不会有临界资源竞争的情况出现，但现实情况是不可能没有并发的存在。</p>
<p>为了保证并发的正确性，需要通过对数据库资源加锁。本文将首先介绍数据库中的锁，之后会介绍各个隔离级别及其实现方式。</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><ul>
<li><strong>写锁</strong>（Write Lock，也叫作排他锁，eXclusive Lock，简写为 X-Lock）：如果数据有加写锁，就只有持有写锁的事务才能对数据进行写入操作，数据加持着写锁时，其他事务不能写入数据，也不能施加读锁。</li>
<li><strong>读锁</strong>（Read Lock，也叫作共享锁，Shared Lock，简写为 S-Lock）：多个事务可以对同一个数据添加多个读锁，数据被加上读锁后就不能再被加上写锁，所以其他事务不能对该数据进行写入，但仍然可以读取。对于持有读锁的事务，如果该数据只有它自己一个事务加了读锁，允许直接将其升级为写锁，然后写入数据。</li>
<li><strong>范围锁</strong>（Range Lock）：对于某个范围直接加排他锁，在这个范围内的数据不能被写入。</li>
</ul>
<p>特别注意：<strong>写锁禁止其他事务施加读锁，而不是禁止事务读取数据。</strong></p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>只有读锁和读锁是兼容的，写锁不兼容任何其他锁。</p>
<table>
<thead>
<tr>
<th></th>
<th>Write Lock (X)</th>
<th>Read Lock (S)</th>
</tr>
</thead>
<tbody><tr>
<td>Write Lock (X)</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td>Read Lock (S)</td>
<td>不兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>事务的隔离性是通过锁的机制来实现的，事务的隔离性越高，并发吞吐量越低，为了让开发人员能够在吞吐量以及隔离性之前取的较好的平衡点，数据库提供了多种隔离性级别。</p>
<p>从本质上来说，事务在不同隔离级别下的不同表现，来源于不同隔离级别采取的加锁机制的不同。</p>
<p>下表是事务的 4 个隔离级别，隔离性从上到下依次递减：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>特征</th>
<th>可能存在的问题</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Serializability</strong>，可串行性</td>
<td>多个事务并发执行的效果，和串行执行的效果一致。</td>
<td>无</td>
</tr>
<tr>
<td><strong>Repeatable read</strong>，可重复读</td>
<td>可重复度保证一个事务读取到的数据，在整个事务执行过程中不会改变。</td>
<td>幻读</td>
</tr>
<tr>
<td><strong>Read committed</strong>，读已提交</td>
<td>不允许一个事务读取到其他事务提交的数据。</td>
<td>幻读、不可重复读</td>
</tr>
<tr>
<td><strong>Read uncommitted</strong>，读未提交</td>
<td>允许一个事务读取到其他事务未提交的数据。</td>
<td>幻读、不可重复读、脏读</td>
</tr>
</tbody></table>
<h2 id="Serializability-可串行性"><a href="#Serializability-可串行性" class="headerlink" title="Serializability, 可串行性"></a>Serializability, 可串行性</h2><p>对事务所涉及到的数据加读锁、写锁、范围锁即可实现 <code>Serializability</code> 所要求的隔离性。</p>
<h2 id="Repeatable-Read-可重复读"><a href="#Repeatable-Read-可重复读" class="headerlink" title="Repeatable Read, 可重复读"></a>Repeatable Read, 可重复读</h2><p><code>可重复读</code> 对事务所涉及的数据加读锁和写锁，且一直持有至事务结束，但不再加范围锁。这就意味着 <code>可重复读</code> 可能会出现幻读（Phantom reads, 可参考下文针对幻读问题的讨论）的问题，比如说：</p>
<p><img src="/images/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/Pasted%20image%2020230212154319.png"></p>
<p>事务 T1 在两次查询取得的数据将会不同，这是因为事务 T1 并没有加范围锁，而 T2 在两次查询之间插入了一行新的记录，这是允许的，因为 <code>可重复读</code> 仅仅只会对数据加读锁和写锁。</p>
<h2 id="Read-Committed-读已提交"><a href="#Read-Committed-读已提交" class="headerlink" title="Read Committed, 读已提交"></a>Read Committed, 读已提交</h2><p><code>读已提交</code> 对事务所涉及的数据将会加写锁和读锁，写锁在被施加后会一直持续到事务结束为止，但是读锁在查询操作结束后将会立即得到释放。</p>
<p><code>读已提交</code> 除了幻读问题之外，还存在着 <code>不可重复读</code> （Non-repeatable reads, 可参考下文对不可重复读问题的讨论）的问题，举个例子：</p>
<p><img src="/images/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/Pasted%20image%2020230212155522.png"></p>
<p>事务 T1 将会读到 T2 对数据的修改，这是因为在 <code>读已提交</code> 隔离级别下，事务不会对数据加贯穿整个事务生命周期的读锁，在 T1 事务第一次查询结束之后，该行记录的写锁就被释放了，T2 也因此能够对改行数据进行写操作。</p>
<h2 id="Read-Uncommitted-读未提交"><a href="#Read-Uncommitted-读未提交" class="headerlink" title="Read Uncommitted, 读未提交"></a>Read Uncommitted, 读未提交</h2><p><code>读未提交</code> 对事务涉及的数据只加写锁，会一直持续到事务结束，但完全不加读锁。</p>
<p><code>读未提交</code> 除了有幻读、不可重复读问题之外，还可能面临脏读的问题（Dirty reads，可参考下文对脏读问题的解释），举例如下：</p>
<p><img src="/images/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/Pasted%20image%2020230212160142.png"></p>
<p><code>读未提交</code> 完全不加读锁，因此即便 T2 对行数据加了写锁，T1 也能读到 T2 对行数据的修改。</p>
<p>这里要特别注意，写锁会阻塞任何加写锁或读锁的操作，并不阻塞单纯的读取行为。 <code>读未提交</code> 在查询时不加读锁，因此不会被阻塞。</p>
<p>假如在 <code>读已提交</code> 的隔离级别下，因为在查询前会先加读锁，而 T2 此时已对该行数据加了写锁，T1 事务的第二次查询将会被阻塞。</p>
<p>综上所述：</p>
<ol>
<li>事务的隔离性是通过锁的机制来实现的。</li>
<li>事务隔离性的不同本质上是锁机制的不同。</li>
</ol>
<h1 id="隔离性问题"><a href="#隔离性问题" class="headerlink" title="隔离性问题"></a>隔离性问题</h1><h2 id="Phantom-Reads-幻读"><a href="#Phantom-Reads-幻读" class="headerlink" title="Phantom Reads, 幻读"></a>Phantom Reads, 幻读</h2><p>幻读是指，当一个事务 A 使用相同的查询条件进行两次范围查询时，在两次查询之间有其他事务插入或者删除了数据，导致事务 A 前后两次查询到的数据不一致。</p>
<p>From Wikipedia:</p>
<blockquote>
<p>A <em>phantom read</em> occurs when a transaction retrieves a set of rows twice and new rows are inserted into or removed from that set by another transaction that is committed in between.</p>
</blockquote>
<p><img src="/images/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/Pasted%20image%2020230212161843.png"></p>
<h2 id="Non-repeatable-Reads-不可重复读"><a href="#Non-repeatable-Reads-不可重复读" class="headerlink" title="Non-repeatable Reads, 不可重复读"></a>Non-repeatable Reads, 不可重复读</h2><p>不可重复读是指，一个事务 A 对某一行查询了两次，因为其他事务在两次查询之间对这一行数据进行了修改，导致事务 A 的两次查询结果不一致。</p>
<p>From Wikipedia:</p>
<blockquote>
<p>A <em>non-repeatable read</em> occurs when a transaction retrieves a row twice and that row is updated by another transaction that is committed in between.</p>
</blockquote>
<p><img src="/images/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/Pasted%20image%2020230212162127.png"></p>
<h2 id="Drity-Reads-脏读"><a href="#Drity-Reads-脏读" class="headerlink" title="Drity Reads, 脏读"></a>Drity Reads, 脏读</h2><p>脏读是指，一个事务读到了另一个事务未提交的修改。</p>
<p>From Wikipedia:</p>
<blockquote>
<p>A <em>dirty read</em> (aka <em>uncommitted dependency</em>) occurs when a transaction retrieves a row that has been updated by another transaction that is not yet committed.</p>
</blockquote>
<p><img src="/images/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/Pasted%20image%2020230212162144.png"></p>
<h2 id="Dirty-Write-脏写"><a href="#Dirty-Write-脏写" class="headerlink" title="Dirty Write, 脏写"></a>Dirty Write, 脏写</h2><p>脏写是指，一个事务覆盖了另一个事务未提交的更新：</p>
<p><img src="/images/%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84/Pasted%20image%2020230212162527.png"></p>
<p>假设事务既不加读锁也不加写锁，那么 T1 对行数据的更新将会被 T2 对该行数据的写操作所覆盖。</p>
<p>不过，即便是 Read Uncommitted 隔离级别下，也不会出现这种情况。脏写意味着事务的原子性都被破坏了，所以一般不把它纳入隔离性相关问题的讨论范围内。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>下表总结了各个事务隔离级别下可能遇到的问题：</p>
<table>
<thead>
<tr>
<th></th>
<th>Phantom Reads</th>
<th>Non-repeatable Reads</th>
<th>Dirty Reads</th>
</tr>
</thead>
<tbody><tr>
<td>Serializability</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
<tr>
<td>Repeatable Read</td>
<td>可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
<tr>
<td>Read Committed</td>
<td>可能</td>
<td>可能</td>
<td>不可能</td>
</tr>
<tr>
<td>Read Uncommitted</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
</tbody></table>
<p>下表总结了各个事务隔离级别下对锁的使用情况：</p>
<table>
<thead>
<tr>
<th></th>
<th>Read Locks</th>
<th>Write Locks</th>
<th>Range Locks</th>
</tr>
</thead>
<tbody><tr>
<td>Serializability</td>
<td>加读锁并持有到事务结束</td>
<td>加写锁并持有到事务结束</td>
<td>加范围锁并持有到事务结束</td>
</tr>
<tr>
<td>Repeatable Read</td>
<td>加读锁并持有到事务结束</td>
<td>加写锁并持有到事务结束</td>
<td>不加范围锁</td>
</tr>
<tr>
<td>Read Committed</td>
<td>加读锁，查询结束后立即释放</td>
<td>加写锁并持有到事务结束</td>
<td>不加范围锁</td>
</tr>
<tr>
<td>Read Uncommitted</td>
<td>不加读锁</td>
<td>加写锁并持有到事务结束</td>
<td>不加范围锁</td>
</tr>
</tbody></table>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a target="_blank" rel="noopener" href="http://icyfenix.cn/architect-perspective/general-architecture/transaction/local.html">本地事务 | 凤凰架构</a></li>
<li>《MySQL 技术内幕——InnoDB 存储引擎》</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Isolation_(database_systems)">Isolation (database systems) - Wikipedia</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh_CN">
    <link itemprop="mainEntityOfPage" href="https://caffcen.github.io/2023/02/04/CAP-%E7%90%86%E8%AE%BA%E5%92%8C-PACELC-%E7%90%86%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="caffcen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caffcen's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/04/CAP-%E7%90%86%E8%AE%BA%E5%92%8C-PACELC-%E7%90%86%E8%AE%BA/" class="post-title-link" itemprop="url">CAP 理论和 PACELC 理论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-02-04 15:57:20 / Modified: 16:22:52" itemprop="dateCreated datePublished" datetime="2023-02-04T15:57:20+08:00">2023-02-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h1><p>CAP 理论阐述的是，一个分布式系统不可能同时满足<strong>一致性</strong>（consistency）、<strong>可用性</strong>（availability）和<strong>分区容错性</strong>（partition tolerance）这 3 个特性，至多只能满足其中的两个，实际上要么满足 CP（一致性+分区容错性），要么满足 AP（可用性+分区容错性）。</p>
<h2 id="一致性-consistency"><a href="#一致性-consistency" class="headerlink" title="一致性 consistency"></a>一致性 consistency</h2><p>读请求（read request）总是能得到最新的值，也就是说，在任何时间，分布式系统中所有节点对于任一一个值存储的都是相同版本。这便是一致性。</p>
<h2 id="可用性-availability"><a href="#可用性-availability" class="headerlink" title="可用性 availability"></a>可用性 availability</h2><p>可用性意思是，每一个请求都能够收到非异常返回，但并不保证请求拿到的值就是最新的值。</p>
<h2 id="分区容错性-partition-tolerance"><a href="#分区容错性-partition-tolerance" class="headerlink" title="分区容错性 partition tolerance"></a>分区容错性 partition tolerance</h2><p>分区（partition）意味着分布式系统的任意一对节点出现了通讯中断。而分区容错性则要求，即便在内部节点出现故障时，整个系统依然能够运行，部分节点之间的网络异常不会导致整个系统的失效。</p>
<h2 id="分区容错的必要性"><a href="#分区容错的必要性" class="headerlink" title="分区容错的必要性"></a>分区容错的必要性</h2><p>分区容错性是一个分布式系统不可或缺的特性，因为任何系统的任意节点之间都有可能出现网络故障。当一个系统出现分区，部分内部节点无法访问彼此的时候，必须要在一致性和可用性之间做出选择：是为了保障服务依然可用而损害一致性呢，又或者是保障一致性而拒绝服务？</p>
<p><img src="/images/CAP-%E7%90%86%E8%AE%BA%E5%92%8C-PACELC-%E7%90%86%E8%AE%BA/Drawing%202023-02-04%2015.26.25.excalidraw.png"></p>
<p>举个例子，考虑上图的情况，假设有两个节点 A 和 B 之间发生了分区的情况，当用户先向节点 B 给 X 变量写一个值后，从节点 A 读取 X 变量，那么系统面临着两个选择：</p>
<ul>
<li>它可以选择其中一个请求返回失败，但这样就损害了可用性</li>
<li>它可以处理两个请求，但是针对读请求返回一个旧的值，但这样就破坏了一致性</li>
</ul>
<p>因此，我们能够得出结论：</p>
<blockquote>
<p>实际上，CAP 理论要求一个分布式系统在内部节点发生网络故障，分区错误发生时，要么选择保留一致性，要么选择维护可用性。</p>
</blockquote>
<h1 id="PACELC-理论"><a href="#PACELC-理论" class="headerlink" title="PACELC 理论"></a>PACELC 理论</h1><p>PACELC 理论是 CAP 理论的补充，以下这段文字摘抄自维基百科 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/PACELC_theorem">PACELC theorem - Wikipedia</a>，它指出了 PACELC 这几个字母的缩写是怎么来的：</p>
<blockquote>
<p>In <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Theoretical_computer_science" title="Theoretical computer science">theoretical computer science</a>, the <strong>PACELC theorem</strong> is an extension to the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CAP_theorem" title="CAP theorem">CAP theorem</a>. It states that in case of network partitioning (P) in a distributed computer system, one has to choose between availability (A) and consistency (C) (as per the CAP theorem), but else (E), even when the system is running normally in the absence of partitions, one has to choose between latency (L) and consistency (C).</p>
</blockquote>
<p>一个分布式系统也不会一直面临着分区网络故障，当内部节点之间不存在通讯问题时，一致性和可用性都是可以得到保证的，特别是可用性基本不会出现问题。</p>
<p>不过，为了保证一致性，数据在节点之间进行复制时会需要一定的时间，这部分复制时间可能会给用户请求带来不小的延迟，因此，在一致性和延迟（latency）之间有存在利弊权衡：</p>
<ol>
<li>系统可以牺牲一致性，不等待值在所有节点写入完成；或者</li>
<li>保证强一致性，但请求需要等待值在各个节点完成写入后才能够收到返回</li>
</ol>
<h2 id="基于-PACELC-理论的系统分类"><a href="#基于-PACELC-理论的系统分类" class="headerlink" title="基于 PACELC 理论的系统分类"></a>基于 PACELC 理论的系统分类</h2><p>我们可以根据系统是否发生了分区错误、分区错误发生时选择维持哪种特性（C 或 A），以及未发生分区错误时系统是否想要保持强一致性，来给分布式系统做如下 4 种分类：</p>
<table>
<thead>
<tr>
<th>分区错误发生时</th>
<th>系统没有分区错误</th>
</tr>
</thead>
<tbody><tr>
<td>AP</td>
<td>EL</td>
</tr>
<tr>
<td>AP</td>
<td>EC</td>
</tr>
<tr>
<td>CP</td>
<td>EL</td>
</tr>
<tr>
<td>CP</td>
<td>EC</td>
</tr>
</tbody></table>
<p>其中的 E 表示 else，举例来说，AP&#x2F;EL 系统在分区错误发生时希望维持系统的可用性，除此之外也就是内部节点没有网络故障时，希望保持低延迟。</p>
<p>一般来说，一个系统要么希望是高可用、低延迟的，要么总是要求强一致性，因此大多数系统都落到了 AP&#x2F;EL 或 CP&#x2F;EC 这两个类别之中。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh_CN">
    <link itemprop="mainEntityOfPage" href="https://caffcen.github.io/2023/01/08/LeetCode-%E7%AC%94%E8%AE%B0-1%EF%BC%9ASliding-Window-%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="caffcen">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="caffcen's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/08/LeetCode-%E7%AC%94%E8%AE%B0-1%EF%BC%9ASliding-Window-%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">LeetCode 笔记 1：Sliding Window 题目总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-01-08 16:58:18" itemprop="dateCreated datePublished" datetime="2023-01-08T16:58:18+08:00">2023-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-02-26 15:52:25" itemprop="dateModified" datetime="2023-02-26T15:52:25+08:00">2023-02-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是滑动窗口算法"><a href="#什么是滑动窗口算法" class="headerlink" title="什么是滑动窗口算法"></a>什么是滑动窗口算法</h1><p>先用一个简单的<a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-size-subarray-sum/">题目</a>来说明什么是滑动窗口算法。</p>
<p><img src="/images/LeetCode-%E7%AC%94%E8%AE%B0-1%EF%BC%9ASliding-Window-%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Pasted%20image%2020230108160856.png"></p>
<p>最直接的思路就是，对于每个给定的 index，计算出从该 index 开始的一个最小 subarray，其和大于 <code>target</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; ++j) &#123;</span><br><span class="line">        sum += nums[j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            minLength = Math.min(minLength, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法的问题就在于，相邻的 index 之间，存在着重合的计算。</p>
<p>解决办法就是维护一个滑动窗口，这样就能够解决重复计算的问题了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE, sum = <span class="number">0</span>, windowStart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">windowEnd</span> <span class="operator">=</span> <span class="number">0</span>; windowEnd &lt; nums.length; ++windowEnd) &#123;</span><br><span class="line">            sum += nums[windowEnd];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                res = Math.min(res, windowEnd - windowStart + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[windowStart++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每次迭代，将滑动窗口的大小扩大 <code>1</code>，并将 <code>nums[windowEnd]</code> 加到子数组和 <code>sum</code> 中。</li>
<li>当子数组和 <code>sum &gt; target</code> 时，更新结果</li>
<li>因为当前子数组和已经比 <code>target</code> 大，为求得最优解，我们缩小滑动窗口大小：将滑动窗口的左端的值 <code>nums[windowStart]</code> 从 <code>sum</code> 中减去，并将窗口左端点下标加一</li>
</ul>
<p>总的来说，滑动窗口算法是基于迭代的算法，其使用包括如下步骤：</p>
<ul>
<li>每次迭代扩大滑动窗口的大小：<code>++windowEnd</code></li>
<li>更新窗口左端点 <code>windowStart</code>，使窗口范围的数据是满足题目要求的</li>
<li>更新结果</li>
</ul>
<h1 id="使用到-Map-的题目类型"><a href="#使用到-Map-的题目类型" class="headerlink" title="使用到 Map 的题目类型"></a>使用到 Map 的题目类型</h1><p>有些题目需要使用哈希表来记录滑动窗口中数据出现的次数，典型的题目为：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutation-in-string/">567. Permutation in String</a></p>
<p><img src="/images/LeetCode-%E7%AC%94%E8%AE%B0-1%EF%BC%9ASliding-Window-%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Pasted%20image%2020230108163150.png"></p>
<p>这类题目的思路都很接近：</p>
<ul>
<li>用一个 Map（<code>charCntMap</code>） 来存储目标字符串每个字符的频率</li>
<li>用一个 <code>int</code> （<code>cnt</code>）来存储 Map 的大小（<code>charCntMap.size()</code>），即目标字符串（当前题目是 <code>s1</code>）有多少个不重复的字符</li>
<li>维护一个滑动窗口，每次扩大窗口大小时，如果当前字符出现在 Map 中，将其频率减一</li>
<li>当该字符的频率变为 0 时，将 <code>cnt</code> 减一；当 <code>cnt == 0</code> 时，说明目标数组所有字符已经出现在了当前的滑动窗口中，这时更新结果（该题目返回 <code>true</code>）</li>
<li>当滑动窗口非法时（该题目是<code>窗口大小 &gt; s1.length()</code>），将窗口左端点的 <code>index</code> 加一（<code>windowStart + 1</code>）；同时：<ul>
<li>如果 Map 存储的该字符出现的频率为 0，则 <code>++cnt</code>，这表明了当前的滑动窗口无法存储目标字符串（<code>s1</code>）所有的字符了</li>
<li>将 Map 存储的该字符的频率加一</li>
</ul>
</li>
</ul>
<p>Java 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; charCntMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : s1.toCharArray()) &#123;</span><br><span class="line">            charCntMap.put(ch, charCntMap.getOrDefault(ch, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">windowStart</span> <span class="operator">=</span> <span class="number">0</span>, cnt = charCntMap.size();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">windowEnd</span> <span class="operator">=</span> <span class="number">0</span>; windowEnd &lt; s2.length(); ++windowEnd) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s2.charAt(windowEnd);</span><br><span class="line">            <span class="keyword">if</span> (charCntMap.containsKey(ch)) &#123;</span><br><span class="line">                charCntMap.put(ch, charCntMap.get(ch) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (charCntMap.get(ch) == <span class="number">0</span>) &#123;</span><br><span class="line">                    --cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (windowEnd - windowStart + <span class="number">1</span> &gt; s1.length()) &#123;</span><br><span class="line">                ch = s2.charAt(windowStart++);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (charCntMap.containsKey(ch)) &#123;</span><br><span class="line">                    charCntMap.put(ch, charCntMap.get(ch) + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (charCntMap.get(ch) == <span class="number">1</span>) &#123;</span><br><span class="line">                        ++cnt;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似的题目有：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/contains-duplicate-ii/">219. Contains Duplicate II</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/fruit-into-baskets/">904. Fruit Into Baskets</a></li>
</ul>
<h1 id="使用到-Set-的题目类型"><a href="#使用到-Set-的题目类型" class="headerlink" title="使用到 Set 的题目类型"></a>使用到 Set 的题目类型</h1><p>滑动窗口算法有些时候需要配合 HashSet 使用，如 <a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">3. Longest Substring Without Repeating Characters</a>:</p>
<p><img src="/images/LeetCode-%E7%AC%94%E8%AE%B0-1%EF%BC%9ASliding-Window-%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93/Pasted%20image%2020230108165249.png"></p>
<p>思路为：</p>
<ul>
<li>维护一个 <code>Set</code> 来存储出现在滑动窗口中的元素</li>
<li>维护一个滑动窗口，每次迭代的时候检查当前的滑动窗口是否合法，即检查 <code>Set</code> 是否有保存窗口右端点对应的元素；窗口非法则说明当前窗口过大，需要缩小窗口大小</li>
<li>窗口合法时更新结果值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, windowStart = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">windowEnd</span> <span class="operator">=</span> <span class="number">0</span>; windowEnd &lt; s.length(); ++windowEnd) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(windowEnd);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (set.contains(ch)) &#123;</span><br><span class="line">                <span class="keyword">while</span> (set.contains(ch)) &#123;</span><br><span class="line">                    set.remove(s.charAt(windowStart++));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">             set.add(ch);</span><br><span class="line">             res = Math.max(res, windowEnd - windowStart + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="其他典型-Sliding-window-题目"><a href="#其他典型-Sliding-window-题目" class="headerlink" title="其他典型 Sliding window 题目"></a>其他典型 Sliding window 题目</h1><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-repeating-character-replacement/">424. Longest Repeating Character Replacement</a></li>
<li><a href="">643. Maximum Average Subarray I</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-mountain-in-array/">845. Longest Mountain in Array</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-consecutive-ones-iii/">1004. Max Consecutive Ones III</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/grumpy-bookstore-owner/">1052. Grumpy Bookstore Owner</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/">1658. Minimum Operations to Reduce X to Zero</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">caffcen</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">caffcen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
