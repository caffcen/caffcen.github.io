<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://caffcen.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://caffcen.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://caffcen.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https://caffcen.github.io/android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=https://caffcen.github.io/apple-touch-icon.png><meta name=description content><title>LeetCode Sliding Window Problems | Lihang Liu's Homepage</title><link rel=canonical href=https://caffcen.github.io/blog/3_leetcode_sliding_window/><meta property="og:url" content="https://caffcen.github.io/blog/3_leetcode_sliding_window/"><meta property="og:site_name" content="Lihang Liu's Homepage"><meta property="og:title" content="LeetCode Sliding Window Problems"><meta property="og:description" content="Introduction to sliding window pattern"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-11-23T14:24:56-05:00"><meta property="article:modified_time" content="2025-11-23T15:09:33-05:00"><meta property="article:tag" content="Leetcode"><link rel=stylesheet href=/assets/combined.min.57df9e7d692553f966cff4593ede6b53efb74da234876bacffeac774bd572e53.css media=all></head><body class=auto><div class=content><header><div class=header><h1 class=header-title><a href=https://caffcen.github.io/>Lihang Liu's Homepage</a></h1><div class=header-menu><p class=small><a href=/>/Home</a></p><p class=small><a href=/blog/>/Blog</a></p><p class=small><a href=/archive/>/Archive</a></p></div></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a><span class=breadcrumbs-separator>/</span><a href=/blog/>Blog</a><span class=breadcrumbs-separator>/</span>
<a href=/blog/3_leetcode_sliding_window/>LeetCode Sliding Window Problems</a></div><div><article><header class=single-intro-container><h1 class=single-title>LeetCode Sliding Window Problems</h1><p class=single-summary>Introduction to sliding window pattern</p><div class=single-subsummary><div><p class=single-date><time datetime=2025-11-23T14:24:56-05:00>November 23, 2025</time>
&nbsp; · &nbsp;6 min read</p></div></div></header><aside class=toc><p><strong>Table of contents</strong></p><nav id=TableOfContents><ul><li><a href=#problem-description>Problem description</a></li><li><a href=#a-naive-solution>A naive solution</a></li><li><a href=#sliding-window-approach>Sliding window approach</a></li></ul><ul><li><a href=#problem-statement>Problem statement</a></li><li><a href=#solution>Solution</a></li></ul><ul><li><a href=#problem-description-1>Problem description</a></li><li><a href=#solution-1>Solution</a></li></ul></nav></aside><div class=single-content><h1 class=heading id=what-is-the-sliding-window-algorithm>What is the sliding window algorithm?
<a class=anchor href=#what-is-the-sliding-window-algorithm>#</a></h1><p>Let&rsquo;s first demonstrate what is the sliding window approach and why we use it by solving this problem: <a href=https://leetcode.com/problems/minimum-size-subarray-sum/description/>Minimum Size Subarray Sum - LeetCode</a></p><h2 class=heading id=problem-description>Problem description
<a class=anchor href=#problem-description>#</a></h2><p>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return <em>the <strong>minimal length</strong> of a</em> <em>subarray</em> <em>whose sum is greater than or equal to</em> <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> target = 7, nums = [2,3,1,2,4,3]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The subarray [4,3] has the minimal length under the problem constraint.</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> target = 4, nums = [1,4,4]
<strong>Output:</strong> 1</p><p><strong>Example 3:</strong></p><p><strong>Input:</strong> target = 11, nums = [1,1,1,1,1,1,1,1]
<strong>Output:</strong> 0</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= target &lt;= 109</code></li><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li></ul><h2 class=heading id=a-naive-solution>A naive solution
<a class=anchor href=#a-naive-solution>#</a></h2><p>A brute force solution could be trying every possible subarray and calculating the sum of the numbers in the subarray. If the sum is larger than target, we update the <code>minLength</code> if the length of the subarray is less than the current minimum.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=font-weight:700;text-decoration:underline>int</span> minLength = Integer.MAX_VALUE;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span><span style=font-weight:700;text-decoration:underline>for</span> (<span style=font-weight:700;text-decoration:underline>int</span> i = 0; i &lt; nums.length; ++i) {
</span></span><span style=display:flex><span>    <span style=font-weight:700;text-decoration:underline>int</span> sum = 0;
</span></span><span style=display:flex><span>    <span style=font-weight:700;text-decoration:underline>for</span> (<span style=font-weight:700;text-decoration:underline>int</span> j = i; j &lt; nums.length; ++j) {
</span></span><span style=display:flex><span>        sum += nums[j];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (sum &gt; target) {
</span></span><span style=display:flex><span>            minLength = Math.min(minLength, j - i + 1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>break</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The problem is that there are a lot of duplicated calculations due to many subarrays sharing a common overlap.</p><p>If we can somehow memorize the summation for the overlap, we no longer need to calculate the sum of the overlapping area twice.</p><h2 class=heading id=sliding-window-approach>Sliding window approach
<a class=anchor href=#sliding-window-approach>#</a></h2><p>The idea is to use a sliding window to keep track of the subarray we are visiting:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=font-weight:700;font-style:italic;text-decoration:underline>class</span> <span style=color:#666;font-weight:700;font-style:italic>Solution</span> {
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> <span style=font-weight:700;text-decoration:underline>int</span> <span style=color:#666;font-weight:700;font-style:italic>minSubArrayLen</span>(<span style=font-weight:700;text-decoration:underline>int</span> target, <span style=font-weight:700;text-decoration:underline>int</span>[] nums) {
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>int</span> res = Integer.MAX_VALUE, sum = 0, windowStart = 0;
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>for</span> (<span style=font-weight:700;text-decoration:underline>int</span> windowEnd = 0; windowEnd &lt; nums.length; ++windowEnd) {
</span></span><span style=display:flex><span>            sum += nums[windowEnd];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>while</span> (sum &gt;= target) {
</span></span><span style=display:flex><span>                res = Math.min(res, windowEnd - windowStart + 1);
</span></span><span style=display:flex><span>                sum -= nums[windowStart++];
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>return</span> res == Integer.MAX_VALUE ? 0 : res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>Each iteration, we enlarge the window size by incrementing <code>windowEnd</code> by 1, and add the number into <code>sum</code></li><li>If <code>sum > target</code>, which means we have a valid subarray (window), we update <code>res</code> if possible</li><li>If <code>sum > target</code>, the subarray already satisfies the requirement, in order to get the smallest such subarray, we shrink the window size by incrementing the left boundary — <code>windowStart</code></li></ul><p>Compared with the $O(n^2)$ native solution, we achieve $O(n)$ by leveraging the sliding window algorithm, which always keeps track of a valid window that satisfies the requirements.</p><h1 class=heading id=problems-requiring-a-map>Problems requiring a map
<a class=anchor href=#problems-requiring-a-map>#</a></h1><p>A sliding window can be easily integrated with other data structures like a map, to keep track of more sophisticated information within the window. Let&rsquo;s take a look at <a href=https://leetcode.com/problems/permutation-in-string/>567. Permutation in String</a></p><h2 class=heading id=problem-statement>Problem statement
<a class=anchor href=#problem-statement>#</a></h2><p>Given two strings <code>s1</code> and <code>s2</code>, return <code>true</code> if <code>s2</code> contains a permutation of <code>s1</code>, or <code>false</code> otherwise.</p><p>In other words, return <code>true</code> if one of <code>s1</code>&rsquo;s permutations is the substring of <code>s2</code>.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> s1 = &ldquo;ab&rdquo;, s2 = &ldquo;eidbaooo&rdquo;
<strong>Output:</strong> true
<strong>Explanation:</strong> s2 contains one permutation of s1 (&ldquo;ba&rdquo;).</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> s1 = &ldquo;ab&rdquo;, s2 = &ldquo;eidboaoo&rdquo;
<strong>Output:</strong> false</p><p><strong>Constraints:</strong></p><ul><li><code>1 &lt;= s1.length, s2.length &lt;= 104</code></li><li><code>s1</code> and <code>s2</code> consist of lowercase English letters.</li></ul><h2 class=heading id=solution>Solution
<a class=anchor href=#solution>#</a></h2><p>The idea is very similar:</p><ul><li>We keep track of a window by recording the char frequencies in a map.</li><li>Each iteration:<ul><li>Enlarge the current window by moving the <code>windowEnd</code> pointer</li><li>Update the map to reflect the newly-added char</li><li>If all chars from <code>s1</code> are stored in the current window, return <code>true</code></li><li>If the size of our window is larger than <code>s1.length()</code>, then we need to shrink it by incrementing the <code>windowStart</code> pointer and updating the map</li></ul></li><li>If the iteration ends, then <code>s2</code> is not a permutation of <code>s1</code>, return <code>false</code></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=font-weight:700;font-style:italic;text-decoration:underline>class</span> <span style=color:#666;font-weight:700;font-style:italic>Solution</span> {
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> <span style=font-weight:700;text-decoration:underline>boolean</span> <span style=color:#666;font-weight:700;font-style:italic>checkInclusion</span>(String s1, String s2) {
</span></span><span style=display:flex><span>        Map&lt;Character, Integer&gt; charCntMap = <span style=font-weight:700;text-decoration:underline>new</span> HashMap&lt;&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#888;font-style:italic>// init, storing the frequencies of chars in s1 into a map</span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>for</span> (<span style=font-weight:700;text-decoration:underline>char</span> ch : s1.toCharArray()) {
</span></span><span style=display:flex><span>            charCntMap.put(ch, charCntMap.getOrDefault(ch, 0) + 1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>int</span> windowStart = 0, cnt = charCntMap.size();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>for</span> (<span style=font-weight:700;text-decoration:underline>int</span> windowEnd = 0; windowEnd &lt; s2.length(); ++windowEnd) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>char</span> ch = s2.charAt(windowEnd);
</span></span><span style=display:flex><span>            <span style=color:#888;font-style:italic>// update map</span>
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>if</span> (charCntMap.containsKey(ch)) {
</span></span><span style=display:flex><span>                charCntMap.put(ch, charCntMap.get(ch) - 1);
</span></span><span style=display:flex><span>                <span style=font-weight:700;text-decoration:underline>if</span> (charCntMap.get(ch) == 0) {
</span></span><span style=display:flex><span>                    --cnt;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#888;font-style:italic>// the window is larger than s1, shrink the window and update the map</span>
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>if</span> (windowEnd - windowStart + 1 &gt; s1.length()) {
</span></span><span style=display:flex><span>                ch = s2.charAt(windowStart++);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=font-weight:700;text-decoration:underline>if</span> (charCntMap.containsKey(ch)) {
</span></span><span style=display:flex><span>                    charCntMap.put(ch, charCntMap.get(ch) + 1);
</span></span><span style=display:flex><span>                    <span style=font-weight:700;text-decoration:underline>if</span> (charCntMap.get(ch) == 1) {
</span></span><span style=display:flex><span>                        ++cnt;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#888;font-style:italic>// all chars are present in current window, return true</span>
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>if</span> (cnt == 0) {
</span></span><span style=display:flex><span>                <span style=font-weight:700;text-decoration:underline>return</span> <span style=font-weight:700;text-decoration:underline>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>return</span> <span style=font-weight:700;text-decoration:underline>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Similar problems：</p><ul><li><a href=https://leetcode.com/problems/contains-duplicate-ii/>219. Contains Duplicate II</a></li><li><a href=https://leetcode.com/problems/fruit-into-baskets/>904. Fruit Into Baskets</a></li></ul><h1 class=heading id=problems-using-a-set>Problems using a set
<a class=anchor href=#problems-using-a-set>#</a></h1><p>In this problem—<a href=https://leetcode.com/problems/longest-substring-without-repeating-characters/>3. Longest Substring Without Repeating Characters</a>, instead of using a map, a set data structure is utilized to record &ldquo;presences&rdquo; of chars in the sliding window.</p><h2 class=heading id=problem-description-1>Problem description
<a class=anchor href=#problem-description-1>#</a></h2><p>Given a string <code>s</code>, find the length of the <strong>longest</strong> <strong>substring</strong> without duplicate characters.</p><p><strong>Example 1:</strong></p><p><strong>Input:</strong> s = &ldquo;abcabcbb&rdquo;
<strong>Output:</strong> 3
<strong>Explanation:</strong> The answer is &ldquo;abc&rdquo;, with the length of 3. Note that <code>"bca"</code> and <code>"cab"</code> are also correct answers.</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> s = &ldquo;bbbbb&rdquo;
<strong>Output:</strong> 1
<strong>Explanation:</strong> The answer is &ldquo;b&rdquo;, with the length of 1.</p><p><strong>Example 3:</strong></p><p><strong>Input:</strong> s = &ldquo;pwwkew&rdquo;
<strong>Output:</strong> 3
<strong>Explanation:</strong> The answer is &ldquo;wke&rdquo;, with the length of 3.
Notice that the answer must be a substring, &ldquo;pwke&rdquo; is a subsequence and not a substring.</p><p><strong>Constraints:</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> consists of English letters, digits, symbols and spaces.</li></ul><h2 class=heading id=solution-1>Solution
<a class=anchor href=#solution-1>#</a></h2><p>The idea is not too much different from the previous one. Instead of using a map to store char frequencies, in this problem we are only interested in the presence of chars.</p><p>At each iteration:</p><ol><li>We first enlarge the window by 1 as usual.</li><li>If the char denoted by <code>windowEnd</code> is already present in the set, we need to shrink the window until it is valid, i.e., the window contains no duplicated char:<ul><li>To do so, we shrink the window by moving the left boundary until the same char added in a previous iteration is excluded</li></ul></li><li>After the exclusion, we are sure the window meets with the requirement, we then update the maximal length of a valid window we have met.</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=font-weight:700;font-style:italic;text-decoration:underline>class</span> <span style=color:#666;font-weight:700;font-style:italic>Solution</span> {
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> <span style=font-weight:700;text-decoration:underline>int</span> <span style=color:#666;font-weight:700;font-style:italic>lengthOfLongestSubstring</span>(String s) {
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>int</span> res = 0, windowStart = 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Set&lt;Character&gt; set = <span style=font-weight:700;text-decoration:underline>new</span> HashSet&lt;&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>for</span> (<span style=font-weight:700;text-decoration:underline>int</span> windowEnd = 0; windowEnd &lt; s.length(); ++windowEnd) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>char</span> ch = s.charAt(windowEnd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#888;font-style:italic>// shrink the sliding window until it is legal</span>
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>while</span> (set.contains(ch)) {
</span></span><span style=display:flex><span>                set.remove(s.charAt(windowStart++));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>             set.add(ch);
</span></span><span style=display:flex><span>             <span style=color:#888;font-style:italic>// the window is valid now, update res</span>
</span></span><span style=display:flex><span>             res = Math.Max (res, windowEnd - windowStart + 1);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 class=heading id=recap>Recap
<a class=anchor href=#recap>#</a></h1><p>The sliding window algorithm is based on iteration, at each iteration, we:</p><ul><li>First, move the right boundary of the sliding window forward by 1</li><li>Update data, no matter it is the summation of elements in the window, or is the frequencies of chars</li><li>Shrink the window if it is invalid by moving the left boundary until the requirement is met. Update any necessary data during the process.</li></ul><h1 class=heading id=other-sliding-window-leetcode-problems>Other sliding window LeetCode problems
<a class=anchor href=#other-sliding-window-leetcode-problems>#</a></h1><ul><li><a href=https://leetcode.com/problems/longest-repeating-character-replacement/>424. Longest Repeating Character Replacement</a></li><li><a href>643. Maximum Average Subarray I</a></li><li><a href=https://leetcode.com/problems/longest-mountain-in-array/>845. Longest Mountain in Array</a></li><li><a href=https://leetcode.com/problems/max-consecutive-ones-iii/>1004. Max Consecutive Ones III</a></li><li><a href=https://leetcode.com/problems/grumpy-bookstore-owner/>1052. Grumpy Bookstore Owner</a></li><li><a href=https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/>1658. Minimum Operations to Reduce X to Zero</a></li></ul></div></article><div class=single-comments><script src=https://giscus.app/client.js data-repo data-repo-id data-category data-category-id data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><div class=single-pagination><hr><div class=flexnowrap><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text>←</div><div class=single-pagination-text><a href=/blog/2_leetcode_trie/>LeetCode Trie Data Structure & Related Problems</a></div></div></div><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text><a href=/blog/4_leetcode_lca/>LeetCode Lowest Common Ancestor Problems</a></div><div class=single-pagination-text>→</div></div></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>Powered by
<a href=https://gohugo.io/>Hugo</a>
and
<a href=https://github.com/tomfran/typo>tomfran/typo</a></p></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></body><script src=/js/theme-switch.js></script><script defer src=/js/copy-code.js></script></html>