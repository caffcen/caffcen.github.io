<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://caffcen.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://caffcen.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://caffcen.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https://caffcen.github.io/android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=https://caffcen.github.io/apple-touch-icon.png><meta name=description content><title>LeetCode Lowest Common Ancestor Problems | Lihang Liu's Homepage</title><link rel=canonical href=https://caffcen.github.io/blog/4_leetcode_lca/><meta property="og:url" content="https://caffcen.github.io/blog/4_leetcode_lca/"><meta property="og:site_name" content="Lihang Liu's Homepage"><meta property="og:title" content="LeetCode Lowest Common Ancestor Problems"><meta property="og:description" content="Summary of the lowest common ancestor problems"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-11-30T11:49:41-05:00"><meta property="article:modified_time" content="2025-11-30T11:56:32-05:00"><meta property="article:tag" content="Leetcode"><link rel=stylesheet href=/assets/combined.min.57df9e7d692553f966cff4593ede6b53efb74da234876bacffeac774bd572e53.css media=all></head><body class=auto><div class=content><header><div class=header><h1 class=header-title><a href=https://caffcen.github.io/>Lihang Liu's Homepage</a></h1><div class=header-menu><p class=small><a href=/>/Home</a></p><p class=small><a href=/blog/>/Blog</a></p><p class=small><a href=/archive/>/Archive</a></p></div></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a><span class=breadcrumbs-separator>/</span><a href=/blog/>Blog</a><span class=breadcrumbs-separator>/</span>
<a href=/blog/4_leetcode_lca/>LeetCode Lowest Common Ancestor Problems</a></div><div class=autonumber><article><header class=single-intro-container><h1 class=single-title>LeetCode Lowest Common Ancestor Problems</h1><p class=single-summary>Summary of the lowest common ancestor problems</p><div class=single-subsummary><div><p class=single-date><time datetime=2025-11-30T11:49:41-05:00>November 30, 2025</time>
&nbsp; · &nbsp;6 min read</p></div></div></header><aside class=toc><p><strong>Table of contents</strong></p><nav id=TableOfContents><ul><li><a href=#1123-lowest-common-ancestor-of-deepest-leaves>1123. Lowest Common Ancestor of Deepest Leaves</a><ul><li><a href=#solution>Solution</a></li></ul></li><li><a href=#235-lowest-common-ancestor-of-a-binary-search-tree>235. Lowest Common Ancestor of a Binary Search Tree</a></li></ul></nav></aside><div class=single-content><h1 class=heading id=lowest-common-ancestor>Lowest Common Ancestor
<a class=anchor href=#lowest-common-ancestor>#</a></h1><p>From Wikipedia <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor#:~:text=In%20ontologies%2C%20the%20lowest%20common,and%20w%20to%20the%20root.">Lowest common ancestor - Wikipedia</a> page:</p><blockquote><p>In <a href=https://en.wikipedia.org/wiki/Graph_theory title="Graph theory">graph theory</a> and <a href=https://en.wikipedia.org/wiki/Computer_science title="Computer science">computer science</a>, the <strong>lowest common ancestor</strong> (<strong>LCA</strong>) (also called least common ancestor) of two nodes v and w in a [tree]( <a href=https://en.wikipedia.org/wiki/Tree>https://en.wikipedia.org/wiki/Tree</a>_ (graph_theory) &ldquo;Tree (graph theory)") or <a href=https://en.wikipedia.org/wiki/Directed_acyclic_graph title="Directed acyclic graph">directed acyclic graph</a> (DAG) T is the lowest (i.e. deepest) node that has both v and w as descendants, where we define each node to be a descendant of itself (so if v has a direct connection from w, w is the lowest common ancestor).</p></blockquote><p>The definition is simple. Let&rsquo;s see some examples:</p><p><figure><div class=img-container style=--w:1048;--h:798><img loading=lazy alt src=/blog/4_leetcode_lca/1.png width=1048 height=798></div></figure></p><ul><li>The LCA of A and B is A;</li><li>The LCA of B and C is A;</li><li>The LCA of D and E is A;</li><li>The LCA of E and I is C;</li><li>The LCA of D and F is A;</li><li>The LCA of G and H is D;</li><li>The LCA of C and F is C;</li></ul><h1 class=heading id=how-to-find-the-lca-of-two-nodes-in-a-tree>How to find the LCA of two nodes in a tree?
<a class=anchor href=#how-to-find-the-lca-of-two-nodes-in-a-tree>#</a></h1><p>Almost all binary tree problems use a recursive algorithm, this is due to the local structure property of the tree data structure: each node only stores its local information, we cannot access global tree data from any single node.</p><p>So, at each node, we process the &ldquo;current&rdquo; data and node locally, and return it to its parent via the recursive calls: when the recursive function call returns to the parent, local information is passed and kept. Thus we can construct the final and global results by recursively processing and passing information.</p><p>The idea to get the LCA of any two nodes, say <code>A</code> and <code>B</code>, also applies the recursive method:</p><ul><li>Starting from the bottom up, if the current node is either <code>A</code> or <code>B</code>, return the node itself to its parent where the recursion starts. If the current node is neither one, return a <code>null</code>.</li><li>When two recursive calls return from the left and right child, the parent can determine whether it is the LCA by checking whether the returns are <code>null</code> or not:<ul><li>If both returns are not <code>null</code>, the parent node can infer that it is actually the LCA of <code>A</code> and <code>B</code></li><li>If one is <code>null</code> and the other is not, the parent can tell that the non-<code>null</code> node returned is either the LCA or one of the target nodes, it can safely return the non- <code>null</code> node</li><li>If both are <code>null</code>, the parent know that the subtree starting at it does not hold <code>A</code> and <code>B</code>, it can simply returns <code>null</code></li></ul></li></ul><p>For any given node <code>A</code> and <code>B</code>, their <code>LCA</code> is:</p><ul><li><strong>Case 1</strong>: A parent node exists above.</li><li><strong>Case 2</strong>: <code>A</code> or <code>B</code> itself, which means one of the target is the ancestor of the other one.</li></ul><p>Which means during our recursive call, both of the returns are not null can happen at most one time (for case 1). In such a case, the current node must be the <code>LCA</code>.</p><p>For case 2, the base case check in the recursive algorithm can safely return the <code>LCA</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=font-weight:700;font-style:italic;text-decoration:underline>class</span> <span style=color:#666;font-weight:700;font-style:italic>Solution</span> {
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> TreeNode <span style=color:#666;font-weight:700;font-style:italic>lowestCommonAncestor</span>(TreeNode root, TreeNode p, TreeNode q) {
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (root == <span style=font-weight:700;text-decoration:underline>null</span>) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> <span style=font-weight:700;text-decoration:underline>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (root == p || root == q) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> root;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        TreeNode left = lowestCommonAncestor(root.left, p, q);
</span></span><span style=display:flex><span>        TreeNode right = lowestCommonAncestor(root.right, p, q);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (left != <span style=font-weight:700;text-decoration:underline>null</span> &amp;&amp; right != <span style=font-weight:700;text-decoration:underline>null</span>) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> root;
</span></span><span style=display:flex><span>        } <span style=font-weight:700;text-decoration:underline>else</span> <span style=font-weight:700;text-decoration:underline>if</span> (left != <span style=font-weight:700;text-decoration:underline>null</span>) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> left;
</span></span><span style=display:flex><span>        } <span style=font-weight:700;text-decoration:underline>else</span> {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> right;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 class=heading id=sample-problems>Sample problems
<a class=anchor href=#sample-problems>#</a></h1><h2 class=heading id=1123-lowest-common-ancestor-of-deepest-leaves><a href=https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/>1123. Lowest Common Ancestor of Deepest Leaves</a>
<a class=anchor href=#1123-lowest-common-ancestor-of-deepest-leaves>#</a></h2><p>Given the <code>root</code> of a binary tree, return <em>the lowest common ancestor of its deepest leaves</em>.</p><p>Recall that:</p><ul><li>The node of a binary tree is a leaf if and only if it has no children</li><li>The depth of the root of the tree is <code>0</code>. if the depth of a node is <code>d</code>, the depth of each of its children is <code>d + 1</code>.</li><li>The lowest common ancestor of a set <code>S</code> of nodes, is the node <code>A</code> with the largest depth such that every node in <code>S</code> is in the subtree with root <code>A</code>.</li></ul><p><strong>Example 1:</strong></p><p>![[2.png]]</p><p><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4]
<strong>Output:</strong> [2,7,4]
<strong>Explanation:</strong> We return the node with value 2, colored in yellow in the diagram.
The nodes coloured in blue are the deepest leaf-nodes of the tree.
Note that nodes 6, 0, and 8 are also leaf nodes, but the depth of them is 2, but the depth of nodes 7 and 4 is 3.</p><p><strong>Example 2:</strong></p><p><strong>Input:</strong> root = [1]
<strong>Output:</strong> [1]
<strong>Explanation:</strong> The root is the deepest node in the tree, and it&rsquo;s the lca of itself.</p><p><strong>Example 3:</strong></p><p><strong>Input:</strong> root = [0,1,3,null,2]
<strong>Output:</strong> [2]
<strong>Explanation:</strong> The deepest leaf node in the tree is 2, the lca of one node is itself.</p><h3 class=heading id=solution>Solution
<a class=anchor href=#solution>#</a></h3><p>To solve the problem, we need two separate steps:</p><ol><li>Find the deepest leaves;</li><li>Return their <code>LCA</code></li></ol><p>Multiple (more than 2) deepest leaves can exist at the same time, our algorithm still holds because:</p><ol><li>For the deepest node, it returns itself.</li><li>For any internal node, it still checks the returns from its children:<ol><li>If both the returns are <code>null</code> -> the subtree starting at it does not hold any deepest node;</li><li>If any of the return is not <code>null</code> -> the return is <code>LCA</code></li><li>If both of the return is not <code>null</code> -> the current internal node is the <code>LCA</code></li></ol></li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=font-weight:700;font-style:italic;text-decoration:underline>class</span> <span style=color:#666;font-weight:700;font-style:italic>Solution</span> {
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>private</span> <span style=font-weight:700;text-decoration:underline>int</span> deepestDepth = 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> TreeNode <span style=color:#666;font-weight:700;font-style:italic>lcaDeepestLeaves</span>(TreeNode root) {
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (root.left == <span style=font-weight:700;text-decoration:underline>null</span> &amp;&amp; root.right == <span style=font-weight:700;text-decoration:underline>null</span>) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> root;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        findDeepestDepth(root, 0);
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>return</span> lca(root, 0);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>private</span> TreeNode <span style=color:#666;font-weight:700;font-style:italic>lca</span>(TreeNode root, <span style=font-weight:700;text-decoration:underline>int</span> depth) {
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (root == <span style=font-weight:700;text-decoration:underline>null</span>) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> <span style=font-weight:700;text-decoration:underline>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        TreeNode leftRet = lca(root.left, depth + 1);
</span></span><span style=display:flex><span>        TreeNode rightRet = lca(root.right, depth + 1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (depth == deepestDepth) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> root;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (leftRet != <span style=font-weight:700;text-decoration:underline>null</span> &amp;&amp; rightRet != <span style=font-weight:700;text-decoration:underline>null</span>) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> root;
</span></span><span style=display:flex><span>        } <span style=font-weight:700;text-decoration:underline>else</span> <span style=font-weight:700;text-decoration:underline>if</span> (leftRet != <span style=font-weight:700;text-decoration:underline>null</span>) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> leftRet;
</span></span><span style=display:flex><span>        } <span style=font-weight:700;text-decoration:underline>else</span> {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> rightRet;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>private</span> <span style=font-weight:700;text-decoration:underline>void</span> <span style=color:#666;font-weight:700;font-style:italic>findDeepestDepth</span>(TreeNode root, <span style=font-weight:700;text-decoration:underline>int</span> depth) {
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (root == <span style=font-weight:700;text-decoration:underline>null</span>) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        deepestDepth = Math.max(deepestDepth, depth);
</span></span><span style=display:flex><span>        findDeepestDepth(root.left, depth + 1);
</span></span><span style=display:flex><span>        findDeepestDepth(root.right, depth + 1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 class=heading id=235-lowest-common-ancestor-of-a-binary-search-tree><a href=https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/>235. Lowest Common Ancestor of a Binary Search Tree</a>
<a class=anchor href=#235-lowest-common-ancestor-of-a-binary-search-tree>#</a></h2><p><figure><div class=img-container style=--w:1020;--h:962><img loading=lazy alt src=/blog/4_leetcode_lca/3.png width=1020 height=962></div></figure></p><p>The difference is that we switch to binary search tree. It has the following property:</p><p><strong>For any given node <code>A</code> and <code>B</code>, their <code>LCA</code> must obeys <code>A.val &lt;= LCA.val && LCA.val &lt;= B.val</code> if <code>A.val &lt;= B.val</code>.</strong></p><p>So, during recursive calls, we do not check the nullity of returns anymore. For this problem, we check whether the internal node satisfies the boolean statement mentioned above:</p><ul><li>If <code>curr.val &lt; A.val && curr.val &lt; B.val</code>, then the current node&rsquo;s value is too small, we need to find the LCA from its right subtree;</li><li>If <code>curr.val > A.val && curr.val > B.val</code>, then the <code>curr.val</code> is too large, we search the <code>LCA</code> from its left subtree</li><li>If <code>curr.val > A.val && curr.val &lt; B.val</code>, the curr node must be the LCA</li></ul><p>Then algorithm works as follows:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=font-weight:700;font-style:italic;text-decoration:underline>class</span> <span style=color:#666;font-weight:700;font-style:italic>Solution</span> {
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> TreeNode <span style=color:#666;font-weight:700;font-style:italic>lowestCommonAncestor</span>(TreeNode root, TreeNode p, TreeNode q) {
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> lowestCommonAncestor(root.left, p, q);
</span></span><span style=display:flex><span>        } <span style=font-weight:700;text-decoration:underline>else</span> <span style=font-weight:700;text-decoration:underline>if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> lowestCommonAncestor(root.right, p, q);
</span></span><span style=display:flex><span>        } <span style=font-weight:700;text-decoration:underline>else</span> {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> root;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 class=heading id=other-lca-problems>Other LCA problems
<a class=anchor href=#other-lca-problems>#</a></h1><ol><li><a href=https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/>235. Lowest Common Ancestor of a Binary Search Tree</a></li><li><a href=https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/>236. Lowest Common Ancestor of a Binary Tree</a></li><li><a href=https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/>865. Smallest Subtree with all the Deepest Nodes</a></li><li><a href=https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/>1123. Lowest Common Ancestor of Deepest Leaves</a></li></ol></div></article><div class=single-comments><script src=https://giscus.app/client.js data-repo data-repo-id data-category data-category-id data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><div class=single-pagination><hr><div class=flexnowrap><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text>←</div><div class=single-pagination-text><a href=/blog/3_leetcode_sliding_window/>LeetCode Sliding Window Problems</a></div></div></div><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text><a href=/blog/5_leetcode_construct_bst_from_xxx_traversal/>Construct Binary Tree From inorder/preorder/postorder Traversal</a></div><div class=single-pagination-text>→</div></div></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>Powered by
<a href=https://gohugo.io/>Hugo</a>
and
<a href=https://github.com/tomfran/typo>tomfran/typo</a></p></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></body><script src=/js/theme-switch.js></script><script defer src=/js/copy-code.js></script></html>