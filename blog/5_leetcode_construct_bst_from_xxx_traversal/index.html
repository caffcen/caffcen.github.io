<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://caffcen.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://caffcen.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://caffcen.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https://caffcen.github.io/android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=https://caffcen.github.io/apple-touch-icon.png><meta name=description content><title>Construct Binary Tree From inorder/preorder/postorder Traversal | Lihang Liu's Homepage</title><link rel=canonical href=https://caffcen.github.io/blog/5_leetcode_construct_bst_from_xxx_traversal/><meta property="og:url" content="https://caffcen.github.io/blog/5_leetcode_construct_bst_from_xxx_traversal/"><meta property="og:site_name" content="Lihang Liu's Homepage"><meta property="og:title" content="Construct Binary Tree From inorder/preorder/postorder Traversal"><meta property="og:description" content="This post analyzes how to construct a bst from its preorder/postorder/inorder traversals"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-12-07T12:10:06-05:00"><meta property="article:modified_time" content="2025-12-30T15:37:09-05:00"><meta property="article:tag" content="Leetcode"><link rel=stylesheet href=/assets/combined.min.57df9e7d692553f966cff4593ede6b53efb74da234876bacffeac774bd572e53.css media=all></head><body class=auto><div class=content><header><div class=header><h1 class=header-title><a href=https://caffcen.github.io/>Lihang Liu's Homepage</a></h1><div class=header-menu><p class=small><a href=/>/Home</a></p><p class=small><a href=/blog/>/Blog</a></p><p class=small><a href=/archive/>/Archive</a></p></div></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a><span class=breadcrumbs-separator>/</span><a href=/blog/>Blog</a><span class=breadcrumbs-separator>/</span>
<a href=/blog/5_leetcode_construct_bst_from_xxx_traversal/>Construct Binary Tree From inorder/preorder/postorder Traversal</a></div><div class=autonumber><article><header class=single-intro-container><h1 class=single-title>Construct Binary Tree From inorder/preorder/postorder Traversal</h1><p class=single-summary>This post analyzes how to construct a bst from its preorder/postorder/inorder traversals</p><div class=single-subsummary><div><p class=single-date><time datetime=2025-12-07T12:10:06-05:00>December 7, 2025</time>
&nbsp; · &nbsp;8 min read</p></div></div></header><aside class=toc><p><strong>Table of contents</strong></p><nav id=TableOfContents></nav></aside><div class=single-content><p>Can we construct a BST from any 2 of its preorder/postorder/inorder traversals (actually, traversal sequences)? The answer is yes. In order to understand why we can do so, we need to have a deep understanding of the properties not only of BST but also of its traversals.</p><p>We briefly recap the BST data structure first:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=font-weight:700;font-style:italic;text-decoration:underline>class</span> <span style=color:#666;font-weight:700;font-style:italic>TreeNode</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700;text-decoration:underline>int</span> val;  
</span></span><span style=display:flex><span>    TreeNode left;  
</span></span><span style=display:flex><span>    TreeNode right;  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TreeNode() {  
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TreeNode(<span style=font-weight:700;text-decoration:underline>int</span> val) {  
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>this</span>.val = val;  
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TreeNode(<span style=font-weight:700;text-decoration:underline>int</span> val, TreeNode left, TreeNode right) {  
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>this</span>.val = val;  
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>this</span>.left = left;  
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>this</span>.right = right;  
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> <span style=font-weight:700;font-style:italic;text-decoration:underline>static</span> <span style=font-weight:700;text-decoration:underline>void</span> <span style=color:#666;font-weight:700;font-style:italic>preorder</span>(TreeNode root, List&lt;Integer&gt; list) {  
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (root == <span style=font-weight:700;text-decoration:underline>null</span>) {  
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span>;  
</span></span><span style=display:flex><span>        }  
</span></span><span style=display:flex><span>        list.add(root.val);  
</span></span><span style=display:flex><span>        preorder(root.left, list);  
</span></span><span style=display:flex><span>        preorder(root.right, list);  
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> <span style=font-weight:700;font-style:italic;text-decoration:underline>static</span> <span style=font-weight:700;text-decoration:underline>void</span> <span style=color:#666;font-weight:700;font-style:italic>postorder</span>(TreeNode root, List&lt;Integer&gt; list) {  
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (root == <span style=font-weight:700;text-decoration:underline>null</span>) {  
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span>;  
</span></span><span style=display:flex><span>        }  
</span></span><span style=display:flex><span>        postorder(root.left, list);  
</span></span><span style=display:flex><span>        postorder(root.right, list);  
</span></span><span style=display:flex><span>        list.add(root.val);  
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> <span style=font-weight:700;font-style:italic;text-decoration:underline>static</span> <span style=font-weight:700;text-decoration:underline>void</span> <span style=color:#666;font-weight:700;font-style:italic>inorder</span>(TreeNode root, List&lt;Integer&gt; list) {  
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (root == <span style=font-weight:700;text-decoration:underline>null</span>) {  
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span>;  
</span></span><span style=display:flex><span>        }  
</span></span><span style=display:flex><span>        inorder(root.left, list);  
</span></span><span style=display:flex><span>        list.add(root.val);  
</span></span><span style=display:flex><span>        inorder(root.right, list);  
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=table-outer><table><thead><tr><th></th><th><code>inorder</code></th><th><code>preorder</code></th><th><code>postorder</code></th></tr></thead><tbody><tr><td>Node Traversal Order</td><td><code>root.left</code> -> <code>root</code> -> <code>root.right</code></td><td><code>root -> root. left -> root.right</code></td><td><code>root.left -> root.right -> root</code></td></tr><tr><td>The position of subroot within subsequence (where subsequence refers to the sequence obtained by traversing the subtree rooted at subroot)</td><td>Can not be determined solely by <code>inorder</code></td><td><code>subseq[0]</code></td><td><code>subseq[sublist.length - 1]</code></td></tr><tr><td>Properties</td><td></td><td>According to the nature of preorder traversal, the next element in the current subtree sequence after the subroot must be <code>subroot.left</code> (if it exists).That is: <code>subroot.left = subseq[1]</code></td><td>According to the nature of postorder traversal, the element right before the <code>subroot</code> in the current subtree sequence must be <code>subroot.right</code> (if it exists).That is: <code>subroot.right = subseq[subseq.length - 2]</code></td></tr><tr><td>Subsequence Structure</td><td><code>[left subtree sequence] [subroot] [right subtree sequence]</code></td><td><code>[subroot] [left subtree sequence] [right subtree sequence]</code></td><td><code>[left subtree sequence] [right subtree sequence] [subroot]</code></td></tr></tbody></table></div><p>We can easily get the <code>subroot</code> from <code>preorder</code> and <code>postorder</code> traversal subsequences, since the <code>subroot</code> must be positioned at the first and the last index, which can be inferred from the properties of <code>preorder</code> and <code>postorder</code> recursive calls.</p><p>But we cannot infer the position of the <code>subroot</code> solely from the <code>inorder</code> sequence: the position of the <code>subroot</code> seems to be arbitrary. But, if we can tell the position of the <code>subroot</code> from <code>preorder</code> or <code>postorder</code> sequences, we can determine the range of <code>subroot.left</code> and <code>subroot.right</code> by:</p><ol><li>Find the position of the <code>subroot</code> in the <code>inorder</code> sequence</li><li>According to the property of <code>inorder</code> traversal, all elements that appear before the <code>subroot</code> are its left children, all elements that follow the <code>subroot</code> are its right children</li></ol><p>As mentioned in my previous blog <a href=https://caffcen.github.io/blog/4_leetcode_lca/>LeetCode Lowest Common Ancestor Problems | Lihang Liu&rsquo;s Homepage</a>, almost all binary tree problems are solved in recursion. If we are given <code>inorder</code> traversal sequence of a BST + one of its <code>postorder</code> or <code>preorder</code> traversal sequence, we can rebuild the BST by recursively finding the <code>subroot</code> and partitioning its left children and right children.</p><p>Let&rsquo;s see the problems.</p><h1 class=heading id=105-construct-binary-tree-from-preorder-and-inorder-traversal><a href=https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/>105. Construct Binary Tree from Preorder and Inorder Traversal</a>
<a class=anchor href=#105-construct-binary-tree-from-preorder-and-inorder-traversal>#</a></h1><p><figure><div class=img-container style=--w:1020;--h:773><img loading=lazy alt src=/blog/5_leetcode_construct_bst_from_xxx_traversal/1.png width=1020 height=773></div></figure></p><p>Let&rsquo;s first clarify the variables we&rsquo;re going to use:</p><ul><li><code>rootPreIndex</code>: The index of the <code>subroot</code> in the <code>preorder</code> sequence</li><li><code>rootInorderIndex</code>: The index of the <code>subroot</code> in the <code>inorder</code> sequence</li><li><code>inorderLeft</code> and <code>inorderRight</code>: refer to the recursion range for the subtree, i.e., <code>inorder[inorderLeft : inorderRight]</code> is the <code>inorder</code> sequence of the subtree. It is also used to control our recursive functions</li><li>The length (size) of the left subtree: <code>leftSubtreeSize = rootInorderIndex - inorderLeft</code></li></ul><p>The algorithm works as follows:</p><ol><li>We recursively built the BST using this <code>TreeNode build(int[] preorder, int[] inorder, int rootPreIndex, int inorderLeft, int inorderRight)</code> function</li><li>Find the <code>subroot</code> from the <code>preorder</code> subarr, the <code>subroot</code> is always the first element in <code>preorder</code> subarr, call the constructor to instantiate the <code>subroot</code> node</li><li>Determines the index of <code>subroot</code>, i.e. <code>rootInorderIndex</code>, in <code>inorder</code> subarr</li><li>Recursively built the left subtree:<ul><li>The index of <code>subroot.left</code> in the <code>preorder</code> is <code>rootPreIndex + 1</code></li><li>The <code>inorderLeft</code> for the left subtree is the current <code>inorderLeft</code></li><li>The <code>inorderRight</code> for the right subtree is <code>rootInorderIndex - 1</code></li><li>Call <code>build(preorder, inorder, rootPreIndex + 1, inorderLeft, rootInorderIndex - 1)</code></li></ul></li><li>Recursively built the right subtree:<ul><li>The index of <code>subroot.right</code> in the <code>preorder</code> is <code>rootInorderIndex + leftSubtreeSize + 1</code></li><li>The <code>inorderLeft</code> for the right subtree is <code>rootInorderIndex + 1</code></li><li>The <code>inorderRight</code> for the right subtree is <code>inorderRight</code></li><li>Recursively build right subtree by calling <code>build(preorder, inorder, rootPreIndex + leftSubTreeSize + 1, rootInorderIndex + 1, inorderRight)</code></li></ul></li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=font-weight:700;font-style:italic;text-decoration:underline>class</span> <span style=color:#666;font-weight:700;font-style:italic>Solution</span> {
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> TreeNode <span style=color:#666;font-weight:700;font-style:italic>buildTree</span>(<span style=font-weight:700;text-decoration:underline>int</span>[] preorder, <span style=font-weight:700;text-decoration:underline>int</span>[] inorder) {
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>return</span> build(preorder, inorder, 0, 0, inorder.length - 1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> TreeNode <span style=color:#666;font-weight:700;font-style:italic>build</span>(<span style=font-weight:700;text-decoration:underline>int</span>[] preorder, <span style=font-weight:700;text-decoration:underline>int</span>[] inorder, <span style=font-weight:700;text-decoration:underline>int</span> rootPreIndex, <span style=font-weight:700;text-decoration:underline>int</span> inorderLeft, <span style=font-weight:700;text-decoration:underline>int</span> inorderRight) {
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (inorderLeft &gt; inorderRight || rootPreIndex &lt; 0 || rootPreIndex &gt;= preorder.length) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> <span style=font-weight:700;text-decoration:underline>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        TreeNode root = <span style=font-weight:700;text-decoration:underline>new</span> TreeNode(preorder[rootPreIndex]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>int</span> rootInorderIndex = -1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>for</span> (<span style=font-weight:700;text-decoration:underline>int</span> i = 0; i &lt; inorder.length; ++i) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>if</span> (inorder[i] == root.val) {
</span></span><span style=display:flex><span>                rootInorderIndex = i;
</span></span><span style=display:flex><span>                <span style=font-weight:700;text-decoration:underline>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>int</span> leftSubTreeSize = rootInorderIndex - inorderLeft;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        root.left = build(preorder, inorder, rootPreIndex + 1, inorderLeft, rootInorderIndex - 1);
</span></span><span style=display:flex><span>        root.right = build(preorder, inorder, rootPreIndex + leftSubTreeSize + 1, rootInorderIndex + 1, inorderRight);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>return</span> root;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 class=heading id=106-construct-binary-tree-from-inorder-and-postorder-traversal><a href=https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/>106. Construct Binary Tree from Inorder and Postorder Traversal</a>
<a class=anchor href=#106-construct-binary-tree-from-inorder-and-postorder-traversal>#</a></h1><p>This problem does not differ a lot from <a href=https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/>105. Construct Binary Tree from Preorder and Inorder Traversal</a> we have covered. So I just leave my solution here:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=font-weight:700;font-style:italic;text-decoration:underline>class</span> <span style=color:#666;font-weight:700;font-style:italic>Solution</span> {
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> TreeNode <span style=color:#666;font-weight:700;font-style:italic>buildTree</span>(<span style=font-weight:700;text-decoration:underline>int</span>[] inorder, <span style=font-weight:700;text-decoration:underline>int</span>[] postorder) {
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>return</span> build(inorder, postorder, postorder.length - 1, 0, inorder.length - 1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> TreeNode <span style=color:#666;font-weight:700;font-style:italic>build</span>(<span style=font-weight:700;text-decoration:underline>int</span>[] inorder, <span style=font-weight:700;text-decoration:underline>int</span>[] postorder, <span style=font-weight:700;text-decoration:underline>int</span> rootPostIndex, <span style=font-weight:700;text-decoration:underline>int</span> inorderLeft, <span style=font-weight:700;text-decoration:underline>int</span> inorderRight) {
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (inorderLeft &gt; inorderRight || rootPostIndex &lt; 0 || rootPostIndex &gt;= postorder.length) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> <span style=font-weight:700;text-decoration:underline>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        TreeNode root = <span style=font-weight:700;text-decoration:underline>new</span> TreeNode(postorder[rootPostIndex]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>int</span> rootInorderIndex = -1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>for</span> (<span style=font-weight:700;text-decoration:underline>int</span> i = 0; i &lt; inorder.length; ++i) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>if</span> (inorder[i] == root.val) {
</span></span><span style=display:flex><span>                rootInorderIndex = i;
</span></span><span style=display:flex><span>                <span style=font-weight:700;text-decoration:underline>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>int</span> rightSubTreeLen = inorderRight - rootInorderIndex;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        root.left = build(inorder, postorder, rootPostIndex - rightSubTreeLen - 1, inorderLeft, rootInorderIndex - 1);
</span></span><span style=display:flex><span>        root.right = build(inorder, postorder, rootPostIndex - 1, rootInorderIndex + 1, inorderRight);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>return</span> root;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 class=heading id=889-construct-binary-tree-from-preorder-and-postorder-traversal><a href=https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/>889. Construct Binary Tree from Preorder and Postorder Traversal</a>
<a class=anchor href=#889-construct-binary-tree-from-preorder-and-postorder-traversal>#</a></h1><p><figure><div class=img-container style=--w:1020;--h:781><img loading=lazy alt src=/blog/5_leetcode_construct_bst_from_xxx_traversal/2.png width=1020 height=781></div></figure></p><p>This problem is a little bit different from the previous two, we no longer have an <code>inorder</code> sequence to determine the left and right subtrees.</p><p>But, from the properties of <code>postorder</code> and <code>preorder</code>, we can still infer the ranges for both <code>subroot.left</code> and <code>subroot.right</code> subtress in the <code>preorder</code> and <code>postorder</code>. Take the example shown in the problem:</p><ul><li>The <code>root</code> is 1, it is the first element in <code>preorder</code> and the last element in <code>postorder</code></li><li><code>root.left</code> is 2, which is right after <code>root</code> in <code>preorder</code>, and right before <code>root</code> in <code>postorder</code><ul><li>From here, we can do a linear scan to find the index of <code>root.left</code> in the <code>postorder</code> subsequence. Note that the index for <code>root.left</code> in the left subtree is denoted as <code>leftSubRootPostIndex</code></li><li>After obtaining the position of <code>root.left</code> in <code>postorder</code>, we can calculate the length of the left subtree using: <code>leftSubtreeLength = leftSubRootPostIndex - postLeft + 1</code></li><li>In the example, <code>root.left</code> is 2, and its index in <code>postorder</code> is <code>2</code>, so the length of the left subtree is <code>2 - 0 + 1 = 3</code></li></ul></li><li>After obtaining the length of the left subtree, we can calculate the range of the left and right subtree in <code>preorder</code> and <code>postorder</code>:</li><li>For the left subtree:<ul><li>The <code>preorder</code> starts at <code>rootPreIndex + 1</code>, ends at <code>rootPreIndex + leftSubtreeLength</code> (ps, in the code, <code>rootPreIndex</code> is named <code>preLeft</code>)</li><li>The <code>postorder</code> starts at <code>postLeft</code>, ends at <code>postLeft + leftSubtreeLength - 1</code>, this can be inferred from the properties of post-order traversal</li></ul></li><li>For the right subtree:<ul><li>The <code>preorder</code> starts at <code>preLeft + leftSubtreeLength + 1</code>, ends at <code>preRight</code></li><li>The <code>postorder</code> starts at <code>postLeft + leftSubtreeLength</code> ends at <code>postRight - 1</code></li></ul></li></ul><p>As you can see, we can infer the ranges for the subtrees by combining the information obtained from both traversals:</p><ul><li>From the <code>preorder</code>, we know <code>root</code> is <code>preorder[0]</code>, <code>root.left</code> is <code>preorder[1]</code></li><li>Once we know <code>root.left</code>, we can do a linear scan to find its index in <code>postorder</code></li><li>Once we know the index of <code>root.left</code> in <code>postorder</code>, we can calculate the length of the left subtree</li><li>Once we know the length of the left subtree, the length of the right subtree, plus the starting and ending index for <code>preorder</code> and <code>postorder</code> for the recursive calls, can be calculated</li></ul><p>Can we build the solution using the length of the right subtree? Of course we can. Since <code>root.right</code> appears right before the <code>root</code> in <code>postorder</code>, we can do a linear scan to find its index in <code>preorder</code>, then we can calculate the length of the right subtree. The implementation is different, but the idea is similar.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=font-weight:700;font-style:italic;text-decoration:underline>class</span> <span style=color:#666;font-weight:700;font-style:italic>Solution</span> {
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> TreeNode <span style=color:#666;font-weight:700;font-style:italic>constructFromPrePost</span>(<span style=font-weight:700;text-decoration:underline>int</span>[] preorder, <span style=font-weight:700;text-decoration:underline>int</span>[] postorder) {
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>return</span> build(preorder, postorder, 0, preorder.length - 1, 0, postorder.length - 1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>private</span> TreeNode <span style=color:#666;font-weight:700;font-style:italic>build</span>(<span style=font-weight:700;text-decoration:underline>int</span>[] pre, <span style=font-weight:700;text-decoration:underline>int</span>[] post, <span style=font-weight:700;text-decoration:underline>int</span> preLeft, <span style=font-weight:700;text-decoration:underline>int</span> preRight, <span style=font-weight:700;text-decoration:underline>int</span> postLeft, <span style=font-weight:700;text-decoration:underline>int</span> postRight) {
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (preLeft &gt; preRight) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> <span style=font-weight:700;text-decoration:underline>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        TreeNode root = <span style=font-weight:700;text-decoration:underline>new</span> TreeNode(pre[preLeft]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (preLeft + 1 &gt; preRight) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> root;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>int</span> leftSubRootPostIndex;
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>for</span> (leftSubRootPostIndex = postLeft; leftSubRootPostIndex &lt;= postRight; ++leftSubRootPostIndex) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>if</span> (post[leftSubRootPostIndex] == pre[preLeft + 1]) {
</span></span><span style=display:flex><span>                <span style=font-weight:700;text-decoration:underline>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>int</span> leftSubtreeLength = leftSubRootPostIndex - postLeft + 1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        root.left = build(pre, post, preLeft + 1, preLeft + leftSubtreeLength, postLeft, postLeft + leftSubtreeLength - 1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        root.right = build(pre, post, preLeft + leftSubtreeLength + 1, preRight, postLeft + leftSubtreeLength, postRight - 1);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>return</span> root;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 class=heading id=recap>Recap
<a class=anchor href=#recap>#</a></h1><p>Given two sequences from inorder/preorder/postorder traversals of a binary tree, we can rebuild the binary tree by combining information from both traversals.</p><p>We can first determine the index of the <code>root</code> in both traversals. From there, given the properties of inorder/preorder/postorder traversals, we can easily tell the index for <code>root.left</code> or <code>root.right</code>. Then we can determine the length or the range for the left and right subtrees. Once we inferred the ranges, we can rebuild the original binary tree using recursive function calls.</p><h1 class=heading id=leetcode-problems>LeetCode Problems
<a class=anchor href=#leetcode-problems>#</a></h1><ul><li><a href=https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/>105. Construct Binary Tree from Preorder and Inorder Traversal</a></li><li><a href=https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/>106. Construct Binary Tree from Inorder and Postorder Traversal</a></li><li><a href=https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/>889. Construct Binary Tree from Preorder and Postorder Traversal</a></li><li><a href=https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/>1008. Construct Binary Search Tree from Preorder Traversal</a></li></ul></div></article><div class=single-comments><script src=https://giscus.app/client.js data-repo data-repo-id data-category data-category-id data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><div class=single-pagination><hr><div class=flexnowrap><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text>←</div><div class=single-pagination-text><a href=/blog/4_leetcode_lca/>LeetCode Lowest Common Ancestor Problems</a></div></div></div><div class=single-pagination-next></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>Powered by
<a href=https://gohugo.io/>Hugo</a>
and
<a href=https://github.com/tomfran/typo>tomfran/typo</a></p></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></body><script src=/js/theme-switch.js></script><script defer src=/js/copy-code.js></script></html>