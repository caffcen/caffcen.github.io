<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>AbstractQueuedSynchronizer 简介 | Lihang Liu&#39;s Homepage</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="本文主要介绍了 JUC 中的 AbstractQueuedSynchronizer 的实现基础、其和 CLH 队列锁之间的关联、独占锁模式及共享锁模式加解锁的过程等。不包含 ConditionObject 的分析。
简介 AQS 提供了实现同步阻塞队列的基本框架，是 juc 包中其他众多同步原语和锁实现的基础。
Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released.">
    <meta name="generator" content="Hugo 0.125.7">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="https://caffcen.github.io/archive/13_aqs_intro/">
    

    <meta property="og:url" content="https://caffcen.github.io/archive/13_aqs_intro/">
  <meta property="og:site_name" content="Lihang Liu&#39;s Homepage">
  <meta property="og:title" content="AbstractQueuedSynchronizer 简介">
  <meta property="og:description" content="本文主要介绍了 JUC 中的 AbstractQueuedSynchronizer 的实现基础、其和 CLH 队列锁之间的关联、独占锁模式及共享锁模式加解锁的过程等。不包含 ConditionObject 的分析。
简介 AQS 提供了实现同步阻塞队列的基本框架，是 juc 包中其他众多同步原语和锁实现的基础。
Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="archive">
    <meta property="article:published_time" content="2023-05-21T16:04:33+08:00">
    <meta property="article:modified_time" content="2023-05-21T16:04:33+08:00">

  <meta itemprop="name" content="AbstractQueuedSynchronizer 简介">
  <meta itemprop="description" content="本文主要介绍了 JUC 中的 AbstractQueuedSynchronizer 的实现基础、其和 CLH 队列锁之间的关联、独占锁模式及共享锁模式加解锁的过程等。不包含 ConditionObject 的分析。
简介 AQS 提供了实现同步阻塞队列的基本框架，是 juc 包中其他众多同步原语和锁实现的基础。
Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released.">
  <meta itemprop="datePublished" content="2023-05-21T16:04:33+08:00">
  <meta itemprop="dateModified" content="2023-05-21T16:04:33+08:00">
  <meta itemprop="wordCount" content="2343"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="AbstractQueuedSynchronizer 简介">
<meta name="twitter:description" content="本文主要介绍了 JUC 中的 AbstractQueuedSynchronizer 的实现基础、其和 CLH 队列锁之间的关联、独占锁模式及共享锁模式加解锁的过程等。不包含 ConditionObject 的分析。
简介 AQS 提供了实现同步阻塞队列的基本框架，是 juc 包中其他众多同步原语和锁实现的基础。
Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released.">

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Lihang Liu&#39;s Homepage
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Archives
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">AbstractQueuedSynchronizer 简介</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2023-05-21T16:04:33+08:00">May 21, 2023</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>本文主要介绍了 JUC 中的 <code>AbstractQueuedSynchronizer</code> 的实现基础、其和 CLH 队列锁之间的关联、独占锁模式及共享锁模式加解锁的过程等。不包含 <code>ConditionObject</code> 的分析。</p>
<h1 id="简介">简介</h1>
<p>AQS 提供了实现同步阻塞队列的基本框架，是 juc 包中其他众多同步原语和锁实现的基础。</p>
<blockquote>
<p>Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released. Given these, the other methods in this class carry out all queuing and blocking mechanics. Subclasses can maintain other state fields, but only the atomically updated int value manipulated using methods getState, setState and compareAndSetState is tracked with respect to synchronization.
S
以上片段摘录自 AQS 源码中的注释，可以总结出以下几点：</p>
</blockquote>
<ul>
<li>AQS 提供了一种基于先入先出 FIFO 等待队列的线程同步框架；</li>
<li>AQS 被设计为其他同步器实现的基础，其他同步器需要在内部实现 AQS 的模板方法，来实现自己的同步原语。</li>
</ul>
<h1 id="node-数据结构">Node 数据结构</h1>
<p><code>Node</code> 结构是 AQS 阻塞队列实现的基础结构，是 AQS 排队、获取锁、释放锁等行为被操作的对象。 <code>Node</code> 代表的其实就是想要获取锁的线程，每一个 <code>Node</code> 对象都是对一个想要获取锁的线程的封装和表示，其实现基于 CLH Queue Lock 中的节点数据结构，关于 CLH Queue Lock，可以参考笔者之前的博客（<a href="https://caffcen.github.io/2023/04/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-CLH-Queue-Lock/">深入理解 CLH Queue Lock | caffcen&rsquo;s blog</a>）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Node SHARED <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node();  <span style="color:#75715e">// 节点处于共享等待的标识</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Node EXCLUSIVE <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;  <span style="color:#75715e">// 节点处于独占等待的标识</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CANCELLED <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> SIGNAL <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CONDITION <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>2;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> PROPAGATE <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>3;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> waitStatus;  <span style="color:#75715e">// 线程的状态</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">volatile</span> Node prev;  <span style="color:#75715e">// 前驱节点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">volatile</span> Node next;  <span style="color:#75715e">// 后继节点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">volatile</span> Thread thread;  <span style="color:#75715e">// 节点对应的线程</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Node nextWaiter;  <span style="color:#75715e">// 指向下一个等待在条件变量上的节点</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>waitStatus</code> 可能有几种取值：</p>
<ol>
<li><code>0</code> : 节点初始化时候的值</li>
<li><code>CANCELLED = 1</code> : 表示节点由于超时或者被打断，『取消』排队</li>
<li><code>SIGNAL = -1</code> : 当前节点如果是 <code>SIGNAL</code> 则表示后继结点需要被唤醒，或者换过来说，如果当前节点想要被唤醒并尝试获取锁，则需要前驱节点的 <code>waitStatus</code> 是 <code>SIGNAL</code></li>
<li><code>CONDITION = -2</code> : 表示节点位于条件变量的等待队列中</li>
<li><code>PROPAGATE = -3</code> : 仅在释放共享锁时使用到</li>
</ol>
<p><code>Node</code> 类是构建起 AQS 阻塞双向队列的基础节点数据结构， <code>prev</code> 和 <code>next</code> 变量实现了双向队列， <code>waitStatus</code> 表示节点对应的线程的等待状态。</p>
<h1 id="aqs-队列">AQS 队列</h1>
<p>AQS 双向等待 FIFO 队列的实现基于上面提到 <code>Node</code> 数据结构：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbstractQueuedSynchronizer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">extends</span> AbstractOwnableSynchronizer
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">implements</span> java.<span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Serializable</span> {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Head of the wait queue, lazily initialized.  Except for
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * initialization, it is modified only via method setHead.  Note:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * If head exists, its waitStatus is guaranteed not to be
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * CANCELLED.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">volatile</span> Node head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Tail of the wait queue, lazily initialized.  Modified only via
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * method enq to add new wait node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">volatile</span> Node tail;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * The synchronization state.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> state;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>state</code> 字段是 AQS 的同步状态字段，主要通过 <code>compareAndSetState</code> （内部实现基于 Unsafe 的 CAS 操作）进行原子地更新。</p>
<h2 id="线程节点入队">线程节点入队</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbstractQueuedSynchronizer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">extends</span> AbstractOwnableSynchronizer
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">implements</span> java.<span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Serializable</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Inserts node into queue, initializing if necessary. See picture above.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param node the node to insert
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return node&#39;s predecessor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">enq</span>(<span style="color:#66d9ef">final</span> Node node) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (;;) {
</span></span><span style="display:flex;"><span>            Node t <span style="color:#f92672">=</span> tail;  <span style="color:#75715e">// 获取队列尾部节点</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果没有初始化，则原子地设置 head</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (t <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) { <span style="color:#75715e">// Must initialize</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (compareAndSetHead(<span style="color:#66d9ef">new</span> Node()))
</span></span><span style="display:flex;"><span>                    tail <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                node.<span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> t;  <span style="color:#75715e">// node 将要成为队列的新 tail，因此更新 t 为 node 的前驱节点</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (compareAndSetTail(t, node)) {  <span style="color:#75715e">// 原子地更新</span>
</span></span><span style="display:flex;"><span>                    t.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> t;  <span style="color:#75715e">// 更新成功则返回 node 的前驱节点，否则进入下一次循环直至成功</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Creates and enqueues node for current thread and given mode.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return the new node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">addWaiter</span>(Node mode) {
</span></span><span style="display:flex;"><span>        Node node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node(Thread.<span style="color:#a6e22e">currentThread</span>(), mode);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Try the fast path of enq; backup to full enq on failure</span>
</span></span><span style="display:flex;"><span>        Node pred <span style="color:#f92672">=</span> tail;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (pred <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            node.<span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> pred;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 尝试原子地更新尾结点，如果成功则直接返回，否则调用 enq 入队</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (compareAndSetTail(pred, node)) {
</span></span><span style="display:flex;"><span>                pred.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 快速入队失败，调用 enq 入队</span>
</span></span><span style="display:flex;"><span>        enq(node);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> node;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="线程节点出队">线程节点出队</h2>
<p>节点出队列则很简单，把 <code>head</code> 设为当前节点即可：</p>
<blockquote>
<p>To dequeue, you just set the head field.</p>
</blockquote>
<h1 id="模板方法">模板方法</h1>
<blockquote>
<p>Subclasses should be defined as non-public internal helper classes that are used to implement the synchronization properties of their enclosing class. Class AbstractQueuedSynchronizer does not implement any synchronization interface. Instead it defines methods such as acquireInterruptibly that can be invoked as appropriate by concrete locks and related synchronizers to implement their public methods.</p>
</blockquote>
<p>AQS 是非常优秀的模板模式的实现和应用，它提供以下模板方法供实现类实现，以达到不同的同步原语以及同步器机制：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbstractQueuedSynchronizer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">extends</span> AbstractOwnableSynchronizer
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">implements</span> java.<span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Serializable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquire</span>(<span style="color:#66d9ef">int</span> arg);  <span style="color:#75715e">// 尝试获取独占锁</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryRelease</span>(<span style="color:#66d9ef">int</span> arg);  <span style="color:#75715e">// 尝试释放独占锁</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">tryAcquireShared</span>(<span style="color:#66d9ef">int</span> arg);  <span style="color:#75715e">// 尝试获取共享锁</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryReleaseShared</span>(<span style="color:#66d9ef">int</span> arg);  <span style="color:#75715e">// 尝试释放共享锁</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isHeldExclusively</span>();  <span style="color:#75715e">// 返回共享资源是否以独占的方式被占用</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="reentrantlock-如何实现-aqs">ReentrantLock 如何实现 AQS</h2>
<p>我们以 <code>ReentrantLock</code> 为例来看一下 juc 包中的同步器和 AQS 是如何搭配使用的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReentrantLock</span> <span style="color:#66d9ef">implements</span> Lock, java.<span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Serializable</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Sync</span> <span style="color:#66d9ef">extends</span> AbstractQueuedSynchronizer {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">nonfairTryAcquire</span>(<span style="color:#66d9ef">int</span> acquires) {...}
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryRelease</span>(<span style="color:#66d9ef">int</span> releases) {...}
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isHeldExclusively</span>() {...}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NonfairSync</span> <span style="color:#66d9ef">extends</span> Sync {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquire</span>(<span style="color:#66d9ef">int</span> acquires) {...}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FairSync</span> <span style="color:#66d9ef">extends</span> Sync {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">tryAcquire</span>(<span style="color:#66d9ef">int</span> acquires) {...}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>ReentrantLock</code> 内部类 <code>Sync</code> 继承了 AQS，同时实现了 <code>tryRelease</code> 接口来释放锁，同时，为了同时实现公平锁和非公平锁的加锁逻辑， <code>ReentrantLock</code> 还提供了 <code>NonfairSync</code> 和 <code>FairSync</code> 来实现不同的 <code>tryAcquire</code> 逻辑。</p>
<p>可见 AQS 负责维护队列状态、更新同步状态等底层操作，这些操作对任何的同步器都是相同的，并且暴露出了 5 个模板接口供实现类实现，这样实现类仅仅需要关注自己的同步原语的实现即可，不用关注相同的底层逻辑。</p>
<h1 id="独占锁模式">独占锁模式</h1>
<h2 id="独占锁模式下的加锁操作">独占锁模式下的加锁操作</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbstractQueuedSynchronizer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">extends</span> AbstractOwnableSynchronizer
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">implements</span> java.<span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Serializable</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Acquires in exclusive mode, ignoring interrupts.  Implemented
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * by invoking at least once {@link #tryAcquire},
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * returning on success.  Otherwise the thread is queued, possibly
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * repeatedly blocking and unblocking, invoking {@link
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * #tryAcquire} until success.  This method can be used
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * to implement method {@link Lock#lock}.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param arg the acquire argument.  This value is conveyed to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *        {@link #tryAcquire} but is otherwise uninterpreted and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *        can represent anything you like.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">acquire</span>(<span style="color:#66d9ef">int</span> arg) {
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e">// 尝试获取锁，如果获取成功直接返回</span>
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e">// tryAcquire 由具体的同步器实现</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>tryAcquire(arg) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>            acquireQueued(addWaiter(Node.<span style="color:#a6e22e">EXCLUSIVE</span>), arg))  <span style="color:#75715e">// 无法获取到资源，先加入队列，再尝试获取</span>
</span></span><span style="display:flex;"><span>            selfInterrupt();  <span style="color:#75715e">// 中断当前线程</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Acquires in exclusive uninterruptible mode for thread already in
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * queue. Used by condition wait methods as well as acquire.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param node the node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param arg the acquire argument
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return {@code true} if interrupted while waiting
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">acquireQueued</span>(<span style="color:#66d9ef">final</span> Node node, <span style="color:#66d9ef">int</span> arg) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">boolean</span> failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">boolean</span> interrupted <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (;;) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">final</span> Node p <span style="color:#f92672">=</span> node.<span style="color:#a6e22e">predecessor</span>();  <span style="color:#75715e">// 取前置节点</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> head <span style="color:#f92672">&amp;&amp;</span> tryAcquire(arg)) {
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// 只有前置节点已经获取了锁，即前置节点成为了队列的 head 也就是出队时，尝试获取锁</span>
</span></span><span style="display:flex;"><span>                    setHead(node);  <span style="color:#75715e">// 获取锁成功，出队列，返回</span>
</span></span><span style="display:flex;"><span>                    p.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>; <span style="color:#75715e">// help GC</span>
</span></span><span style="display:flex;"><span>                    failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> interrupted;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 获取锁失败，调用 shouldParkAfterFailedAcquire 看是否需要睡眠当前线程</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (shouldParkAfterFailedAcquire(p, node) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                    parkAndCheckInterrupt())
</span></span><span style="display:flex;"><span>                    interrupted <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (failed)
</span></span><span style="display:flex;"><span>                cancelAcquire(node);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Checks and updates status for a node that failed to acquire.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Returns true if thread should block. This is the main signal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * control in all acquire loops.  Requires that pred == node.prev.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param pred node&#39;s predecessor holding status
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param node the node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return {@code true} if thread should block
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">shouldParkAfterFailedAcquire</span>(Node pred, Node node) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 取前置节点的 waitStatus</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ws <span style="color:#f92672">=</span> pred.<span style="color:#a6e22e">waitStatus</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ws <span style="color:#f92672">==</span> Node.<span style="color:#a6e22e">SIGNAL</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             * This node has already set status asking a release
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             * to signal it, so it can safely park.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;  <span style="color:#75715e">// 前置节点的 SIGNAL 已设置，当前可以安全地睡眠，返回 true</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ws <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             * Predecessor was cancelled. Skip over predecessors and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             * indicate retry.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 前驱节点对应的线程不再尝试获取锁，不断往前遍历知道找到一个状态为非取消的节点</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>                node.<span style="color:#a6e22e">prev</span> <span style="color:#f92672">=</span> pred <span style="color:#f92672">=</span> pred.<span style="color:#a6e22e">prev</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">while</span> (pred.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&gt;</span> 0);
</span></span><span style="display:flex;"><span>            pred.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             * waitStatus must be 0 or PROPAGATE.  Indicate that we
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             * need a signal, but don&#39;t park yet.  Caller will need to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             * retry to make sure it cannot acquire before parking.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">             */</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 设置前驱节点的状态为 SIGNAL，之后当前线程才能够被唤醒</span>
</span></span><span style="display:flex;"><span>            compareAndSetWaitStatus(pred, ws, Node.<span style="color:#a6e22e">SIGNAL</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Convenience method to park and then check if interrupted
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return {@code true} if interrupted
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">parkAndCheckInterrupt</span>() {
</span></span><span style="display:flex;"><span>        LockSupport.<span style="color:#a6e22e">park</span>(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Thread.<span style="color:#a6e22e">interrupted</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>总结一下加锁过程：</p>
<ul>
<li>调用 <code>acquire</code> 获取锁， <code>acquire</code> 内部调用同步器内部类实现的 <code>tryAcquire</code> 尝试获取锁，加锁成功则直接返回，否则将线程节点加入等待队列中，并调用 <code>acquireQueued</code> 继续尝试获取锁；</li>
<li><code>acquireQueued</code> 有一个无限循环来不断尝试获取锁。当前驱节点为 <code>head</code> 时才会调用 <code>tryAcquire</code> 来获取锁，这和 CLH 队列锁的加锁操作如出一辙：只有等前驱节点成功获取锁并解锁后，当前节点才能够取获取锁。这里贴出了 CLH 队列锁加锁的代码供对比参考：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CLHLock</span> <span style="color:#66d9ef">implements</span> Lock {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lock</span>() {
</span></span><span style="display:flex;"><span>        QNode qnode <span style="color:#f92672">=</span> myNode.<span style="color:#a6e22e">get</span>();
</span></span><span style="display:flex;"><span>        qnode.<span style="color:#a6e22e">locked</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        QNode pred <span style="color:#f92672">=</span> tail.<span style="color:#a6e22e">getAndSet</span>(qnode);
</span></span><span style="display:flex;"><span>        myPred.<span style="color:#a6e22e">set</span>(pred);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (pred.<span style="color:#a6e22e">locked</span>) {
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><code>acquireQueued</code> 如果加锁成功，那么则会将 <code>head</code> 设为当前节点，将当前节点出队并返回；否则调用 <code>shouldParkAfterFailedAcquire</code></li>
<li><code>shouldParkAfterFailedAcquire</code> 方法是用来在当前线程没有成功获取到锁时，检查并更新节点状态的。其有几个功能：
<ol>
<li>判断当前线程是否能够『安全地』休眠，即判断前驱结点的 <code>waitStatus</code> 是否为 <code>SIGNAL</code> ；</li>
<li>如果前驱节点取消了排队，则不断往前寻找一个未取消的节点，当做当前节点的前置节点；</li>
<li>如果前驱节点的 <code>waitStatus</code> 不为 <code>SIGNAL</code> ，则原子性的更新为 <code>SIGNAL</code> ，方便当前节点之后被阻塞</li>
<li>返回当前线程是否能够休眠；</li>
</ol>
</li>
</ul>
<p>总的来说，AQS 共享锁的加锁逻辑和 CLH 队列锁的加锁逻辑本质上是相同的：当前线程只有在它的前驱节点的线程获取到锁之后，才可以尝试去获取锁，且它们都采用的是一种自旋忙等待的方式，不断地测试前置节点的状态来实现的。</p>
<p>不同点在于 AQS 通过 <code>shouldParkAfterFailedAcquire</code> 方法可以让当前忙等待的线程被阻塞，好让出 CPU 时间。</p>
<h2 id="独占锁模式下的解锁操作">独占锁模式下的解锁操作</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbstractQueuedSynchronizer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">extends</span> AbstractOwnableSynchronizer
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">implements</span> java.<span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Serializable</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Releases in exclusive mode.  Implemented by unblocking one or
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * more threads if {@link #tryRelease} returns true.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * This method can be used to implement method {@link Lock#unlock}.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param arg the release argument.  This value is conveyed to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *        {@link #tryRelease} but is otherwise uninterpreted and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *        can represent anything you like.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return the value returned from {@link #tryRelease}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">release</span>(<span style="color:#66d9ef">int</span> arg) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 调用同步器实现的 tryRelease</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (tryRelease(arg)) {
</span></span><span style="display:flex;"><span>            Node h <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果成功释放，则调用 unparkSuccessor 唤醒可能在睡眠的后继节点线程</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (h <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> h.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">!=</span> 0)
</span></span><span style="display:flex;"><span>                unparkSuccessor(h);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Wakes up node&#39;s successor, if one exists.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param node the node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unparkSuccessor</span>(Node node) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * If status is negative (i.e., possibly needing signal) try
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * to clear in anticipation of signalling.  It is OK if this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * fails or if status is changed by waiting thread.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ws <span style="color:#f92672">=</span> node.<span style="color:#a6e22e">waitStatus</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ws <span style="color:#f92672">&lt;</span> 0)
</span></span><span style="display:flex;"><span>            compareAndSetWaitStatus(node, ws, 0);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Thread to unpark is held in successor, which is normally
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * just the next node.  But if cancelled or apparently null,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * traverse backwards from tail to find the actual
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * non-cancelled successor.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        Node s <span style="color:#f92672">=</span> node.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果后继节点取消了排队，则从 tail 开始往队列头部遍历，找到 node 后第一个未取消排队的节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (s <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> s.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&gt;</span> 0) {
</span></span><span style="display:flex;"><span>            s <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (Node t <span style="color:#f92672">=</span> tail; t <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> t <span style="color:#f92672">!=</span> node; t <span style="color:#f92672">=</span> t.<span style="color:#a6e22e">prev</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (t.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&lt;=</span> 0)
</span></span><span style="display:flex;"><span>                    s <span style="color:#f92672">=</span> t;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 如果后继节点存在，则唤醒它</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (s <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>            LockSupport.<span style="color:#a6e22e">unpark</span>(s.<span style="color:#a6e22e">thread</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>独占模式下解锁的操作则简单很多，主要工作是唤醒当前节点的后继节点。</p>
<h1 id="共享锁模式">共享锁模式</h1>
<h2 id="共享锁模式下的加锁操作">共享锁模式下的加锁操作</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbstractQueuedSynchronizer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">extends</span> AbstractOwnableSynchronizer
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">implements</span> java.<span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Serializable</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Acquires in shared mode, ignoring interrupts.  Implemented by
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * first invoking at least once {@link #tryAcquireShared},
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * returning on success.  Otherwise the thread is queued, possibly
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * repeatedly blocking and unblocking, invoking {@link
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * #tryAcquireShared} until success.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param arg the acquire argument.  This value is conveyed to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *        {@link #tryAcquireShared} but is otherwise uninterpreted
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *        and can represent anything you like.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">acquireShared</span>(<span style="color:#66d9ef">int</span> arg) {
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e">// 调用同步器实现的 tryAcquireShared 方法</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (tryAcquireShared(arg) <span style="color:#f92672">&lt;</span> 0)
</span></span><span style="display:flex;"><span>	        <span style="color:#75715e">// 失败，调用 doAcquireShared 方法继续不断尝试</span>
</span></span><span style="display:flex;"><span>            doAcquireShared(arg);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Acquires in shared uninterruptible mode.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param arg the acquire argument
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doAcquireShared</span>(<span style="color:#66d9ef">int</span> arg) {
</span></span><span style="display:flex;"><span>	    <span style="color:#75715e">// 获取锁失败，现将线程入队</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">final</span> Node node <span style="color:#f92672">=</span> addWaiter(Node.<span style="color:#a6e22e">SHARED</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">boolean</span> failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">boolean</span> interrupted <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> (;;) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">final</span> Node p <span style="color:#f92672">=</span> node.<span style="color:#a6e22e">predecessor</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 和独占模式相同，只有前置节点为 head 时才能够尝试获取锁</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (p <span style="color:#f92672">==</span> head) {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> tryAcquireShared(arg);
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// r &gt;= 0 表示获取锁成功</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (r <span style="color:#f92672">&gt;=</span> 0) {
</span></span><span style="display:flex;"><span>	                    <span style="color:#75715e">// 当前线程出队，并将 release 信息传播给后继节点</span>
</span></span><span style="display:flex;"><span>                        setHeadAndPropagate(node, r);
</span></span><span style="display:flex;"><span>                        p.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>; <span style="color:#75715e">// help GC</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">if</span> (interrupted)
</span></span><span style="display:flex;"><span>                            selfInterrupt();
</span></span><span style="display:flex;"><span>                        failed <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 获取锁失败，判断是否需要休眠</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (shouldParkAfterFailedAcquire(p, node) <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                    parkAndCheckInterrupt())
</span></span><span style="display:flex;"><span>                    interrupted <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (failed)
</span></span><span style="display:flex;"><span>                cancelAcquire(node);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Sets head of queue, and checks if successor may be waiting
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * in shared mode, if so propagating if either propagate &gt; 0 or
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * PROPAGATE status was set.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param node the node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param propagate the return value from a tryAcquireShared
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setHeadAndPropagate</span>(Node node, <span style="color:#66d9ef">int</span> propagate) {
</span></span><span style="display:flex;"><span>        Node h <span style="color:#f92672">=</span> head; <span style="color:#75715e">// Record old head for check below</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 设置 head 为当前节点，表示当前节点已经获取到了临界资源，出队</span>
</span></span><span style="display:flex;"><span>        setHead(node);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Try to signal next queued node if:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *   Propagation was indicated by caller,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *     or was recorded (as h.waitStatus either before
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *     or after setHead) by a previous operation
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *     (note: this uses sign-check of waitStatus because
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *      PROPAGATE status may transition to SIGNAL.)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * and
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *   The next node is waiting in shared mode,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *     or we don&#39;t know, because it appears null
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * The conservatism in both of these checks may cause
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * unnecessary wake-ups, but only when there are multiple
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * racing acquires/releases, so most need signals now or soon
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * anyway.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (propagate <span style="color:#f92672">&gt;</span> 0 <span style="color:#f92672">||</span> h <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> h.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span>
</span></span><span style="display:flex;"><span>            (h <span style="color:#f92672">=</span> head) <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> h.<span style="color:#a6e22e">waitStatus</span> <span style="color:#f92672">&lt;</span> 0) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 当满足任一条件时，则唤醒后继节点让其尝试进入临界区</span>
</span></span><span style="display:flex;"><span>            Node s <span style="color:#f92672">=</span> node.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (s <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> s.<span style="color:#a6e22e">isShared</span>())
</span></span><span style="display:flex;"><span>                doReleaseShared();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Release action for shared mode -- signals successor and ensures
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * propagation. (Note: For exclusive mode, release just amounts
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * to calling unparkSuccessor of head if it needs signal.)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doReleaseShared</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Ensure that a release propagates, even if there are other
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * in-progress acquires/releases.  This proceeds in the usual
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * way of trying to unparkSuccessor of head if it needs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * signal. But if it does not, status is set to PROPAGATE to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * ensure that upon release, propagation continues.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Additionally, we must loop in case a new node is added
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * while we are doing this. Also, unlike other uses of
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * unparkSuccessor, we need to know if CAS to reset status
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * fails, if so rechecking.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (;;) {
</span></span><span style="display:flex;"><span>            Node h <span style="color:#f92672">=</span> head;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (h <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> h <span style="color:#f92672">!=</span> tail) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> ws <span style="color:#f92672">=</span> h.<span style="color:#a6e22e">waitStatus</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (ws <span style="color:#f92672">==</span> Node.<span style="color:#a6e22e">SIGNAL</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 当 waitStatus 为 SIGNAL 时，需要唤醒后继节点</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>compareAndSetWaitStatus(h, Node.<span style="color:#a6e22e">SIGNAL</span>, 0))
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// recheck 保证线程安全</span>
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">continue</span>;            <span style="color:#75715e">// loop to recheck cases</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 唤醒后继节点</span>
</span></span><span style="display:flex;"><span>                    unparkSuccessor(h);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (ws <span style="color:#f92672">==</span> 0 <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>                         <span style="color:#f92672">!</span>compareAndSetWaitStatus(h, 0, Node.<span style="color:#a6e22e">PROPAGATE</span>))
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 为了保证将唤醒操作传播出去，需要设置 waitStatus 为 PROPAGATE</span>
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">continue</span>;                <span style="color:#75715e">// loop on failed CAS</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 如果 head 变更，说明有其他节点也成功释放了临界资源，它将会负责唤醒后继的阻塞节点，当前线程可以退出循环</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (h <span style="color:#f92672">==</span> head)                   <span style="color:#75715e">// loop if head changed</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>共享模式和独占模式加锁的区别主要是：</p>
<ol>
<li>可以有多个线程同时尝试获取锁；独占模式只能有一个；</li>
<li>共享锁模式下，如果一个线程成功获取到了锁，那么它还会同时尝试去唤醒其他等待着的线程；而独占模式只有在解锁后才会去唤醒队列中阻塞的节点。</li>
</ol>
<p>共享锁模式比较重要的是 <code>setHeadAndPropagate</code> 和 <code>doReleaseShared</code> 。 <code>setHeadAndPropagate</code> 会进行两个操作：</p>
<ol>
<li>将获取了锁的线程出队，即将 <code>head</code> 设为当前节点；</li>
<li>满足一下条件时，调用 <code>doReleaseShared</code> 唤醒队列中阻塞的线程：
<ol>
<li><code>propagate &gt; 0</code> : 表示还有资源剩余可以索取</li>
<li><code>h == null</code></li>
<li><code>h.waitStatus &lt; 0</code></li>
<li><code>(h = head) == null</code></li>
<li><code>h.waitStatus &lt; 0</code></li>
</ol>
</li>
</ol>
<p><code>doReleaseShared</code> 则是在尝试不断地唤醒符合条件的节点。</p>
<p>总结一下共享模式加锁：</p>
<ul>
<li>调用 <code>acquireShared</code> 加锁。会调用同步器实现的 <code>tryAcquireShared</code> 方法尝试获取锁，如果成功直接返回；否则调用 <code>doAcquireShared</code></li>
<li><code>doAcquireShared</code> 首先会将当前线程入队；之后则会尝试获取锁：
<ul>
<li>先判断自己的前驱节点是否是 <code>head</code> ，是的话则尝试获取锁，如果成功则调用 <code>setHeadAndPropagate</code> ，将 <code>head</code> 设置为自己，同时唤醒队列中阻塞的节点</li>
<li>如果自己的前驱节点不是 <code>head</code> ，又或者获取锁失败，则调用 <code>shouldParkAfterFailedAcquire</code> 判断自己是否需要休眠，这和独占锁模式是一模一样的</li>
</ul>
</li>
<li><code>setHeadAndPropagate</code> 首先将当前获得了共享锁的节点出队，之后在满足条件的情况下，尝试唤醒队列中被阻塞的线程</li>
<li><code>doReleaseShared</code> 不断尝试唤醒被阻塞的线程，直到 <code>head</code> 因为某个线程也成功地获得到了共享锁而被更新为止</li>
</ul>
<p>因为共享锁模式下，共同持有锁的多个线程势必将带来比较复杂的竞争，笔者对这部分内容的理解也不是很透彻，推荐阅读文末 Reference 中的美团技术博客（<a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用 - 美团技术团队</a>），其中有较好的分析。</p>
<h2 id="共享锁模式下的解锁操作">共享锁模式下的解锁操作</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbstractQueuedSynchronizer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">extends</span> AbstractOwnableSynchronizer
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">implements</span> java.<span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Serializable</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Releases in shared mode.  Implemented by unblocking one or more
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * threads if {@link #tryReleaseShared} returns true.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param arg the release argument.  This value is conveyed to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *        {@link #tryReleaseShared} but is otherwise uninterpreted
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *        and can represent anything you like.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return the value returned from {@link #tryReleaseShared}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">releaseShared</span>(<span style="color:#66d9ef">int</span> arg) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (tryReleaseShared(arg)) {
</span></span><span style="display:flex;"><span>            doReleaseShared();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>解锁操作很简单，调用了同步器实现的 <code>tryReleaseShared</code> 方法，如果成功释放了共享资源则调用 <code>doReleaseShared</code> 唤醒后续线程。</p>
<h1 id="reference">Reference</h1>
<ol>
<li>AQS 源码</li>
<li><a href="https://gee.cs.oswego.edu/dl/papers/aqs.pdf">https://gee.cs.oswego.edu/dl/papers/aqs.pdf</a></li>
<li><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用 - 美团技术团队</a></li>
<li><a href="https://www.cnblogs.com/taleLaugh/p/15257784.html">Java并发之AQS详解 - 拉夫德鲁 - 博客园</a></li>
</ol>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://caffcen.github.io/" >
    &copy;  Lihang Liu's Homepage 2024 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
