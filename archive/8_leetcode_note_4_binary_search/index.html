<!DOCTYPE html>
<html><head lang="en">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>LeetCode 笔记 4：Binary Search 的5种变体应用 - Lihang Liu&#39;s Homepage</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="二分查找在算法题目中是十分常见的一类题目，但这类题目往往要求二分查找找出解集中的第一个、最后一个解，这个时候通常的二分查找算法就无法直接套用了。
本文将列举 5 种二分查找的变体应用，它们分别是：
Contains，是否包含目标 Index of first occurrence of a key，目标第一次出现的下标 Index of last occurrence of a key，目标最后一次出现的下标 Index of least element greater than (or equal) to key，最小的大于（或大于等于）目标的下标 Index of greatest element less than (or equal to) key，最大的小于（或小于等于）目标的下标 之后会更新几篇文章针对不同类型的题目进行分析。
这 5 中变体算法的代码如下：
class BinarySearch { /** * 是否包含 key * * @param nums 输入数组 * @param key 目标 * @return true 包含；false 不包含 */ public static boolean contains(int[] nums, int key) { int low = 0, high = nums." />
	<meta property="og:image" content=""/>
	<meta property="og:url" content="https://caffcen.github.io/archive/8_leetcode_note_4_binary_search/">
  <meta property="og:site_name" content="Lihang Liu&#39;s Homepage">
  <meta property="og:title" content="LeetCode 笔记 4：Binary Search 的5种变体应用">
  <meta property="og:description" content="二分查找在算法题目中是十分常见的一类题目，但这类题目往往要求二分查找找出解集中的第一个、最后一个解，这个时候通常的二分查找算法就无法直接套用了。
本文将列举 5 种二分查找的变体应用，它们分别是：
Contains，是否包含目标 Index of first occurrence of a key，目标第一次出现的下标 Index of last occurrence of a key，目标最后一次出现的下标 Index of least element greater than (or equal) to key，最小的大于（或大于等于）目标的下标 Index of greatest element less than (or equal to) key，最大的小于（或小于等于）目标的下标 之后会更新几篇文章针对不同类型的题目进行分析。
这 5 中变体算法的代码如下：
class BinarySearch { /** * 是否包含 key * * @param nums 输入数组 * @param key 目标 * @return true 包含；false 不包含 */ public static boolean contains(int[] nums, int key) { int low = 0, high = nums.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="archive">
    <meta property="article:published_time" content="2023-03-12T16:03:48+08:00">
    <meta property="article:modified_time" content="2023-03-12T16:03:48+08:00">
<meta name="twitter:card" content="summary"><meta name="twitter:title" content="LeetCode 笔记 4：Binary Search 的5种变体应用">
<meta name="twitter:description" content="二分查找在算法题目中是十分常见的一类题目，但这类题目往往要求二分查找找出解集中的第一个、最后一个解，这个时候通常的二分查找算法就无法直接套用了。
本文将列举 5 种二分查找的变体应用，它们分别是：
Contains，是否包含目标 Index of first occurrence of a key，目标第一次出现的下标 Index of last occurrence of a key，目标最后一次出现的下标 Index of least element greater than (or equal) to key，最小的大于（或大于等于）目标的下标 Index of greatest element less than (or equal to) key，最大的小于（或小于等于）目标的下标 之后会更新几篇文章针对不同类型的题目进行分析。
这 5 中变体算法的代码如下：
class BinarySearch { /** * 是否包含 key * * @param nums 输入数组 * @param key 目标 * @return true 包含；false 不包含 */ public static boolean contains(int[] nums, int key) { int low = 0, high = nums.">
<script src="https://caffcen.github.io/js/feather.min.js"></script>
	
	
        <link href="https://caffcen.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://caffcen.github.io/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://caffcen.github.io/css/dark.726cd11ca6eb7c4f7d48eb420354f814e5c1b94281aaf8fd0511c1319f7f78a4.css"  disabled />
	

	
	

	
	
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
		
		
		<script>
			document.addEventListener("DOMContentLoaded", function() {
					renderMathInElement(document.body, {
							delimiters: [
									{left: "$$", right: "$$", display: true},
									{left: "$", right: "$", display: false}
							]
					});
			});
			</script>
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://caffcen.github.io/">Lihang Liu&#39;s Homepage</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/blog/">Blog</a>
		
		<a href="/archive/">Archive</a>
		
		| <span id="dark-mode-toggle" onclick="toggleTheme()"></span>
		<script src="https://caffcen.github.io/js/themetoggle.js"></script>
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">LeetCode 笔记 4：Binary Search 的5种变体应用</h1>
			<div class="meta">Posted on Mar 12, 2023</div>
		</div>
		

		<section class="body">
			<p>二分查找在算法题目中是十分常见的一类题目，但这类题目往往要求二分查找找出解集中的第一个、最后一个解，这个时候通常的二分查找算法就无法直接套用了。</p>
<p>本文将列举 5 种二分查找的变体应用，它们分别是：</p>
<ol>
<li>Contains，是否包含目标</li>
<li>Index of first occurrence of a key，目标第一次出现的下标</li>
<li>Index of last occurrence of a key，目标最后一次出现的下标</li>
<li>Index of least element greater than (or equal) to key，最小的大于（或大于等于）目标的下标</li>
<li>Index of greatest element less than (or equal to) key，最大的小于（或小于等于）目标的下标</li>
</ol>
<p>之后会更新几篇文章针对不同类型的题目进行分析。</p>
<p>这 5 中变体算法的代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BinarySearch</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 是否包含 key
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param nums 输入数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param key 目标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return true 包含；false 不包含
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">contains</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums, <span style="color:#66d9ef">int</span> key) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> low <span style="color:#f92672">=</span> 0, high <span style="color:#f92672">=</span> nums.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;=</span> high) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> low <span style="color:#f92672">+</span> (high <span style="color:#f92672">-</span> low) <span style="color:#f92672">/</span> 2;  <span style="color:#75715e">// (low + high) / 2 可能导致溢出，因此采用这种方式计算</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> midVal <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>mid<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (midVal <span style="color:#f92672">==</span> key) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (midVal <span style="color:#f92672">&lt;</span> key) {
</span></span><span style="display:flex;"><span>                low <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (midVal <span style="color:#f92672">&gt;</span> key) {
</span></span><span style="display:flex;"><span>                high <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param nums 输入数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param key 目标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return 返回 key 第一次出现时的下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">first</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums, <span style="color:#66d9ef">int</span> key) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1, low <span style="color:#f92672">=</span> 0, high <span style="color:#f92672">=</span> nums.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;=</span> high) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> low <span style="color:#f92672">+</span> (high <span style="color:#f92672">-</span> low <span style="color:#f92672">+</span> 1) <span style="color:#f92672">/</span> 2;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> midVal <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>mid<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (midVal <span style="color:#f92672">&lt;</span> key) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// key 在 mid 右边</span>
</span></span><span style="display:flex;"><span>                low <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (midVal <span style="color:#f92672">&gt;</span> key) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// key 在 mid 左边</span>
</span></span><span style="display:flex;"><span>                high <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (midVal <span style="color:#f92672">==</span> key) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// mid 左边可能存在 key，因此左移右边界</span>
</span></span><span style="display:flex;"><span>                ans <span style="color:#f92672">=</span> mid;
</span></span><span style="display:flex;"><span>                high <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param nums 输入数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param key 目标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return 返回 key 最后出现时的下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">last</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums, <span style="color:#66d9ef">int</span> key) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1, low <span style="color:#f92672">=</span> 0, high <span style="color:#f92672">=</span> nums.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;=</span> high) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> low <span style="color:#f92672">+</span> (high <span style="color:#f92672">-</span> low <span style="color:#f92672">+</span> 1) <span style="color:#f92672">/</span> 2;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> midVal <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>mid<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (midVal <span style="color:#f92672">&lt;</span> key) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// key 在 mid 右边</span>
</span></span><span style="display:flex;"><span>                low <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (midVal <span style="color:#f92672">&gt;</span> key) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// key 在 mid 左边</span>
</span></span><span style="display:flex;"><span>                high <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (midVal <span style="color:#f92672">==</span> key) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 右边界任然可能存在 key，因此将 low 右移</span>
</span></span><span style="display:flex;"><span>                ans <span style="color:#f92672">=</span> mid;
</span></span><span style="display:flex;"><span>                low <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param nums 输入数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param key 目标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return 最小大于 key 的元素的下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">leastGreater</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums, <span style="color:#66d9ef">int</span> key) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1, low <span style="color:#f92672">=</span> 0, high <span style="color:#f92672">=</span> nums.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;=</span> high) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> low <span style="color:#f92672">+</span> (high <span style="color:#f92672">-</span> low <span style="color:#f92672">+</span> 1) <span style="color:#f92672">/</span> 2;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> midVal <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>mid<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (midVal <span style="color:#f92672">&lt;</span> key) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 最小大于 key 的元素在 mid 右边</span>
</span></span><span style="display:flex;"><span>                low <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (midVal <span style="color:#f92672">&gt;</span> key) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 任然存在比 midVal 更小的解，因此将 high 左移</span>
</span></span><span style="display:flex;"><span>                ans <span style="color:#f92672">=</span> mid;
</span></span><span style="display:flex;"><span>                high <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (midVal <span style="color:#f92672">==</span> key) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 最小大于 key 的元素在 mid 右边</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 可以和 midVal &lt; key 的情况进行合并</span>
</span></span><span style="display:flex;"><span>                low <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param nums 输入数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param key 目标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @return 最大的小于 key 的元素的下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">greatestLesser</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums, <span style="color:#66d9ef">int</span> key) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1, low <span style="color:#f92672">=</span> 0, high <span style="color:#f92672">=</span> nums.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;=</span> high) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> low <span style="color:#f92672">+</span> (high <span style="color:#f92672">-</span> low <span style="color:#f92672">+</span> 1) <span style="color:#f92672">/</span> 2;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> midVal <span style="color:#f92672">=</span> nums<span style="color:#f92672">[</span>mid<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (midVal <span style="color:#f92672">&lt;</span> key) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 可能存在比 midVal 更大的解，因此右移 low</span>
</span></span><span style="display:flex;"><span>                ans <span style="color:#f92672">=</span> mid;
</span></span><span style="display:flex;"><span>                low <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (midVal <span style="color:#f92672">&gt;</span> key) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// midVal 过大，解在 mid 左边</span>
</span></span><span style="display:flex;"><span>                high <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (midVal <span style="color:#f92672">==</span> key) {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 同样，可以和 midVal &gt; key 进行合并</span>
</span></span><span style="display:flex;"><span>                high <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> 1;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>其中算法 <code>leastGreater</code> 和 <code>greatestLesser</code> 只需稍作修改即可用于求解大于等于以及小于等于的情况，因此不做赘述。</p>
<p>其中，变体 2 （目标第一次出现时的下标，上面的 <code>first</code> 算法）和 C++ <code>std::lower_bound()</code> 很类似：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ForwardIt</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>ForwardIt lower_bound(ForwardIt first, ForwardIt last, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ForwardIt it;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>iterator_traits<span style="color:#f92672">&lt;</span>ForwardIt<span style="color:#f92672">&gt;::</span>difference_type count, step;
</span></span><span style="display:flex;"><span>    count <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>distance(first, last);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        it <span style="color:#f92672">=</span> first; 
</span></span><span style="display:flex;"><span>        step <span style="color:#f92672">=</span> count <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>; 
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>advance(it, step);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>it <span style="color:#f92672">&lt;</span> value)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            first <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>it; 
</span></span><span style="display:flex;"><span>            count <span style="color:#f92672">-=</span> step <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; 
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            count <span style="color:#f92672">=</span> step;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> first;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>变体 4，最大的小于（或小于等于）目标的元素的下标（上面的 <code>greatestLesser</code> 算法）和 C++ 的 <code>std::upper_bound()</code> 算法很类似：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ForwardIt</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>ForwardIt upper_bound(ForwardIt first, ForwardIt last, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ForwardIt it;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>iterator_traits<span style="color:#f92672">&lt;</span>ForwardIt<span style="color:#f92672">&gt;::</span>difference_type count, step;
</span></span><span style="display:flex;"><span>    count <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>distance(first, last);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        it <span style="color:#f92672">=</span> first; 
</span></span><span style="display:flex;"><span>        step <span style="color:#f92672">=</span> count <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>; 
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>advance(it, step);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(value <span style="color:#f92672">&lt;</span> <span style="color:#f92672">*</span>it))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            first <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>it;
</span></span><span style="display:flex;"><span>            count <span style="color:#f92672">-=</span> step <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        } 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            count <span style="color:#f92672">=</span> step;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> first;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="reference">Reference</h1>
<ol>
<li><a href="https://www.geeksforgeeks.org/variants-of-binary-search/">Variants of Binary Search - GeeksforGeeks</a></li>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound">std::lower_bound - cppreference.com</a></li>
<li><a href="https://en.cppreference.com/w/cpp/algorithm/upper_bound">std::upper_bound - cppreference.com</a></li>
</ol>

		</section>

		<div class="post-tags">
			
			
			
		</div>
		</article>
</main>
<footer>
  <div style="display:flex"></div>
  <div class="footer-info">
    2024  © Lihang Liu |  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>


  


</div>
    </body>
</html>
