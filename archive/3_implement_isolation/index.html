<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://caffcen.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://caffcen.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://caffcen.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https://caffcen.github.io/android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=https://caffcen.github.io/apple-touch-icon.png><meta name=description content><title>本地事务的隔离性是如何实现的 | Lihang Liu's Homepage</title><link rel=canonical href=https://caffcen.github.io/archive/3_implement_isolation/><meta property="og:url" content="https://caffcen.github.io/archive/3_implement_isolation/"><meta property="og:site_name" content="Lihang Liu's Homepage"><meta property="og:title" content="本地事务的隔离性是如何实现的"><meta property="og:description" content="详细解析数据库事务隔离性的实现原理，包括锁机制和各种隔离级别的工作方式"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="archive"><meta property="article:published_time" content="2023-02-12T16:02:53+08:00"><meta property="article:modified_time" content="2025-11-23T14:50:26-05:00"><link rel=stylesheet href=/assets/combined.min.57df9e7d692553f966cff4593ede6b53efb74da234876bacffeac774bd572e53.css media=all></head><body class=auto><div class=content><header><div class=header><h1 class=header-title><a href=https://caffcen.github.io/>Lihang Liu's Homepage</a></h1><div class=header-menu><p class=small><a href=/>/Home</a></p><p class=small><a href=/blog/>/Blog</a></p><p class=small><a href=/archive/>/Archive</a></p></div></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a><span class=breadcrumbs-separator>/</span><a href=/archive/>Archive</a><span class=breadcrumbs-separator>/</span>
<a href=/archive/3_implement_isolation/>本地事务的隔离性是如何实现的</a></div><div><article><header class=single-intro-container><h1 class=single-title>本地事务的隔离性是如何实现的</h1><p class=single-summary>详细解析数据库事务隔离性的实现原理，包括锁机制和各种隔离级别的工作方式</p><div class=single-subsummary><div><p class=single-date><time datetime=2023-02-12T16:02:53+08:00>February 12, 2023</time></p></div></div></header><div class=single-content><p>如果没有并发的存在，数据库所有事务总是串行执行的，那么也就不会有临界资源竞争的情况出现，但现实情况是不可能没有并发的存在。</p><p>为了保证并发的正确性，需要通过对数据库资源加锁。本文将首先介绍数据库中的锁，之后会介绍各个隔离级别及其实现方式。</p><h1 class=heading id=锁>锁
<a class=anchor href=#%e9%94%81>#</a></h1><ul><li><strong>写锁</strong>（Write Lock，也叫作排他锁，eXclusive Lock，简写为 X-Lock）：如果数据有加写锁，就只有持有写锁的事务才能对数据进行写入操作，数据加持着写锁时，其他事务不能写入数据，也不能施加读锁。</li><li><strong>读锁</strong>（Read Lock，也叫作共享锁，Shared Lock，简写为 S-Lock）：多个事务可以对同一个数据添加多个读锁，数据被加上读锁后就不能再被加上写锁，所以其他事务不能对该数据进行写入，但仍然可以读取。对于持有读锁的事务，如果该数据只有它自己一个事务加了读锁，允许直接将其升级为写锁，然后写入数据。</li><li><strong>范围锁</strong>（Range Lock）：对于某个范围直接加排他锁，在这个范围内的数据不能被写入。</li></ul><p>特别注意：<strong>写锁禁止其他事务施加读锁，而不是禁止事务读取数据。</strong></p><h2 class=heading id=兼容性>兼容性
<a class=anchor href=#%e5%85%bc%e5%ae%b9%e6%80%a7>#</a></h2><p>只有读锁和读锁是兼容的，写锁不兼容任何其他锁。</p><div class=table-outer><table><thead><tr><th></th><th>Write Lock (X)</th><th>Read Lock (S)</th></tr></thead><tbody><tr><td>Write Lock (X)</td><td>不兼容</td><td>不兼容</td></tr><tr><td>Read Lock (S)</td><td>不兼容</td><td>兼容</td></tr></tbody></table></div><h1 class=heading id=事务隔离级别>事务隔离级别
<a class=anchor href=#%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab>#</a></h1><p>事务的隔离性是通过锁的机制来实现的，事务的隔离性越高，并发吞吐量越低，为了让开发人员能够在吞吐量以及隔离性之前取的较好的平衡点，数据库提供了多种隔离性级别。</p><p>从本质上来说，事务在不同隔离级别下的不同表现，来源于不同隔离级别采取的加锁机制的不同。</p><p>下表是事务的 4 个隔离级别，隔离性从上到下依次递减：</p><div class=table-outer><table><thead><tr><th>隔离级别</th><th>特征</th><th>可能存在的问题</th></tr></thead><tbody><tr><td><strong>Serializability</strong>，可串行性</td><td>多个事务并发执行的效果，和串行执行的效果一致。</td><td>无</td></tr><tr><td><strong>Repeatable read</strong>，可重复读</td><td>可重复度保证一个事务读取到的数据，在整个事务执行过程中不会改变。</td><td>幻读</td></tr><tr><td><strong>Read committed</strong>，读已提交</td><td>不允许一个事务读取到其他事务提交的数据。</td><td>幻读、不可重复读</td></tr><tr><td><strong>Read uncommitted</strong>，读未提交</td><td>允许一个事务读取到其他事务未提交的数据。</td><td>幻读、不可重复读、脏读</td></tr></tbody></table></div><h2 class=heading id=serializability-可串行性>Serializability, 可串行性
<a class=anchor href=#serializability-%e5%8f%af%e4%b8%b2%e8%a1%8c%e6%80%a7>#</a></h2><p>对事务所涉及到的数据加读锁、写锁、范围锁即可实现 <code>Serializability</code> 所要求的隔离性。</p><h2 class=heading id=repeatable-read-可重复读>Repeatable Read, 可重复读
<a class=anchor href=#repeatable-read-%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb>#</a></h2><p><code>可重复读</code> 对事务所涉及的数据加读锁和写锁，且一直持有至事务结束，但不再加范围锁。这就意味着 <code>可重复读</code> 可能会出现幻读（Phantom reads, 可参考下文针对幻读问题的讨论）的问题，比如说：</p><p><figure><div class=img-container style=--w:2348;--h:778><img loading=lazy alt src=/archive/3_implement_isolation/Pasted%20image%2020230212154319.png width=2348 height=778></div></figure></p><p>事务 T1 在两次查询取得的数据将会不同，这是因为事务 T1 并没有加范围锁，而 T2 在两次查询之间插入了一行新的记录，这是允许的，因为 <code>可重复读</code> 仅仅只会对数据加读锁和写锁。</p><h2 class=heading id=read-committed-读已提交>Read Committed, 读已提交
<a class=anchor href=#read-committed-%e8%af%bb%e5%b7%b2%e6%8f%90%e4%ba%a4>#</a></h2><p><code>读已提交</code> 对事务所涉及的数据将会加写锁和读锁，写锁在被施加后会一直持续到事务结束为止，但是读锁在查询操作结束后将会立即得到释放。</p><p><code>读已提交</code> 除了幻读问题之外，还存在着 <code>不可重复读</code> （Non-repeatable reads, 可参考下文对不可重复读问题的讨论）的问题，举个例子：</p><p><figure><div class=img-container style=--w:2584;--h:776><img loading=lazy alt src=/archive/3_implement_isolation/Pasted%20image%2020230212155522.png width=2584 height=776></div></figure></p><p>事务 T1 将会读到 T2 对数据的修改，这是因为在 <code>读已提交</code> 隔离级别下，事务不会对数据加贯穿整个事务生命周期的读锁，在 T1 事务第一次查询结束之后，该行记录的写锁就被释放了，T2 也因此能够对改行数据进行写操作。</p><h2 class=heading id=read-uncommitted-读未提交>Read Uncommitted, 读未提交
<a class=anchor href=#read-uncommitted-%e8%af%bb%e6%9c%aa%e6%8f%90%e4%ba%a4>#</a></h2><p><code>读未提交</code> 对事务涉及的数据只加写锁，会一直持续到事务结束，但完全不加读锁。</p><p><code>读未提交</code> 除了有幻读、不可重复读问题之外，还可能面临脏读的问题（Dirty reads，可参考下文对脏读问题的解释），举例如下：</p><p><figure><div class=img-container style=--w:1304;--h:430><img loading=lazy alt src=/archive/3_implement_isolation/Pasted%20image%2020230212160142.png width=1304 height=430></div></figure></p><p><code>读未提交</code> 完全不加读锁，因此即便 T2 对行数据加了写锁，T1 也能读到 T2 对行数据的修改。</p><p>这里要特别注意，写锁会阻塞任何加写锁或读锁的操作，并不阻塞单纯的读取行为。 <code>读未提交</code> 在查询时不加读锁，因此不会被阻塞。</p><p>假如在 <code>读已提交</code> 的隔离级别下，因为在查询前会先加读锁，而 T2 此时已对该行数据加了写锁，T1 事务的第二次查询将会被阻塞。</p><p>综上所述：</p><ol><li>事务的隔离性是通过锁的机制来实现的。</li><li>事务隔离性的不同本质上是锁机制的不同。</li></ol><h1 class=heading id=隔离性问题>隔离性问题
<a class=anchor href=#%e9%9a%94%e7%a6%bb%e6%80%a7%e9%97%ae%e9%a2%98>#</a></h1><h2 class=heading id=phantom-reads-幻读>Phantom Reads, 幻读
<a class=anchor href=#phantom-reads-%e5%b9%bb%e8%af%bb>#</a></h2><p>幻读是指，当一个事务 A 使用相同的查询条件进行两次范围查询时，在两次查询之间有其他事务插入或者删除了数据，导致事务 A 前后两次查询到的数据不一致。</p><p>From Wikipedia:</p><blockquote><p>A <em>phantom read</em> occurs when a transaction retrieves a set of rows twice and new rows are inserted into or removed from that set by another transaction that is committed in between.</p></blockquote><p><figure><div class=img-container style=--w:2424;--h:1116><img loading=lazy alt src=/archive/3_implement_isolation/Pasted%20image%2020230212161843.png width=2424 height=1116></div></figure></p><h2 class=heading id=non-repeatable-reads-不可重复读>Non-repeatable Reads, 不可重复读
<a class=anchor href=#non-repeatable-reads-%e4%b8%8d%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb>#</a></h2><p>不可重复读是指，一个事务 A 对某一行查询了两次，因为其他事务在两次查询之间对这一行数据进行了修改，导致事务 A 的两次查询结果不一致。</p><p>From Wikipedia:</p><blockquote><p>A <em>non-repeatable read</em> occurs when a transaction retrieves a row twice and that row is updated by another transaction that is committed in between.</p></blockquote><p><figure><div class=img-container style=--w:2426;--h:1158><img loading=lazy alt src=/archive/3_implement_isolation/Pasted%20image%2020230212162127.png width=2426 height=1158></div></figure></p><h2 class=heading id=drity-reads-脏读>Drity Reads, 脏读
<a class=anchor href=#drity-reads-%e8%84%8f%e8%af%bb>#</a></h2><p>脏读是指，一个事务读到了另一个事务未提交的修改。</p><p>From Wikipedia:</p><blockquote><p>A <em>dirty read</em> (aka <em>uncommitted dependency</em>) occurs when a transaction retrieves a row that has been updated by another transaction that is not yet committed.</p></blockquote><p><figure><div class=img-container style=--w:2334;--h:1250><img loading=lazy alt src=/archive/3_implement_isolation/Pasted%20image%2020230212162144.png width=2334 height=1250></div></figure></p><h2 class=heading id=dirty-write-脏写>Dirty Write, 脏写
<a class=anchor href=#dirty-write-%e8%84%8f%e5%86%99>#</a></h2><p>脏写是指，一个事务覆盖了另一个事务未提交的更新：</p><p><figure><div class=img-container style=--w:1428;--h:428><img loading=lazy alt src=/archive/3_implement_isolation/Pasted%20image%2020230212162527.png width=1428 height=428></div></figure></p><p>假设事务既不加读锁也不加写锁，那么 T1 对行数据的更新将会被 T2 对该行数据的写操作所覆盖。</p><p>不过，即便是 Read Uncommitted 隔离级别下，也不会出现这种情况。脏写意味着事务的原子性都被破坏了，所以一般不把它纳入隔离性相关问题的讨论范围内。</p><h1 class=heading id=总结>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h1><p>下表总结了各个事务隔离级别下可能遇到的问题：</p><div class=table-outer><table><thead><tr><th></th><th>Phantom Reads</th><th>Non-repeatable Reads</th><th>Dirty Reads</th></tr></thead><tbody><tr><td>Serializability</td><td>不可能</td><td>不可能</td><td>不可能</td></tr><tr><td>Repeatable Read</td><td>可能</td><td>不可能</td><td>不可能</td></tr><tr><td>Read Committed</td><td>可能</td><td>可能</td><td>不可能</td></tr><tr><td>Read Uncommitted</td><td>可能</td><td>可能</td><td>可能</td></tr></tbody></table></div><p>下表总结了各个事务隔离级别下对锁的使用情况：</p><div class=table-outer><table><thead><tr><th></th><th>Read Locks</th><th>Write Locks</th><th>Range Locks</th></tr></thead><tbody><tr><td>Serializability</td><td>加读锁并持有到事务结束</td><td>加写锁并持有到事务结束</td><td>加范围锁并持有到事务结束</td></tr><tr><td>Repeatable Read</td><td>加读锁并持有到事务结束</td><td>加写锁并持有到事务结束</td><td>不加范围锁</td></tr><tr><td>Read Committed</td><td>加读锁，查询结束后立即释放</td><td>加写锁并持有到事务结束</td><td>不加范围锁</td></tr><tr><td>Read Uncommitted</td><td>不加读锁</td><td>加写锁并持有到事务结束</td><td>不加范围锁</td></tr></tbody></table></div><h1 class=heading id=reference>Reference
<a class=anchor href=#reference>#</a></h1><ol><li><a href=http://icyfenix.cn/architect-perspective/general-architecture/transaction/local.html>本地事务 | 凤凰架构</a></li><li>《MySQL 技术内幕——InnoDB 存储引擎》</li><li><a href=https://en.wikipedia.org/wiki/Isolation_(database_systems)>Isolation (database systems) - Wikipedia</a></li></ol></div></article><div class=single-comments><script src=https://giscus.app/client.js data-repo data-repo-id data-category data-category-id data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><div class=single-pagination><hr><div class=flexnowrap><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text>←</div><div class=single-pagination-text><a href=/archive/2_cap_pacelc_theory/>CAP 理论和 PACELC 理论</a></div></div></div><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text><a href=/archive/4_implement_atomic_and_durable/>本地事务的原子性和持久性是如何实现的</a></div><div class=single-pagination-text>→</div></div></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>Powered by
<a href=https://gohugo.io/>Hugo</a>
and
<a href=https://github.com/tomfran/typo>tomfran/typo</a></p></footer></body><script src=/js/theme-switch.js></script><script defer src=/js/copy-code.js></script></html>