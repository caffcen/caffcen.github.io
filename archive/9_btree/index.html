<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://caffcen.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://caffcen.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://caffcen.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https://caffcen.github.io/android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=https://caffcen.github.io/apple-touch-icon.png><meta name=description content><title>深入理解 B-Tree | Lihang Liu's Homepage</title><link rel=canonical href=https://caffcen.github.io/archive/9_btree/><meta property="og:url" content="https://caffcen.github.io/archive/9_btree/"><meta property="og:site_name" content="Lihang Liu's Homepage"><meta property="og:title" content="深入理解 B-Tree"><meta property="og:description" content="从 2-3 搜索树出发深入剖析 B-Tree 的结构、特性和实现原理，解析其在数据库和文件系统中的应用"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="archive"><meta property="article:published_time" content="2023-03-18T16:03:56+08:00"><meta property="article:modified_time" content="2025-11-23T14:50:26-05:00"><link rel=stylesheet href=/assets/combined.min.57df9e7d692553f966cff4593ede6b53efb74da234876bacffeac774bd572e53.css media=all></head><body class=auto><div class=content><header><div class=header><h1 class=header-title><a href=https://caffcen.github.io/>Lihang Liu's Homepage</a></h1><div class=header-menu><p class=small><a href=/>/Home</a></p><p class=small><a href=/blog/>/Blog</a></p><p class=small><a href=/archive/>/Archive</a></p></div></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a><span class=breadcrumbs-separator>/</span><a href=/archive/>Archive</a><span class=breadcrumbs-separator>/</span>
<a href=/archive/9_btree/>深入理解 B-Tree</a></div><div><article><header class=single-intro-container><h1 class=single-title>深入理解 B-Tree</h1><p class=single-summary>从 2-3 搜索树出发深入剖析 B-Tree 的结构、特性和实现原理，解析其在数据库和文件系统中的应用</p><div class=single-subsummary><div><p class=single-date><time datetime=2023-03-18T16:03:56+08:00>March 18, 2023</time></p></div></div></header><div class=single-content><p>B 树是一种平衡多路搜索树，可以看做是对二叉搜索树（Binary Search Tree）的拓展。因为 B 树的自平衡以及允许一个节点存储多个值的特性，被广泛运用在数据库以及文件系统中，非常适用于存储大量数据。</p><p>要理解 B 树，最好的方式就是学习 2-3 搜索树——B 树的一种特例。</p><h1 class=heading id=1-2-3-搜索树-2-3-search-tree>1. 2-3 搜索树 (2-3 Search Tree)
<a class=anchor href=#1-2-3-%e6%90%9c%e7%b4%a2%e6%a0%91-2-3-search-tree>#</a></h1><h2 class=heading id=11-定义>1.1 定义
<a class=anchor href=#11-%e5%ae%9a%e4%b9%89>#</a></h2><p>2-3 搜索树是对二叉搜索树一种自然的扩充，二叉搜索树的任意一个节点只能存储一个 key、两个 links，但是 2-3 搜索树扩展了这一设定，2-3 搜索树允许存在以下两类节点：</p><ul><li>2-node：拥有一个 key 两个 links，2-node 和二叉搜索树中的节点完全等价，两个 links 分别指向左子树和右子树：<ul><li>左子树中的所有节点的 key 均『小于』当前 2-node 的 key；</li><li>右子树中的所有节点均『大于』当前 2-node 的 key。</li></ul></li><li>3-node：拥有两个 keys 三个 links，3 个 links 分别指向左子树、右子树和中间子树：<ul><li>左子树中的所有节点的 key 均『小于』当前 3-node 较小的 key；</li><li>右子树中的所有节点均『大于』当前 3-node 较大的 key；</li><li>中间子树中的所有节点均大于 3-node 较小的 key，且小于 3-node 较大的 key。</li></ul></li></ul><blockquote><p>这里大于、小于打引号是因为类型的大小关系往往是可以自定义的。</p></blockquote><blockquote><p>本文使用 key 表示存储数据的键，links 表示指向其他节点的引用，value 表示存储数据实际存储的值，在数据库以及文件系统中，value 可能是指向实际数据的指针。</p></blockquote><p><figure><div class=img-container style=--w:357;--h:269><img loading=lazy alt src=/archive/9_btree/Pasted%20image%2020230318143549.png width=357 height=269></div></figure></p><p>2-3 搜索树支持搜索、插入、删除操作，这些操作的最坏、平均时间复杂度均为 <code>O(longN)</code> ， <code>N</code> 为 2-3 搜索树的数据总量。同时，2-3 搜索树总是高度平衡的，所有叶子结点到根节点的距离总是一致的。</p><p>本文将会对搜索以及插入操作进行详细分析。</p><h2 class=heading id=12-搜索>1.2 搜索
<a class=anchor href=#12-%e6%90%9c%e7%b4%a2>#</a></h2><p>在 2-3 搜索树中搜索某一个 key 是否存在，和在二叉搜索树中几乎一致：</p><ol><li>判断 target 是否等于当前节点中任意 key，如果相等则返回当前节点；</li><li>如果当前节点是 2-node，那么将出现两种情况：<ol><li>如果 target 小于 2-node 的 key，则递归地向左子树进行搜索；</li><li>如果 target 大于 2-node 的 key，则递归地向右子树进行搜索；</li></ol></li><li>如果当前节点是 3-node，那么将出现三种情况：<ol><li>如果 target 小于 3-node 中最小的 key，则递归地向左子树进行搜索；</li><li>如果 target 大于 3-node 中最大的 key，则递归地对右子树进行搜索；</li><li>否则，递归搜索中间子树；</li></ol></li><li>如果当前节点是 <code>null</code> 说明，target 并未在 2-3 搜索树中，返回 <code>null</code></li></ol><p><figure><div class=img-container style=--w:1037;--h:684><img loading=lazy alt src=/archive/9_btree/Pasted%20image%2020230318145503.png width=1037 height=684></div></figure></p><h2 class=heading id=13-插入>1.3 插入
<a class=anchor href=#13-%e6%8f%92%e5%85%a5>#</a></h2><p>向 2-3 搜索树中插入一对 key-value 是一个相较于二叉搜索树的插入算法更为复杂的操作。2-3 搜索树能够保证任何情况下（无论输入数据插入的顺序是怎样的）都是高度平衡的特性和 2-3 搜索树的插入算法是紧密相关的。</p><p>插入算法总是从 <code>root</code> 节点开始搜索，搜索到叶子结点为止（搜索算法 1.2 小节已经讨论过了），再根据叶子结点以及插入 key-value 键值对和叶子结点中的 key 的比较情况来进行操作的。之后的讨论都是基于『已经搜索到需要往哪个叶子节点进行插入』进行讨论。</p><h3 class=heading id=131-插入到-2-node-中>1.3.1 插入到 2-node 中
<a class=anchor href=#131-%e6%8f%92%e5%85%a5%e5%88%b0-2-node-%e4%b8%ad>#</a></h3><p>如果待插入的节点是一个 2-node，只需要将其变为一个 3-node 即可：</p><p><figure><div class=img-container style=--w:423;--h:437><img loading=lazy alt src=/archive/9_btree/Pasted%20image%2020230318150451.png width=423 height=437></div></figure></p><p>当往一个 2-node 中插入一个节点后，所有叶子结点都还位于它原本的位置上，没有任何节点的位置发生变化，也没有新增任何的节点，所以整棵树在插入操作后依然是高度平衡的，所有叶子结点到根节点的距离都没有发生改变。</p><h3 class=heading id=132-插入到单独的-3-node-中>1.3.2 插入到单独的 3-node 中
<a class=anchor href=#132-%e6%8f%92%e5%85%a5%e5%88%b0%e5%8d%95%e7%8b%ac%e7%9a%84-3-node-%e4%b8%ad>#</a></h3><p>如果整棵树只有 <code>root</code> 这一个节点，同时 <code>root</code> 是一个 3-node，那么我们和面对 2-node 时是一样的，我们将待插入的 key 插入其中，让其暂时将其变为一个 4-node（拥有 3 个 keys 和 4 个 links）。然后，我们将这一个 4-node 分裂为 3 个 2-node：</p><ol><li>我们将 3 个 key 中大小位于中间位置的 key-value 对向上分裂，成为当前 2-3 搜索树的 <code>new_root</code> ；</li><li>将 3 个 key 中最小的变为 <code>new_root</code> 的左子树；</li><li>将 3 个 key 中最大的变为 <code>new_root</code> 的右子树</li></ol><p><figure><div class=img-container style=--w:321;--h:323><img loading=lazy alt src=/archive/9_btree/Pasted%20image%2020230318151238.png width=321 height=323></div></figure></p><p>当往一个是 3-node 的 <code>root</code> 中插入一组数据后，整棵树的高度增加了 1（这也是 2-3 搜索树高度增加的唯一情况，2-3 搜索树的高度增加依赖于新插入的数据使得 <code>root</code> 进行分裂），原来的叶子节点到新 <code>root</code> 的距离都增加了 1，所有叶子结点到 <code>root</code> 的距离还是相等的，因此 2-3 搜索树在这种情况下依然是高度平衡的。</p><h3 class=heading id=133-往一个父节点是-2-node-的-3-node-插入数据>1.3.3 往一个父节点是 2-node 的 3-node 插入数据
<a class=anchor href=#133-%e5%be%80%e4%b8%80%e4%b8%aa%e7%88%b6%e8%8a%82%e7%82%b9%e6%98%af-2-node-%e7%9a%84-3-node-%e6%8f%92%e5%85%a5%e6%95%b0%e6%8d%ae>#</a></h3><p>当往一个 3-node 节点插入数据后，和上一小节一样，我们需要将其短暂变为一个 4-node，之后变成 3 个 2-node，并将顺序大小排中间的节点向上分裂。</p><p>因为该叶子节点的父节点是个 2-node，我们只需要将其变为一个 3-node 即可，剩下的未向上分裂的『最小』、『最大』节点变成分裂上去的 key 的左右孩子节点即可：</p><p><figure><div class=img-container style=--w:519;--h:660><img loading=lazy alt src=/archive/9_btree/Pasted%20image%2020230318152424.png width=519 height=660></div></figure></p><p>在这种情况下，从结果来看仅仅是一个中间节点从 2-node 变成了 3-node，没有新增任何节点，树的高度保持一致，因此在这种情况下 2-3 搜索树依然是高度平衡的。</p><h3 class=heading id=134-往一个父节点是-3-node-的-3-node-插入数据>1.3.4 往一个父节点是 3-node 的 3-node 插入数据
<a class=anchor href=#134-%e5%be%80%e4%b8%80%e4%b8%aa%e7%88%b6%e8%8a%82%e7%82%b9%e6%98%af-3-node-%e7%9a%84-3-node-%e6%8f%92%e5%85%a5%e6%95%b0%e6%8d%ae>#</a></h3><p>当向一个 3-node 叶子节点插入数据后，我们将其变为一个 4-node 后分裂成 3 个 2-node，并把大小排在中间的 2-node 向上分裂。</p><p>和 1.3.3 节不同的是，当前叶子节点的父节点是一个 3-node。那么，我们只能把向上分裂的 key-value 对加入其中，将其也变成一个暂时的 4-node，并分出 3 个 2-node，再将大小排中间的 key-value 对继续向上抛。</p><p>相信你此时一定能看出插入算法是如何递归地执行的了。我们将分裂得到的大小位于中间的 2-node 向上抛给父节点，如果父节点也需要进行分裂，那么递归地分裂、向上抛，直到某个父节点是一个 2-node，或者递归到 <code>root</code> 节点时 <code>root</code> 是一个 3-node，递归的步骤才会终止：</p><p><figure><div class=img-container style=--w:516;--h:942><img loading=lazy alt src=/archive/9_btree/Pasted%20image%2020230318153603.png width=516 height=942></div></figure></p><p>我们再来看看在这种情况下 2-3 搜索树是如何保持高度平衡的，只需要考虑两种情况：</p><ol><li><code>root</code> 是一个 2-node，即便从叶子结点一路向上分裂，分裂到 <code>root</code> ，因为 <code>root</code> 是一个 2-node，那么情况将和 1.3.1 是一模一样的，我们只需要将 <code>root</code> 变为一个 3-node 即可。整棵树的高度没有发生任何变化，即便中间的路径可能发生了改变，但所有叶子结点在插入后还是在叶子结点的位置上，它们到根节点的距离依然是相同的。</li><li><code>root</code> 是一个 3-node，那么如果递归到最后需要向 <code>root</code> 进行插入，情况就和 1.3.2 一样，整棵树的高度增加 1，所有叶子结点到根节点的距离都加 1，那么 2-3 搜索树依然是高度平衡的。</li></ol><p>也就是说，在这种情况下，2-3 搜索树的高度依然是平衡的。</p><h2 class=heading id=14-2-3-搜索树插入算法总结>1.4 2-3 搜索树插入算法总结
<a class=anchor href=#14-2-3-%e6%90%9c%e7%b4%a2%e6%a0%91%e6%8f%92%e5%85%a5%e7%ae%97%e6%b3%95%e6%80%bb%e7%bb%93>#</a></h2><p>我们可以总结出 2-3 搜索树插入算法拥有这样的局部特性以及全局特性：</p><ol><li>只有从叶子结点开始，沿着父子关系的路径往上，一直到根节点结束的这一条局部路径范围上的节点会受到影响，插入算法的影响范围总是局部的。</li><li>局部范围内的影响并不会破坏 2-3 搜索树的全局特性：2-3 搜索树在任意时刻总是高度平衡的，所有叶子结点到根节点的距离都相等。</li><li>2-3 搜索树只有当往一个类型是 3-node 的 <code>root</code> 节点插入时，才会导致导致整棵树的高度增加。</li><li>二叉搜索树的高度是往下增加的，而 2-3 搜索树的高度是往上增加的。</li></ol><p>我们知道，二叉搜索树的高度和空间结构严重依赖于输入数据的插入顺序，在最坏情况下（比如顺序插入一组已经排好序的数据）的搜索、插入、删除时间复杂度将变成 <code>O(N)</code> ，而 2-3 搜索树因为它的分裂以及局部变更等特点，使得在任意情况下，插入、搜索、删除的最坏时间复杂度均为 <code>O(logN)</code> 。</p><h1 class=heading id=2-b-tree>2. B-Tree
<a class=anchor href=#2-b-tree>#</a></h1><p>B 树是对 2-3 搜索树的泛化，反过来说就是，2-3 搜索树是一种 3 阶 B 树。</p><h2 class=heading id=21-b-tree-定义>2.1 B-Tree 定义
<a class=anchor href=#21-b-tree-%e5%ae%9a%e4%b9%89>#</a></h2><p>一个 <code>m</code> 阶 B 树可以看做是 2-3 搜索树的一种泛化，它拥有如下特点：</p><ol><li>每个节点最多有 <code>m</code> 个子节点（ <code>m</code> 个 links）。</li><li>每个节点最多有 <code>m - 1</code> 个键值对（ <code>m - 1</code> 个 key-value pairs）。</li><li>每个内部节点至少有 <code>⌈m/2⌉</code> 个子节点。</li><li>根节点必须至少有 2 个键值对（两个 key-value pairs）。</li><li>所有叶节点在同一级别上出现。</li><li>一个具有 <code>k</code> 个子节点的非叶节点包含 <code>k-1</code> 个键值对。</li><li>关键字（keys）集合分布在整颗树中。</li><li>任何一个关键字（key）出现且只出现在一个结点中。</li><li>搜索有可能在非叶子结点结束 (树中所有结点都存储数据，与 B+树这一点不同)。</li><li>其搜索性能等价于在关键字全集内做一次二分查找（最坏时间复杂度 <code>O(logN</code> ）。</li></ol><p>B 树的搜索、插入和删除算法本质上和 2-3 搜索树的搜索、插入、删除算法是一样的，它们的最坏时间复杂度都是 <code>O(logN)</code> 。学懂了 2-3 搜索树，你也就懂了 B 树的各种操作是如何执行的了。</p><h1 class=heading id=reference>Reference
<a class=anchor href=#reference>#</a></h1><ol><li><a href=https://en.wikipedia.org/wiki/2%E2%80%933_tree>2–3 tree - Wikipedia</a></li><li><a href=https://en.wikipedia.org/wiki/B-tree>B-tree - Wikipedia</a></li><li>《MySQL 技术内幕——InnoDB 存储引擎》</li><li>《Algorithms, 4th Edition》by Robert Sedgewick, Kevin Wayne</li></ol></div></article><div class=single-comments><script src=https://giscus.app/client.js data-repo data-repo-id data-category data-category-id data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><div class=single-pagination><hr><div class=flexnowrap><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text>←</div><div class=single-pagination-text><a href=/archive/8_leetcode_note_4_binary_search/>LeetCode 笔记 4：Binary Search 的5种变体应用</a></div></div></div><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text><a href=/archive/10_b+tree/>深入理解 B+ Tree</a></div><div class=single-pagination-text>→</div></div></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>Powered by
<a href=https://gohugo.io/>Hugo</a>
and
<a href=https://github.com/tomfran/typo>tomfran/typo</a></p></footer></body><script src=/js/theme-switch.js></script><script defer src=/js/copy-code.js></script></html>