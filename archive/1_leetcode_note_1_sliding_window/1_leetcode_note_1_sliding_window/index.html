<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>LeetCode 笔记 1：Sliding Window 题目总结 | Lihang Liu&#39;s Homepage</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="什么是滑动窗口算法 先用一个简单的题目来说明什么是滑动窗口算法。
最直接的思路就是，对于每个给定的 index，计算出从该 index 开始的一个最小 subarray，其和大于 target:
int minLength = Integer.MAX_VALUE; for (int i = 0; i &lt; nums.length; &#43;&#43;i) { int sum = 0; for (int j = i; j &lt; nums.length; &#43;&#43;j) { sum &#43;= nums[j]; if (sum &gt; target) { minLength = Math.min(minLength, j - i &#43; 1); } break; } } 这个算法的问题就在于，相邻的 index 之间，存在着重合的计算。
解决办法就是维护一个滑动窗口，这样就能够解决重复计算的问题了：
class Solution { public int minSubArrayLen(int target, int[] nums) { int res = Integer.">
    <meta name="generator" content="Hugo 0.125.7">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/archive/1_leetcode_note_1_sliding_window/1_leetcode_note_1_sliding_window/">
    

    <meta property="og:url" content="http://localhost:1313/archive/1_leetcode_note_1_sliding_window/1_leetcode_note_1_sliding_window/">
  <meta property="og:site_name" content="Lihang Liu&#39;s Homepage">
  <meta property="og:title" content="LeetCode 笔记 1：Sliding Window 题目总结">
  <meta property="og:description" content="什么是滑动窗口算法 先用一个简单的题目来说明什么是滑动窗口算法。
最直接的思路就是，对于每个给定的 index，计算出从该 index 开始的一个最小 subarray，其和大于 target:
int minLength = Integer.MAX_VALUE; for (int i = 0; i &lt; nums.length; &#43;&#43;i) { int sum = 0; for (int j = i; j &lt; nums.length; &#43;&#43;j) { sum &#43;= nums[j]; if (sum &gt; target) { minLength = Math.min(minLength, j - i &#43; 1); } break; } } 这个算法的问题就在于，相邻的 index 之间，存在着重合的计算。
解决办法就是维护一个滑动窗口，这样就能够解决重复计算的问题了：
class Solution { public int minSubArrayLen(int target, int[] nums) { int res = Integer.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="archive">
    <meta property="article:published_time" content="2023-01-08T15:14:33+08:00">
    <meta property="article:modified_time" content="2023-01-08T15:14:33+08:00">

  <meta itemprop="name" content="LeetCode 笔记 1：Sliding Window 题目总结">
  <meta itemprop="description" content="什么是滑动窗口算法 先用一个简单的题目来说明什么是滑动窗口算法。
最直接的思路就是，对于每个给定的 index，计算出从该 index 开始的一个最小 subarray，其和大于 target:
int minLength = Integer.MAX_VALUE; for (int i = 0; i &lt; nums.length; &#43;&#43;i) { int sum = 0; for (int j = i; j &lt; nums.length; &#43;&#43;j) { sum &#43;= nums[j]; if (sum &gt; target) { minLength = Math.min(minLength, j - i &#43; 1); } break; } } 这个算法的问题就在于，相邻的 index 之间，存在着重合的计算。
解决办法就是维护一个滑动窗口，这样就能够解决重复计算的问题了：
class Solution { public int minSubArrayLen(int target, int[] nums) { int res = Integer.">
  <meta itemprop="datePublished" content="2023-01-08T15:14:33+08:00">
  <meta itemprop="dateModified" content="2023-01-08T15:14:33+08:00">
  <meta itemprop="wordCount" content="418"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="LeetCode 笔记 1：Sliding Window 题目总结">
<meta name="twitter:description" content="什么是滑动窗口算法 先用一个简单的题目来说明什么是滑动窗口算法。
最直接的思路就是，对于每个给定的 index，计算出从该 index 开始的一个最小 subarray，其和大于 target:
int minLength = Integer.MAX_VALUE; for (int i = 0; i &lt; nums.length; &#43;&#43;i) { int sum = 0; for (int j = i; j &lt; nums.length; &#43;&#43;j) { sum &#43;= nums[j]; if (sum &gt; target) { minLength = Math.min(minLength, j - i &#43; 1); } break; } } 这个算法的问题就在于，相邻的 index 之间，存在着重合的计算。
解决办法就是维护一个滑动窗口，这样就能够解决重复计算的问题了：
class Solution { public int minSubArrayLen(int target, int[] nums) { int res = Integer.">

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Lihang Liu&#39;s Homepage
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Archives
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">LeetCode 笔记 1：Sliding Window 题目总结</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2023-01-08T15:14:33+08:00">January 8, 2023</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h1 id="什么是滑动窗口算法">什么是滑动窗口算法</h1>
<p>先用一个简单的<a href="https://leetcode.com/problems/minimum-size-subarray-sum/">题目</a>来说明什么是滑动窗口算法。</p>
<p><img src="./Pasted%20image%2020230108160856.png" alt=""></p>
<p>最直接的思路就是，对于每个给定的 index，计算出从该 index 开始的一个最小 subarray，其和大于 <code>target</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> minLength <span style="color:#f92672">=</span> Integer.<span style="color:#a6e22e">MAX_VALUE</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> nums.<span style="color:#a6e22e">length</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> sum <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i; j <span style="color:#f92672">&lt;</span> nums.<span style="color:#a6e22e">length</span>; <span style="color:#f92672">++</span>j) {
</span></span><span style="display:flex;"><span>        sum <span style="color:#f92672">+=</span> nums<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (sum <span style="color:#f92672">&gt;</span> target) {
</span></span><span style="display:flex;"><span>            minLength <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">min</span>(minLength, j <span style="color:#f92672">-</span> i <span style="color:#f92672">+</span> 1);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个算法的问题就在于，相邻的 index 之间，存在着重合的计算。</p>
<p>解决办法就是维护一个滑动窗口，这样就能够解决重复计算的问题了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">minSubArrayLen</span>(<span style="color:#66d9ef">int</span> target, <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> Integer.<span style="color:#a6e22e">MAX_VALUE</span>, sum <span style="color:#f92672">=</span> 0, windowStart <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> windowEnd <span style="color:#f92672">=</span> 0; windowEnd <span style="color:#f92672">&lt;</span> nums.<span style="color:#a6e22e">length</span>; <span style="color:#f92672">++</span>windowEnd) {
</span></span><span style="display:flex;"><span>            sum <span style="color:#f92672">+=</span> nums<span style="color:#f92672">[</span>windowEnd<span style="color:#f92672">]</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span> (sum <span style="color:#f92672">&gt;=</span> target) {
</span></span><span style="display:flex;"><span>                res <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">min</span>(res, windowEnd <span style="color:#f92672">-</span> windowStart <span style="color:#f92672">+</span> 1);
</span></span><span style="display:flex;"><span>                sum <span style="color:#f92672">-=</span> nums<span style="color:#f92672">[</span>windowStart<span style="color:#f92672">++]</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res <span style="color:#f92672">==</span> Integer.<span style="color:#a6e22e">MAX_VALUE</span> <span style="color:#f92672">?</span> 0 : res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>每次迭代，将滑动窗口的大小扩大 <code>1</code>，并将 <code>nums[windowEnd]</code> 加到子数组和 <code>sum</code> 中。</li>
<li>当子数组和 <code>sum &gt; target</code> 时，更新结果</li>
<li>因为当前子数组和已经比 <code>target</code> 大，为求得最优解，我们缩小滑动窗口大小：将滑动窗口的左端的值 <code>nums[windowStart]</code> 从 <code>sum</code> 中减去，并将窗口左端点下标加一</li>
</ul>
<p>总的来说，滑动窗口算法是基于迭代的算法，其使用包括如下步骤：</p>
<ul>
<li>每次迭代扩大滑动窗口的大小：<code>++windowEnd</code></li>
<li>更新窗口左端点 <code>windowStart</code>，使窗口范围的数据是满足题目要求的</li>
<li>更新结果</li>
</ul>
<h1 id="使用到-map-的题目类型">使用到 Map 的题目类型</h1>
<p>有些题目需要使用哈希表来记录滑动窗口中数据出现的次数，典型的题目为：<a href="https://leetcode.com/problems/permutation-in-string/">567. Permutation in String</a></p>
<p><img src="Pasted%20image%2020230108163150.png" alt=""></p>
<p>这类题目的思路都很接近：</p>
<ul>
<li>用一个 Map（<code>charCntMap</code>） 来存储目标字符串每个字符的频率</li>
<li>用一个 <code>int</code> （<code>cnt</code>）来存储 Map 的大小（<code>charCntMap.size()</code>），即目标字符串（当前题目是 <code>s1</code>）有多少个不重复的字符</li>
<li>维护一个滑动窗口，每次扩大窗口大小时，如果当前字符出现在 Map 中，将其频率减一</li>
<li>当该字符的频率变为 0 时，将 <code>cnt</code> 减一；当 <code>cnt == 0</code> 时，说明目标数组所有字符已经出现在了当前的滑动窗口中，这时更新结果（该题目返回 <code>true</code>）</li>
<li>当滑动窗口非法时（该题目是<code>窗口大小 &gt; s1.length()</code>），将窗口左端点的 <code>index</code> 加一（<code>windowStart + 1</code>）；同时：
<ul>
<li>如果 Map 存储的该字符出现的频率为 0，则 <code>++cnt</code>，这表明了当前的滑动窗口无法存储目标字符串（<code>s1</code>）所有的字符了</li>
<li>将 Map 存储的该字符的频率加一</li>
</ul>
</li>
</ul>
<p>Java 实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">checkInclusion</span>(String s1, String s2) {
</span></span><span style="display:flex;"><span>        Map<span style="color:#f92672">&lt;</span>Character, Integer<span style="color:#f92672">&gt;</span> charCntMap <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">char</span> ch : s1.<span style="color:#a6e22e">toCharArray</span>()) {
</span></span><span style="display:flex;"><span>            charCntMap.<span style="color:#a6e22e">put</span>(ch, charCntMap.<span style="color:#a6e22e">getOrDefault</span>(ch, 0) <span style="color:#f92672">+</span> 1);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> windowStart <span style="color:#f92672">=</span> 0, cnt <span style="color:#f92672">=</span> charCntMap.<span style="color:#a6e22e">size</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> windowEnd <span style="color:#f92672">=</span> 0; windowEnd <span style="color:#f92672">&lt;</span> s2.<span style="color:#a6e22e">length</span>(); <span style="color:#f92672">++</span>windowEnd) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> ch <span style="color:#f92672">=</span> s2.<span style="color:#a6e22e">charAt</span>(windowEnd);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (charCntMap.<span style="color:#a6e22e">containsKey</span>(ch)) {
</span></span><span style="display:flex;"><span>                charCntMap.<span style="color:#a6e22e">put</span>(ch, charCntMap.<span style="color:#a6e22e">get</span>(ch) <span style="color:#f92672">-</span> 1);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (charCntMap.<span style="color:#a6e22e">get</span>(ch) <span style="color:#f92672">==</span> 0) {
</span></span><span style="display:flex;"><span>                    <span style="color:#f92672">--</span>cnt;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (windowEnd <span style="color:#f92672">-</span> windowStart <span style="color:#f92672">+</span> 1 <span style="color:#f92672">&gt;</span> s1.<span style="color:#a6e22e">length</span>()) {
</span></span><span style="display:flex;"><span>                ch <span style="color:#f92672">=</span> s2.<span style="color:#a6e22e">charAt</span>(windowStart<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (charCntMap.<span style="color:#a6e22e">containsKey</span>(ch)) {
</span></span><span style="display:flex;"><span>                    charCntMap.<span style="color:#a6e22e">put</span>(ch, charCntMap.<span style="color:#a6e22e">get</span>(ch) <span style="color:#f92672">+</span> 1);
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> (charCntMap.<span style="color:#a6e22e">get</span>(ch) <span style="color:#f92672">==</span> 1) {
</span></span><span style="display:flex;"><span>                        <span style="color:#f92672">++</span>cnt;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (cnt <span style="color:#f92672">==</span> 0) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>类似的题目有：</p>
<ul>
<li><a href="https://leetcode.com/problems/contains-duplicate-ii/">219. Contains Duplicate II</a></li>
<li><a href="https://leetcode.com/problems/fruit-into-baskets/">904. Fruit Into Baskets</a></li>
</ul>
<h1 id="使用到-set-的题目类型">使用到 Set 的题目类型</h1>
<p>滑动窗口算法有些时候需要配合 HashSet 使用，如 <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">3. Longest Substring Without Repeating Characters</a>:</p>
<p><img src="Pasted%20image%2020230108165249.png" alt=""></p>
<p>思路为：</p>
<ul>
<li>维护一个 <code>Set</code> 来存储出现在滑动窗口中的元素</li>
<li>维护一个滑动窗口，每次迭代的时候检查当前的滑动窗口是否合法，即检查 <code>Set</code> 是否有保存窗口右端点对应的元素；窗口非法则说明当前窗口过大，需要缩小窗口大小</li>
<li>窗口合法时更新结果值</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">lengthOfLongestSubstring</span>(String s) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> 0, windowStart <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Set<span style="color:#f92672">&lt;</span>Character<span style="color:#f92672">&gt;</span> set <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashSet<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> windowEnd <span style="color:#f92672">=</span> 0; windowEnd <span style="color:#f92672">&lt;</span> s.<span style="color:#a6e22e">length</span>(); <span style="color:#f92672">++</span>windowEnd) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">char</span> ch <span style="color:#f92672">=</span> s.<span style="color:#a6e22e">charAt</span>(windowEnd);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (set.<span style="color:#a6e22e">contains</span>(ch)) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">while</span> (set.<span style="color:#a6e22e">contains</span>(ch)) {
</span></span><span style="display:flex;"><span>                    set.<span style="color:#a6e22e">remove</span>(s.<span style="color:#a6e22e">charAt</span>(windowStart<span style="color:#f92672">++</span>));
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>             set.<span style="color:#a6e22e">add</span>(ch);
</span></span><span style="display:flex;"><span>             res <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">max</span>(res, windowEnd <span style="color:#f92672">-</span> windowStart <span style="color:#f92672">+</span> 1);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="其他典型-sliding-window-题目">其他典型 Sliding window 题目</h1>
<ul>
<li><a href="https://leetcode.com/problems/longest-repeating-character-replacement/">424. Longest Repeating Character Replacement</a></li>
<li><a href="">643. Maximum Average Subarray I</a></li>
<li><a href="https://leetcode.com/problems/longest-mountain-in-array/">845. Longest Mountain in Array</a></li>
<li><a href="https://leetcode.com/problems/max-consecutive-ones-iii/">1004. Max Consecutive Ones III</a></li>
<li><a href="https://leetcode.com/problems/grumpy-bookstore-owner/">1052. Grumpy Bookstore Owner</a></li>
<li><a href="https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/">1658. Minimum Operations to Reduce X to Zero</a></li>
</ul>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  Lihang Liu's Homepage 2024 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
