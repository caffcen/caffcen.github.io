<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://caffcen.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://caffcen.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://caffcen.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https://caffcen.github.io/android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=https://caffcen.github.io/apple-touch-icon.png><meta name=description content><title>CAP 理论和 PACELC 理论 | Lihang Liu's Homepage</title><link rel=canonical href=https://caffcen.github.io/archive/2_cap_pacelc_theory/><meta property="og:url" content="https://caffcen.github.io/archive/2_cap_pacelc_theory/"><meta property="og:site_name" content="Lihang Liu's Homepage"><meta property="og:title" content="CAP 理论和 PACELC 理论"><meta property="og:description" content="详解分布式系统中的 CAP 理论和 PACELC 理论，分析一致性、可用性和分区容错性之间的权衡"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="archive"><meta property="article:published_time" content="2023-02-04T15:59:55+08:00"><meta property="article:modified_time" content="2025-11-23T14:50:26-05:00"><link rel=stylesheet href=/assets/combined.min.57df9e7d692553f966cff4593ede6b53efb74da234876bacffeac774bd572e53.css media=all></head><body class=auto><div class=content><header><div class=header><h1 class=header-title><a href=https://caffcen.github.io/>Lihang Liu's Homepage</a></h1><div class=header-menu><p class=small><a href=/>/Home</a></p><p class=small><a href=/blog/>/Blog</a></p><p class=small><a href=/archive/>/Archive</a></p></div></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a><span class=breadcrumbs-separator>/</span><a href=/archive/>Archive</a><span class=breadcrumbs-separator>/</span>
<a href=/archive/2_cap_pacelc_theory/>CAP 理论和 PACELC 理论</a></div><div><article><header class=single-intro-container><h1 class=single-title>CAP 理论和 PACELC 理论</h1><p class=single-summary>详解分布式系统中的 CAP 理论和 PACELC 理论，分析一致性、可用性和分区容错性之间的权衡</p><div class=single-subsummary><div><p class=single-date><time datetime=2023-02-04T15:59:55+08:00>February 4, 2023</time></p></div></div></header><div class=single-content><h1 class=heading id=cap-理论>CAP 理论
<a class=anchor href=#cap-%e7%90%86%e8%ae%ba>#</a></h1><p>CAP 理论阐述的是，一个分布式系统不可能同时满足<strong>一致性</strong>（consistency）、<strong>可用性</strong>（availability）和<strong>分区容错性</strong>（partition tolerance）这 3 个特性，至多只能满足其中的两个，实际上要么满足 CP（一致性+分区容错性），要么满足 AP（可用性+分区容错性）。</p><h2 class=heading id=一致性-consistency>一致性 consistency
<a class=anchor href=#%e4%b8%80%e8%87%b4%e6%80%a7-consistency>#</a></h2><p>读请求（read request）总是能得到最新的值，也就是说，在任何时间，分布式系统中所有节点对于任一一个值存储的都是相同版本。这便是一致性。</p><h2 class=heading id=可用性-availability>可用性 availability
<a class=anchor href=#%e5%8f%af%e7%94%a8%e6%80%a7-availability>#</a></h2><p>可用性意思是，每一个请求都能够收到非异常返回，但并不保证请求拿到的值就是最新的值。</p><h2 class=heading id=分区容错性-partition-tolerance>分区容错性 partition tolerance
<a class=anchor href=#%e5%88%86%e5%8c%ba%e5%ae%b9%e9%94%99%e6%80%a7-partition-tolerance>#</a></h2><p>分区（partition）意味着分布式系统的任意一对节点出现了通讯中断。而分区容错性则要求，即便在内部节点出现故障时，整个系统依然能够运行，部分节点之间的网络异常不会导致整个系统的失效。</p><h2 class=heading id=分区容错的必要性>分区容错的必要性
<a class=anchor href=#%e5%88%86%e5%8c%ba%e5%ae%b9%e9%94%99%e7%9a%84%e5%bf%85%e8%a6%81%e6%80%a7>#</a></h2><p>分区容错性是一个分布式系统不可或缺的特性，因为任何系统的任意节点之间都有可能出现网络故障。当一个系统出现分区，部分内部节点无法访问彼此的时候，必须要在一致性和可用性之间做出选择：是为了保障服务依然可用而损害一致性呢，又或者是保障一致性而拒绝服务？</p><p><figure><div class=img-container style=--w:568;--h:404><img loading=lazy alt src=/archive/2_cap_pacelc_theory/Drawing%202023-02-04%2015.26.25.excalidraw.png width=568 height=404></div></figure></p><p>举个例子，考虑上图的情况，假设有两个节点 A 和 B 之间发生了分区的情况，当用户先向节点 B 给 X 变量写一个值后，从节点 A 读取 X 变量，那么系统面临着两个选择：</p><ul><li>它可以选择其中一个请求返回失败，但这样就损害了可用性</li><li>它可以处理两个请求，但是针对读请求返回一个旧的值，但这样就破坏了一致性</li></ul><p>因此，我们能够得出结论：</p><blockquote><p>实际上，CAP 理论要求一个分布式系统在内部节点发生网络故障，分区错误发生时，要么选择保留一致性，要么选择维护可用性。</p></blockquote><h1 class=heading id=pacelc-理论>PACELC 理论
<a class=anchor href=#pacelc-%e7%90%86%e8%ae%ba>#</a></h1><p>PACELC 理论是 CAP 理论的补充，以下这段文字摘抄自维基百科 <a href=https://en.wikipedia.org/wiki/PACELC_theorem>PACELC theorem - Wikipedia</a>，它指出了 PACELC 这几个字母的缩写是怎么来的：</p><blockquote><p>In <a href=https://en.wikipedia.org/wiki/Theoretical_computer_science title="Theoretical computer science">theoretical computer science</a>, the <strong>PACELC theorem</strong> is an extension to the <a href=https://en.wikipedia.org/wiki/CAP_theorem title="CAP theorem">CAP theorem</a>. It states that in case of network partitioning (P) in a distributed computer system, one has to choose between availability (A) and consistency (C) (as per the CAP theorem), but else (E), even when the system is running normally in the absence of partitions, one has to choose between latency (L) and consistency (C).</p></blockquote><p>一个分布式系统也不会一直面临着分区网络故障，当内部节点之间不存在通讯问题时，一致性和可用性都是可以得到保证的，特别是可用性基本不会出现问题。</p><p>不过，为了保证一致性，数据在节点之间进行复制时会需要一定的时间，这部分复制时间可能会给用户请求带来不小的延迟，因此，在一致性和延迟（latency）之间有存在利弊权衡：</p><ol><li>系统可以牺牲一致性，不等待值在所有节点写入完成；或者</li><li>保证强一致性，但请求需要等待值在各个节点完成写入后才能够收到返回</li></ol><h2 class=heading id=基于-pacelc-理论的系统分类>基于 PACELC 理论的系统分类
<a class=anchor href=#%e5%9f%ba%e4%ba%8e-pacelc-%e7%90%86%e8%ae%ba%e7%9a%84%e7%b3%bb%e7%bb%9f%e5%88%86%e7%b1%bb>#</a></h2><p>我们可以根据系统是否发生了分区错误、分区错误发生时选择维持哪种特性（C 或 A），以及未发生分区错误时系统是否想要保持强一致性，来给分布式系统做如下 4 种分类：</p><div class=table-outer><table><thead><tr><th>分区错误发生时</th><th>系统没有分区错误</th></tr></thead><tbody><tr><td>AP</td><td>EL</td></tr><tr><td>AP</td><td>EC</td></tr><tr><td>CP</td><td>EL</td></tr><tr><td>CP</td><td>EC</td></tr></tbody></table></div><p>其中的 E 表示 else，举例来说，AP/EL 系统在分区错误发生时希望维持系统的可用性，除此之外也就是内部节点没有网络故障时，希望保持低延迟。</p><p>一般来说，一个系统要么希望是高可用、低延迟的，要么总是要求强一致性，因此大多数系统都落到了 AP/EL 或 CP/EC 这两个类别之中。</p></div></article><div class=single-comments><script src=https://giscus.app/client.js data-repo data-repo-id data-category data-category-id data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><div class=single-pagination><hr><div class=flexnowrap><div class=single-pagination-prev></div><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text><a href=/archive/3_implement_isolation/>本地事务的隔离性是如何实现的</a></div><div class=single-pagination-text>→</div></div></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>Powered by
<a href=https://gohugo.io/>Hugo</a>
and
<a href=https://github.com/tomfran/typo>tomfran/typo</a></p></footer></body><script src=/js/theme-switch.js></script><script defer src=/js/copy-code.js></script></html>