<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https://caffcen.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://caffcen.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://caffcen.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https://caffcen.github.io/android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=https://caffcen.github.io/apple-touch-icon.png><meta name=description content><title>LeetCode 笔记 3：Construct Binary Tree from xxx Traversal | Lihang Liu's Homepage</title><link rel=canonical href=https://caffcen.github.io/archive/6_leetcode_note_3_construct_bst_from_xxx_traversal/><meta property="og:url" content="https://caffcen.github.io/archive/6_leetcode_note_3_construct_bst_from_xxx_traversal/"><meta property="og:site_name" content="Lihang Liu's Homepage"><meta property="og:title" content="LeetCode 笔记 3：Construct Binary Tree from xxx Traversal"><meta property="og:description" content="分析如何从二叉树的前序、中序和后序遍历序列中重建原始二叉树的算法与实现"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="archive"><meta property="article:published_time" content="2023-02-26T16:03:22+08:00"><meta property="article:modified_time" content="2025-11-23T14:50:26-05:00"><link rel=stylesheet href=/assets/combined.min.57df9e7d692553f966cff4593ede6b53efb74da234876bacffeac774bd572e53.css media=all></head><body class=auto><div class=content><header><div class=header><h1 class=header-title><a href=https://caffcen.github.io/>Lihang Liu's Homepage</a></h1><div class=header-menu><p class=small><a href=/>/Home</a></p><p class=small><a href=/blog/>/Blog</a></p><p class=small><a href=/archive/>/Archive</a></p></div></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a><span class=breadcrumbs-separator>/</span><a href=/archive/>Archive</a><span class=breadcrumbs-separator>/</span>
<a href=/archive/6_leetcode_note_3_construct_bst_from_xxx_traversal/>LeetCode 笔记 3：Construct Binary Tree from xxx Traversal</a></div><div><article><header class=single-intro-container><h1 class=single-title>LeetCode 笔记 3：Construct Binary Tree from xxx Traversal</h1><p class=single-summary>分析如何从二叉树的前序、中序和后序遍历序列中重建原始二叉树的算法与实现</p><div class=single-subsummary><div><p class=single-date><time datetime=2023-02-26T16:03:22+08:00>February 26, 2023</time></p></div></div></header><div class=single-content><p>这一类题目（具体题目可以参考文末的链接）要求我们从 <code>inorder</code>, <code>preorder</code> 及 <code>postorder</code> traversal 其中的两个构建出二叉树，之所以能够通过这三种遍历方式中的两个就构建出整棵二叉树，是因为任意两种遍历方式都能够帮助我们递归地找出当前 <code>subroot</code> 的 left 和 right subtree 的范围。而这要从这三种遍历方式的特点说起：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=font-weight:700;font-style:italic;text-decoration:underline>class</span> <span style=color:#666;font-weight:700;font-style:italic>TreeNode</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700;text-decoration:underline>int</span> val;  
</span></span><span style=display:flex><span>    TreeNode left;  
</span></span><span style=display:flex><span>    TreeNode right;  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TreeNode() {  
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TreeNode(<span style=font-weight:700;text-decoration:underline>int</span> val) {  
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>this</span>.val = val;  
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    TreeNode(<span style=font-weight:700;text-decoration:underline>int</span> val, TreeNode left, TreeNode right) {  
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>this</span>.val = val;  
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>this</span>.left = left;  
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>this</span>.right = right;  
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> <span style=font-weight:700;font-style:italic;text-decoration:underline>static</span> <span style=font-weight:700;text-decoration:underline>void</span> <span style=color:#666;font-weight:700;font-style:italic>preorder</span>(TreeNode root, List&lt;Integer&gt; list) {  
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (root == <span style=font-weight:700;text-decoration:underline>null</span>) {  
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span>;  
</span></span><span style=display:flex><span>        }  
</span></span><span style=display:flex><span>        list.add(root.val);  
</span></span><span style=display:flex><span>        preorder(root.left, list);  
</span></span><span style=display:flex><span>        preorder(root.right, list);  
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> <span style=font-weight:700;font-style:italic;text-decoration:underline>static</span> <span style=font-weight:700;text-decoration:underline>void</span> <span style=color:#666;font-weight:700;font-style:italic>postorder</span>(TreeNode root, List&lt;Integer&gt; list) {  
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (root == <span style=font-weight:700;text-decoration:underline>null</span>) {  
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span>;  
</span></span><span style=display:flex><span>        }  
</span></span><span style=display:flex><span>        postorder(root.left, list);  
</span></span><span style=display:flex><span>        postorder(root.right, list);  
</span></span><span style=display:flex><span>        list.add(root.val);  
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> <span style=font-weight:700;font-style:italic;text-decoration:underline>static</span> <span style=font-weight:700;text-decoration:underline>void</span> <span style=color:#666;font-weight:700;font-style:italic>inorder</span>(TreeNode root, List&lt;Integer&gt; list) {  
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (root == <span style=font-weight:700;text-decoration:underline>null</span>) {  
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span>;  
</span></span><span style=display:flex><span>        }  
</span></span><span style=display:flex><span>        inorder(root.left, list);  
</span></span><span style=display:flex><span>        list.add(root.val);  
</span></span><span style=display:flex><span>        inorder(root.right, list);  
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=table-outer><table><thead><tr><th></th><th><code>inorder</code></th><th><code>preorder</code></th><th><code>postorder</code></th></tr></thead><tbody><tr><td>节点遍历顺序</td><td><code>root.left</code> -> <code>root</code> -> <code>root.right</code></td><td><code>root</code> -> <code>root. left</code> -> <code>root.right</code></td><td><code>root.left</code> -> <code>root.right</code> -> <code>root</code></td></tr><tr><td>subroot 在 sublist 中的位置 （sublist 指遍历 subroot 所在的子树而构成的序列）</td><td>无法单独确定</td><td><code>sublist[0]</code></td><td><code>sublist[sublist.length - 1]</code></td></tr><tr><td>特性</td><td></td><td>根据 <code>preorder</code> 的特性，<code>subroot</code> 在当前子序列中的下一个元素一定是 <code>subroot.left</code> （如果还有的话），也就是 <code>subroot.left = sublist[1]</code></td><td>根据 <code>postorder</code> 的特性，<code>subroot</code> 在当前子序列中的前一个元素一定是 <code>subroot.right</code> （如果还有的话），也就是 <code>subroot.right = sublist[sublist.length - 2]</code></td></tr><tr><td>子序列情况</td><td><code>[左子树子序列][subroot][右子树子序列]</code></td><td><code>[subroot][左子树子序列][右子树子序列]</code></td><td><code>[左子树子序列][右子树子序列][subroot]</code></td></tr></tbody></table></div><p>我们可以总结出，可以很容易从 <code>preorder</code> 以及 <code>postorder</code> 序列中得到 <code>subroot</code> 的值，这是因为 <code>subroot</code> 在这两种递归算法中总是被优先以及最后处理的，所以 <code>subroot</code> 总是出现在子序列的开头或者末尾。</p><p>而 <code>inorder</code> 则无法单独判断出 <code>subroot</code> 的位置，但一旦从 <code>preorder</code> 和 <code>postorder</code> 中知道 <code>subroot</code> 的值，那么就可以轻松知道 <code>subroot</code> 的左子树和右子树的范围（在 <code>inorder</code> 序列中，找到 <code>subroot</code> 的 index，位于 index 左边的归属于左子树，右边的归属于右子树）。</p><p>而且，一旦我们知道了左子树和右子树的数组长度，我们就可以很轻易地计算出 <code>subroot.left</code> 以及 <code>subroot.right</code> 在 <code>preorder</code> 以及 <code>postorder</code> 数组中的下标了。</p><p>因此，我们也就可以递归地从 3 种遍历序列中构建出整棵二叉树。</p><h1 class=heading id=例题>例题
<a class=anchor href=#%e4%be%8b%e9%a2%98>#</a></h1><p><strong>Example 1</strong>: <a href=https://leetcode.com/problems/construct-binary-tree-from-%60preorder%60-and-%60inorder%60-traversal/>105. Construct Binary Tree from <code>preorder</code> and <code>inorder</code> Traversal</a></p><p><figure><div class=img-container style=--w:1020;--h:773><img loading=lazy alt src=/archive/6_leetcode_note_3_construct_bst_from_xxx_traversal/Pasted%20image%2020230226144205.png width=1020 height=773></div></figure></p><p>通过之前的讨论，我们通过 <code>preorder</code> 可以知道 <code>subroot</code> 的位置，那么，在 <code>inorder</code> 数组中找到 <code>subroot</code> 的 <code>index</code> ，位于 <code>index</code> 左边和右边的子序列就对应当前 <code>subroot</code> 的左子树以及右子树，确定左子树和右子树的范围也不再是难事。</p><p>算法如下：</p><ul><li><code>rootPreIndex</code> ： 当前 <code>subroot</code> 在 <code>inorder</code> 数组的 <code>index</code></li><li><code>inorderLeft</code> , <code>inorderRight</code> : 当前子树用到的 <code>inorder</code> 数组的左边界和右边界，用于控制递归终止的条件（base case）</li><li>找到 <code>subroot</code> 在 <code>inorder</code> 数组中的 <code>index</code> ： <code>rootInorderIndex</code></li><li>计算 <code>subroot.left</code> 子树的长度 <code>leftSubTreeSize = rootInorderIndex - inorderLeft</code></li><li>递归地构造左子树： <code>root.left = build(preorder, inorder, rootPreIndex + 1, inorderLeft, rootInorderIndex - 1);</code> ，其中：<ul><li><code>rootPreIndex + 1</code> 表示 <code>root.left</code> 在 <code>preorder</code> 数组的 <code>index</code> ；</li><li>左子树在 <code>inorder</code> 数组中的左边界和当前 <code>subroot</code> 是共享的： <code>inorderLeft</code> ；</li><li>左子树在 <code>inorder</code> 数组中的右边界应该是 <code>subroot</code> 在 <code>inorder</code> 数组中的 <code>index</code> 减去 1： <code>rootInorderIndex - 1</code> ；</li><li>也就是 <code>[inorderLeft, rootInorderIndex - 1]</code> 是左子树在 <code>inorder</code> 数组中的范围；</li></ul></li><li>递归地构造右子树： <code>root.right = build(preorder, inorder, rootPreIndex + leftSubTreeSize + 1, rootInorderIndex + 1, inorderRight);</code> ，其中：<ul><li><code>subroot.right</code> 在 <code>preorder</code> 数组中的 <code>index</code> 应该是 <code>rootPreIndex</code> 加上 <code>subroot</code> 的左子树的长度： <code>subrootPreIndex + leftSubTreeSize + 1</code> ；</li><li><code>subroot.right</code> 在 <code>inorder</code> 数组中的左边界应该是 <code>rootInorderIndex + 1</code> ；</li><li><code>subroot.right</code> 在 <code>inorder</code> 数组中的右边界应该是和当前 <code>subroot</code> 共享的，因此</li><li><code>[rootInorderIndex + 1, inorderRight]</code> 是右子树在 <code>inorder</code> 数组中的范围</li></ul></li></ul><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=font-weight:700;font-style:italic;text-decoration:underline>class</span> <span style=color:#666;font-weight:700;font-style:italic>Solution</span> {
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> TreeNode <span style=color:#666;font-weight:700;font-style:italic>buildTree</span>(<span style=font-weight:700;text-decoration:underline>int</span>[] preorder, <span style=font-weight:700;text-decoration:underline>int</span>[] inorder) {
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>return</span> build(preorder, inorder, 0, 0, inorder.length - 1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> TreeNode <span style=color:#666;font-weight:700;font-style:italic>build</span>(<span style=font-weight:700;text-decoration:underline>int</span>[] preorder, <span style=font-weight:700;text-decoration:underline>int</span>[] inorder, <span style=font-weight:700;text-decoration:underline>int</span> rootPreIndex, <span style=font-weight:700;text-decoration:underline>int</span> inorderLeft, <span style=font-weight:700;text-decoration:underline>int</span> inorderRight) {
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (inorderLeft &gt; inorderRight || rootPreIndex &lt; 0 || rootPreIndex &gt;= preorder.length) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> <span style=font-weight:700;text-decoration:underline>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        TreeNode root = <span style=font-weight:700;text-decoration:underline>new</span> TreeNode(preorder[rootPreIndex]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>int</span> rootInorderIndex = -1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>for</span> (<span style=font-weight:700;text-decoration:underline>int</span> i = 0; i &lt; inorder.length; ++i) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>if</span> (inorder[i] == root.val) {
</span></span><span style=display:flex><span>                rootInorderIndex = i;
</span></span><span style=display:flex><span>                <span style=font-weight:700;text-decoration:underline>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>int</span> leftSubTreeSize = rootInorderIndex - inorderLeft;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        root.left = build(preorder, inorder, rootPreIndex + 1, inorderLeft, rootInorderIndex - 1);
</span></span><span style=display:flex><span>        root.right = build(preorder, inorder, rootPreIndex + leftSubTreeSize + 1, rootInorderIndex + 1, inorderRight);
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>return</span> root;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Example 2</strong>: <a href=https://leetcode.com/problems/construct-binary-tree-from-%60preorder%60-and-%60postorder%60-traversal/>889. Construct Binary Tree from preorder and postorder Traversal</a></p><p><figure><div class=img-container style=--w:1020;--h:781><img loading=lazy alt src=/archive/6_leetcode_note_3_construct_bst_from_xxx_traversal/Pasted%20image%2020230226152220.png width=1020 height=781></div></figure></p><p>这道题目和之前的类似，只不过换成了 <code>preorder</code> 和 <code>postorder</code> 的组合，这也导致我们能够利用的信息有了变化：我们不再能通过 <code>inorder</code> 计算出左子树以及右子树的长度了，我们得通过另外的途径来进行计算。</p><p>之前也有提到过， <code>preoder</code> 和 <code>postorder</code> 有一个特性，就是：</p><ul><li>① 假设 <code>subroot</code> 在 <code>preorder</code> 中的下标是 <code>rootPreIndex</code> ，那么 <code>subroot.left</code> 在 <code>preorder</code> 中的下标一定是 <code>rootPreIndex + 1</code> ；</li><li>② 假设 <code>subroot</code> 在 <code>postorder</code> 中的下标是 <code>rootPostIndex</code> ，那么 <code>subroot.right</code> 在 <code>postorder</code> 的下标一定是 <code>rootPostIndex - 1</code> ；</li></ul><p>我们再结合两种遍历所构成的子序列的情况一起分析：</p><ul><li>③ <code>preorder</code> 子序列情况： <code>[subroot][左子树子序列][右子树子序列]</code></li><li>④ <code>postorder</code> 子序列情况： <code>[左子树子序列][右子树子序列][subroot]</code></li></ul><p>那么，我们可以通过结合 ② 和 ③，可以导出：</p><ul><li>我们通过 ② 知道了 <code>subroot.right</code> 的值，就可以得到它在 <code>preorder</code> 中的位置，它位于 <code>preorder</code> 数组中 <code>[右子树子序列]</code> 的第一个位置；</li><li>既然知道了右子树在 <code>preorder</code> 中的位置，那么左子树的长度就可以通过： <code>rightSubrootPreIndex - subrootPreIndex - 1</code> 得到；</li><li>右子树的长度当然也可以通过当前 <code>preorder</code> 的右边界减去 <code>subroot.right</code> 在 <code>preorder</code> 中的 <code>index</code> 得到</li></ul><p>同样，我们结合 ① 和 ④，也可以推断得到：</p><ul><li>我们通过 ① 知道了 <code>subroot.left</code> 的值，那么就可以知道 <code>subroot.left</code> 在 <code>postorder</code> 数组中的位置，它一定处在 <code>postorder</code> 数组中的 <code>[左子树子序列] </code>的最后一个位置；</li><li>既然知道了左子树序列的首尾位置，那么就可以计算出左子树的长度： <code>leftSubrootPostIndex - postLeft + 1</code> ；</li></ul><p>那么，现在我们获得了递归算法所需的一切条件：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=font-weight:700;font-style:italic;text-decoration:underline>class</span> <span style=color:#666;font-weight:700;font-style:italic>Solution</span> {
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>public</span> TreeNode <span style=color:#666;font-weight:700;font-style:italic>constructFromPrePost</span>(<span style=font-weight:700;text-decoration:underline>int</span>[] preorder, <span style=font-weight:700;text-decoration:underline>int</span>[] postorder) {
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>return</span> build(preorder, postorder, 0, preorder.length - 1, 0, postorder.length - 1);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700;font-style:italic;text-decoration:underline>private</span> TreeNode <span style=color:#666;font-weight:700;font-style:italic>build</span>(<span style=font-weight:700;text-decoration:underline>int</span>[] pre, <span style=font-weight:700;text-decoration:underline>int</span>[] post, <span style=font-weight:700;text-decoration:underline>int</span> preLeft, <span style=font-weight:700;text-decoration:underline>int</span> preRight, <span style=font-weight:700;text-decoration:underline>int</span> postLeft, <span style=font-weight:700;text-decoration:underline>int</span> postRight) {
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (preLeft &gt; preRight) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> <span style=font-weight:700;text-decoration:underline>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        TreeNode root = <span style=font-weight:700;text-decoration:underline>new</span> TreeNode(pre[preLeft]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>if</span> (preLeft + 1 &gt; preRight) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>return</span> root;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>int</span> leftSubRootPostIndex;
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>for</span> (leftSubRootPostIndex = postLeft; leftSubRootPostIndex &lt;= postRight; ++leftSubRootPostIndex) {
</span></span><span style=display:flex><span>            <span style=font-weight:700;text-decoration:underline>if</span> (post[leftSubRootPostIndex] == pre[preLeft + 1]) {
</span></span><span style=display:flex><span>                <span style=font-weight:700;text-decoration:underline>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>int</span> leftSubtreeLength = leftSubRootPostIndex - postLeft + 1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        root.left = build(pre, post, preLeft + 1, preLeft + leftSubtreeLength, postLeft, postLeft + leftSubtreeLength - 1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        root.right = build(pre, post, preLeft + leftSubtreeLength + 1, preRight, postLeft + leftSubtreeLength, postRight - 1);
</span></span><span style=display:flex><span>        <span style=font-weight:700;text-decoration:underline>return</span> root;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 class=heading id=题目>题目
<a class=anchor href=#%e9%a2%98%e7%9b%ae>#</a></h1><ul><li><a href=https://leetcode.com/problems/construct-binary-tree-from-%60preorder%60-and-%60inorder%60-traversal/>105. Construct Binary Tree from preorder and inorder Traversal</a></li><li><a href=https://leetcode.com/problems/construct-binary-tree-from-%60inorder%60-and-%60postorder%60-traversal/>106. Construct Binary Tree from inorder and postorder Traversal</a></li><li><a href=https://leetcode.com/problems/construct-binary-tree-from-%60preorder%60-and-%60postorder%60-traversal/>889. Construct Binary Tree from preorder and postorder Traversal</a></li><li><a href=https://leetcode.com/problems/construct-binary-search-tree-from-%60preorder%60-traversal/>1008. Construct Binary Search Tree from preorder Traversal</a></li></ul></div></article><div class=single-comments><script src=https://giscus.app/client.js data-repo data-repo-id data-category data-category-id data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><div class=single-pagination><hr><div class=flexnowrap><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text>←</div><div class=single-pagination-text><a href=/archive/4_implement_atomic_and_durable/>本地事务的原子性和持久性是如何实现的</a></div></div></div><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text><a href=/archive/7_mysql_innodb_bin_redo_undo_log/>MySQL InnoDB Bin Log, Redo Log, Undo Log 详解</a></div><div class=single-pagination-text>→</div></div></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>Powered by
<a href=https://gohugo.io/>Hugo</a>
and
<a href=https://github.com/tomfran/typo>tomfran/typo</a></p></footer></body><script src=/js/theme-switch.js></script><script defer src=/js/copy-code.js></script></html>