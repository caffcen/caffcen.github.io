<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>LeetCode 笔记 3：Construct Binary Tree from xxx Traversal | Lihang Liu&#39;s Homepage</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="这一类题目（具体题目可以参考文末的链接）要求我们从 inorder, preorder 及 postorder traversal 其中的两个构建出二叉树，之所以能够通过这三种遍历方式中的两个就构建出整棵二叉树，是因为任意两种遍历方式都能够帮助我们递归地找出当前 subroot 的 left 和 right subtree 的范围。而这要从这三种遍历方式的特点说起：
class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() { } TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } public static void preorder(TreeNode root, List&lt;Integer&gt; list) { if (root == null) { return; } list.add(root.val); preorder(root.left, list); preorder(root.right, list); } public static void postorder(TreeNode root, List&lt;Integer&gt; list) { if (root == null) { return; } postorder(root.">
    <meta name="generator" content="Hugo 0.125.7">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="https://caffcen.github.io/archive/6_leetcode_note_3_construct_bst_from_xxx_traversal/">
    

    <meta property="og:url" content="https://caffcen.github.io/archive/6_leetcode_note_3_construct_bst_from_xxx_traversal/">
  <meta property="og:site_name" content="Lihang Liu&#39;s Homepage">
  <meta property="og:title" content="LeetCode 笔记 3：Construct Binary Tree from xxx Traversal">
  <meta property="og:description" content="这一类题目（具体题目可以参考文末的链接）要求我们从 inorder, preorder 及 postorder traversal 其中的两个构建出二叉树，之所以能够通过这三种遍历方式中的两个就构建出整棵二叉树，是因为任意两种遍历方式都能够帮助我们递归地找出当前 subroot 的 left 和 right subtree 的范围。而这要从这三种遍历方式的特点说起：
class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() { } TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } public static void preorder(TreeNode root, List&lt;Integer&gt; list) { if (root == null) { return; } list.add(root.val); preorder(root.left, list); preorder(root.right, list); } public static void postorder(TreeNode root, List&lt;Integer&gt; list) { if (root == null) { return; } postorder(root.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="archive">
    <meta property="article:published_time" content="2023-02-26T16:03:22+08:00">
    <meta property="article:modified_time" content="2023-02-26T16:03:22+08:00">

  <meta itemprop="name" content="LeetCode 笔记 3：Construct Binary Tree from xxx Traversal">
  <meta itemprop="description" content="这一类题目（具体题目可以参考文末的链接）要求我们从 inorder, preorder 及 postorder traversal 其中的两个构建出二叉树，之所以能够通过这三种遍历方式中的两个就构建出整棵二叉树，是因为任意两种遍历方式都能够帮助我们递归地找出当前 subroot 的 left 和 right subtree 的范围。而这要从这三种遍历方式的特点说起：
class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() { } TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } public static void preorder(TreeNode root, List&lt;Integer&gt; list) { if (root == null) { return; } list.add(root.val); preorder(root.left, list); preorder(root.right, list); } public static void postorder(TreeNode root, List&lt;Integer&gt; list) { if (root == null) { return; } postorder(root.">
  <meta itemprop="datePublished" content="2023-02-26T16:03:22+08:00">
  <meta itemprop="dateModified" content="2023-02-26T16:03:22+08:00">
  <meta itemprop="wordCount" content="774"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="LeetCode 笔记 3：Construct Binary Tree from xxx Traversal">
<meta name="twitter:description" content="这一类题目（具体题目可以参考文末的链接）要求我们从 inorder, preorder 及 postorder traversal 其中的两个构建出二叉树，之所以能够通过这三种遍历方式中的两个就构建出整棵二叉树，是因为任意两种遍历方式都能够帮助我们递归地找出当前 subroot 的 left 和 right subtree 的范围。而这要从这三种遍历方式的特点说起：
class TreeNode { int val; TreeNode left; TreeNode right; TreeNode() { } TreeNode(int val) { this.val = val; } TreeNode(int val, TreeNode left, TreeNode right) { this.val = val; this.left = left; this.right = right; } public static void preorder(TreeNode root, List&lt;Integer&gt; list) { if (root == null) { return; } list.add(root.val); preorder(root.left, list); preorder(root.right, list); } public static void postorder(TreeNode root, List&lt;Integer&gt; list) { if (root == null) { return; } postorder(root.">

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Lihang Liu&#39;s Homepage
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Archives
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">LeetCode 笔记 3：Construct Binary Tree from xxx Traversal</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2023-02-26T16:03:22+08:00">February 26, 2023</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>这一类题目（具体题目可以参考文末的链接）要求我们从 <code>inorder</code>, <code>preorder</code> 及 <code>postorder</code> traversal 其中的两个构建出二叉树，之所以能够通过这三种遍历方式中的两个就构建出整棵二叉树，是因为任意两种遍历方式都能够帮助我们递归地找出当前 <code>subroot</code> 的 left 和 right subtree 的范围。而这要从这三种遍历方式的特点说起：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TreeNode</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> val;  
</span></span><span style="display:flex;"><span>    TreeNode left;  
</span></span><span style="display:flex;"><span>    TreeNode right;  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    TreeNode() {  
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    TreeNode(<span style="color:#66d9ef">int</span> val) {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">val</span> <span style="color:#f92672">=</span> val;  
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    TreeNode(<span style="color:#66d9ef">int</span> val, TreeNode left, TreeNode right) {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">val</span> <span style="color:#f92672">=</span> val;  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> left;  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> right;  
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">preorder</span>(TreeNode root, List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list) {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>        list.<span style="color:#a6e22e">add</span>(root.<span style="color:#a6e22e">val</span>);  
</span></span><span style="display:flex;"><span>        preorder(root.<span style="color:#a6e22e">left</span>, list);  
</span></span><span style="display:flex;"><span>        preorder(root.<span style="color:#a6e22e">right</span>, list);  
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">postorder</span>(TreeNode root, List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list) {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>        postorder(root.<span style="color:#a6e22e">left</span>, list);  
</span></span><span style="display:flex;"><span>        postorder(root.<span style="color:#a6e22e">right</span>, list);  
</span></span><span style="display:flex;"><span>        list.<span style="color:#a6e22e">add</span>(root.<span style="color:#a6e22e">val</span>);  
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">inorder</span>(TreeNode root, List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list) {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {  
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;  
</span></span><span style="display:flex;"><span>        }  
</span></span><span style="display:flex;"><span>        inorder(root.<span style="color:#a6e22e">left</span>, list);  
</span></span><span style="display:flex;"><span>        list.<span style="color:#a6e22e">add</span>(root.<span style="color:#a6e22e">val</span>);  
</span></span><span style="display:flex;"><span>        inorder(root.<span style="color:#a6e22e">right</span>, list);  
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><table>
<thead>
<tr>
<th></th>
<th><code>inorder</code></th>
<th><code>preorder</code></th>
<th><code>postorder</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>节点遍历顺序</td>
<td><code>root.left</code> -&gt; <code>root</code> -&gt; <code>root.right</code></td>
<td><code>root</code> -&gt; <code> root. left</code> -&gt; <code>root.right</code></td>
<td><code>root.left</code> -&gt; <code>root.right</code> -&gt; <code>root</code></td>
</tr>
<tr>
<td>subroot 在 sublist 中的位置 （sublist 指遍历 subroot 所在的子树而构成的序列）</td>
<td>无法单独确定</td>
<td><code>sublist[0]</code></td>
<td><code>sublist[sublist.length - 1]</code></td>
</tr>
<tr>
<td>特性</td>
<td></td>
<td>根据 <code>preorder</code> 的特性，<code>subroot</code> 在当前子序列中的下一个元素一定是 <code>subroot.left</code> （如果还有的话），也就是 <code>subroot.left = sublist[1]</code></td>
<td>根据 <code>postorder</code> 的特性，<code>subroot</code> 在当前子序列中的前一个元素一定是 <code>subroot.right</code> （如果还有的话），也就是 <code>subroot.right = sublist[sublist.length - 2]</code></td>
</tr>
<tr>
<td>子序列情况</td>
<td><code>[左子树子序列][subroot][右子树子序列]</code></td>
<td><code>[subroot][左子树子序列][右子树子序列]</code></td>
<td><code>[左子树子序列][右子树子序列][subroot]</code></td>
</tr>
</tbody>
</table>
<p>我们可以总结出，可以很容易从 <code>preorder</code> 以及 <code>postorder</code> 序列中得到 <code>subroot</code> 的值，这是因为 <code>subroot</code> 在这两种递归算法中总是被优先以及最后处理的，所以 <code>subroot</code> 总是出现在子序列的开头或者末尾。</p>
<p>而 <code>inorder</code> 则无法单独判断出 <code>subroot</code> 的位置，但一旦从 <code>preorder</code> 和 <code>postorder</code> 中知道 <code>subroot</code> 的值，那么就可以轻松知道 <code>subroot</code> 的左子树和右子树的范围（在 <code>inorder</code> 序列中，找到 <code>subroot</code> 的 index，位于 index 左边的归属于左子树，右边的归属于右子树）。</p>
<p>而且，一旦我们知道了左子树和右子树的数组长度，我们就可以很轻易地计算出 <code>subroot.left</code> 以及 <code>subroot.right</code> 在 <code>preorder</code> 以及 <code>postorder</code> 数组中的下标了。</p>
<p>因此，我们也就可以递归地从 3 种遍历序列中构建出整棵二叉树。</p>
<h1 id="例题">例题</h1>
<p><strong>Example 1</strong>: <a href="https://leetcode.com/problems/construct-binary-tree-from-%60preorder%60-and-%60inorder%60-traversal/">105. Construct Binary Tree from <code>preorder</code> and <code>inorder</code> Traversal</a></p>
<p><img src="Pasted%20image%2020230226144205.png" alt=""></p>
<p>通过之前的讨论，我们通过 <code>preorder</code> 可以知道 <code>subroot</code> 的位置，那么，在 <code>inorder</code> 数组中找到 <code>subroot</code> 的 <code>index</code> ，位于 <code>index</code> 左边和右边的子序列就对应当前 <code>subroot</code> 的左子树以及右子树，确定左子树和右子树的范围也不再是难事。</p>
<p>算法如下：</p>
<ul>
<li><code>rootPreIndex</code> ： 当前 <code>subroot</code> 在 <code>inorder</code> 数组的 <code>index</code></li>
<li><code>inorderLeft</code> , <code>inorderRight</code> : 当前子树用到的 <code>inorder</code> 数组的左边界和右边界，用于控制递归终止的条件（base case）</li>
<li>找到 <code>subroot</code> 在 <code>inorder</code> 数组中的 <code>index</code> ： <code>rootInorderIndex</code></li>
<li>计算 <code>subroot.left</code> 子树的长度 <code>leftSubTreeSize = rootInorderIndex - inorderLeft</code></li>
<li>递归地构造左子树： <code>root.left = build(preorder, inorder, rootPreIndex + 1, inorderLeft, rootInorderIndex - 1);</code> ，其中：
<ul>
<li><code>rootPreIndex + 1</code> 表示 <code>root.left</code> 在 <code>preorder</code> 数组的 <code>index</code> ；</li>
<li>左子树在 <code>inorder</code> 数组中的左边界和当前 <code>subroot</code> 是共享的： <code>inorderLeft</code> ；</li>
<li>左子树在 <code>inorder</code> 数组中的右边界应该是 <code>subroot</code> 在 <code>inorder</code> 数组中的 <code>index</code> 减去 1： <code>rootInorderIndex - 1</code> ；</li>
<li>也就是 <code>[inorderLeft, rootInorderIndex - 1]</code> 是左子树在 <code>inorder</code> 数组中的范围；</li>
</ul>
</li>
<li>递归地构造右子树： <code>root.right = build(preorder, inorder, rootPreIndex + leftSubTreeSize + 1, rootInorderIndex + 1, inorderRight);</code> ，其中：
<ul>
<li><code>subroot.right</code> 在 <code>preorder</code> 数组中的 <code>index</code> 应该是 <code>rootPreIndex</code> 加上 <code>subroot</code> 的左子树的长度： <code>subrootPreIndex + leftSubTreeSize + 1</code> ；</li>
<li><code>subroot.right</code> 在 <code>inorder</code> 数组中的左边界应该是 <code>rootInorderIndex + 1</code> ；</li>
<li><code>subroot.right</code> 在 <code>inorder</code> 数组中的右边界应该是和当前 <code>subroot</code> 共享的，因此</li>
<li><code>[rootInorderIndex + 1, inorderRight]</code> 是右子树在 <code>inorder</code> 数组中的范围</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">buildTree</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> preorder, <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> inorder) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> build(preorder, inorder, 0, 0, inorder.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">build</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> preorder, <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> inorder, <span style="color:#66d9ef">int</span> rootPreIndex, <span style="color:#66d9ef">int</span> inorderLeft, <span style="color:#66d9ef">int</span> inorderRight) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (inorderLeft <span style="color:#f92672">&gt;</span> inorderRight <span style="color:#f92672">||</span> rootPreIndex <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span> rootPreIndex <span style="color:#f92672">&gt;=</span> preorder.<span style="color:#a6e22e">length</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        TreeNode root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode(preorder<span style="color:#f92672">[</span>rootPreIndex<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> rootInorderIndex <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> inorder.<span style="color:#a6e22e">length</span>; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (inorder<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> root.<span style="color:#a6e22e">val</span>) {
</span></span><span style="display:flex;"><span>                rootInorderIndex <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> leftSubTreeSize <span style="color:#f92672">=</span> rootInorderIndex <span style="color:#f92672">-</span> inorderLeft;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        root.<span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> build(preorder, inorder, rootPreIndex <span style="color:#f92672">+</span> 1, inorderLeft, rootInorderIndex <span style="color:#f92672">-</span> 1);
</span></span><span style="display:flex;"><span>        root.<span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> build(preorder, inorder, rootPreIndex <span style="color:#f92672">+</span> leftSubTreeSize <span style="color:#f92672">+</span> 1, rootInorderIndex <span style="color:#f92672">+</span> 1, inorderRight);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Example 2</strong>: <a href="https://leetcode.com/problems/construct-binary-tree-from-%60preorder%60-and-%60postorder%60-traversal/">889. Construct Binary Tree from preorder and postorder Traversal</a></p>
<p><img src="Pasted%20image%2020230226152220.png" alt=""></p>
<p>这道题目和之前的类似，只不过换成了 <code>preorder</code> 和 <code>postorder</code> 的组合，这也导致我们能够利用的信息有了变化：我们不再能通过 <code>inorder</code> 计算出左子树以及右子树的长度了，我们得通过另外的途径来进行计算。</p>
<p>之前也有提到过， <code>preoder</code> 和 <code>postorder</code> 有一个特性，就是：</p>
<ul>
<li>① 假设 <code>subroot</code> 在 <code>preorder</code> 中的下标是 <code>rootPreIndex</code> ，那么 <code>subroot.left</code> 在 <code>preorder</code> 中的下标一定是 <code>rootPreIndex + 1</code> ；</li>
<li>② 假设 <code>subroot</code> 在 <code>postorder</code> 中的下标是 <code>rootPostIndex</code> ，那么 <code>subroot.right</code> 在 <code>postorder</code> 的下标一定是 <code>rootPostIndex - 1</code> ；</li>
</ul>
<p>我们再结合两种遍历所构成的子序列的情况一起分析：</p>
<ul>
<li>③ <code>preorder</code> 子序列情况： <code>[subroot][左子树子序列][右子树子序列]</code></li>
<li>④ <code>postorder</code> 子序列情况： <code>[左子树子序列][右子树子序列][subroot]</code></li>
</ul>
<p>那么，我们可以通过结合 ② 和 ③，可以导出：</p>
<ul>
<li>我们通过 ② 知道了 <code>subroot.right</code> 的值，就可以得到它在 <code>preorder</code> 中的位置，它位于 <code>preorder</code> 数组中 <code>[右子树子序列]</code> 的第一个位置；</li>
<li>既然知道了右子树在 <code>preorder</code> 中的位置，那么左子树的长度就可以通过： <code>rightSubrootPreIndex - subrootPreIndex - 1</code> 得到；</li>
<li>右子树的长度当然也可以通过当前 <code>preorder</code> 的右边界减去 <code>subroot.right</code> 在 <code>preorder</code> 中的 <code>index</code> 得到</li>
</ul>
<p>同样，我们结合 ① 和 ④，也可以推断得到：</p>
<ul>
<li>我们通过 ① 知道了 <code>subroot.left</code> 的值，那么就可以知道 <code>subroot.left</code> 在 <code>postorder</code> 数组中的位置，它一定处在 <code>postorder</code> 数组中的 <code>[左子树子序列] </code> 的最后一个位置；</li>
<li>既然知道了左子树序列的首尾位置，那么就可以计算出左子树的长度： <code>leftSubrootPostIndex - postLeft + 1</code> ；</li>
</ul>
<p>那么，现在我们获得了递归算法所需的一切条件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">constructFromPrePost</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> preorder, <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> postorder) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> build(preorder, postorder, 0, preorder.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1, 0, postorder.<span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> TreeNode <span style="color:#a6e22e">build</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> pre, <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> post, <span style="color:#66d9ef">int</span> preLeft, <span style="color:#66d9ef">int</span> preRight, <span style="color:#66d9ef">int</span> postLeft, <span style="color:#66d9ef">int</span> postRight) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (preLeft <span style="color:#f92672">&gt;</span> preRight) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        TreeNode root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode(pre<span style="color:#f92672">[</span>preLeft<span style="color:#f92672">]</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (preLeft <span style="color:#f92672">+</span> 1 <span style="color:#f92672">&gt;</span> preRight) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> leftSubRootPostIndex;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (leftSubRootPostIndex <span style="color:#f92672">=</span> postLeft; leftSubRootPostIndex <span style="color:#f92672">&lt;=</span> postRight; <span style="color:#f92672">++</span>leftSubRootPostIndex) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (post<span style="color:#f92672">[</span>leftSubRootPostIndex<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> pre<span style="color:#f92672">[</span>preLeft <span style="color:#f92672">+</span> 1<span style="color:#f92672">]</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> leftSubtreeLength <span style="color:#f92672">=</span> leftSubRootPostIndex <span style="color:#f92672">-</span> postLeft <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        root.<span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> build(pre, post, preLeft <span style="color:#f92672">+</span> 1, preLeft <span style="color:#f92672">+</span> leftSubtreeLength, postLeft, postLeft <span style="color:#f92672">+</span> leftSubtreeLength <span style="color:#f92672">-</span> 1);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        root.<span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> build(pre, post, preLeft <span style="color:#f92672">+</span> leftSubtreeLength <span style="color:#f92672">+</span> 1, preRight, postLeft <span style="color:#f92672">+</span> leftSubtreeLength, postRight <span style="color:#f92672">-</span> 1);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="题目">题目</h1>
<ul>
<li><a href="https://leetcode.com/problems/construct-binary-tree-from-%60preorder%60-and-%60inorder%60-traversal/">105. Construct Binary Tree from preorder and inorder Traversal</a></li>
<li><a href="https://leetcode.com/problems/construct-binary-tree-from-%60inorder%60-and-%60postorder%60-traversal/">106. Construct Binary Tree from inorder and postorder Traversal</a></li>
<li><a href="https://leetcode.com/problems/construct-binary-tree-from-%60preorder%60-and-%60postorder%60-traversal/">889. Construct Binary Tree from preorder and postorder Traversal</a></li>
<li><a href="https://leetcode.com/problems/construct-binary-search-tree-from-%60preorder%60-traversal/">1008. Construct Binary Search Tree from preorder Traversal</a></li>
</ul>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="https://caffcen.github.io/" >
    &copy;  Lihang Liu's Homepage 2024 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
